{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Lamassu Iot Docs Lamassu is an IoT first PKI designed for industrial scenarios. Public key infrastructure are systems in charge of creating, storing and distributing digital certificates which are used to verify that a particular public key belongs to a certain entity. PKIs creates digital certificates which map to public keys to entities, securely stores these certificates in a central repository and revokes them if needed.","title":"Welcome to Lamassu Iot Docs"},{"location":"#welcome-to-lamassu-iot-docs","text":"Lamassu is an IoT first PKI designed for industrial scenarios. Public key infrastructure are systems in charge of creating, storing and distributing digital certificates which are used to verify that a particular public key belongs to a certain entity. PKIs creates digital certificates which map to public keys to entities, securely stores these certificates in a central repository and revokes them if needed.","title":"Welcome to Lamassu Iot Docs"},{"location":"architecture/","text":"Architecture Core Services Lamassu has been designed to be modular and keep the core services as simple as possible encapsulating on each service a set of well defined responsibilities. The core services are those that bring the main functionalities of a modern PKI for industrial IoT use cases. The core services are: CA The Certificate Authority is the service in charge of issuing and managing the life cycle of the certificate. This service manages two different types of certificates: PKI Certificates : This kind of certificates are used by regular end entities such as the devices that connect to the PKI. Internal Certificates : In contrast with the previous type of certificates, these certificate authorities have a more restricted use. Their creation should be limited to the most trusted entities of the PKI. For instance, DMS certificates are issued by an internal CA named LAMASSU-DMS-MANAGER that is created on boot up. For the moment this is the only internal CA that is supported by Lamassu, but we are exploring the possibility of managing the certificates used by the services themselves. On top of the regular functionalities that can be performed on this service such as creating new CAs, issuing or revoking certificates, this service is in charge of maintaining an accurate state of the managed entities (both CA certificates and regular certificates). In order to do so, a periodic task is scheduled once a day to check the status of validity of all certificates. Warning This feature does not perform well on deployments that have issued many certificates as it is performed on a sequential single threaded process. We are working on a solution to improve this. There are 4 different status that a certificate can have: The Active state indicates that a certificate is valid and can be trusted by end entities. The Expired state indicates that a certificate has reached its expiration date and is no longer valid and cannot be trusted anymore. The Revoked state is used by PKI admins when a security incident or unexpected situations arise and the certificate or CA certificate is no longer trusted. Recently a new state has been added to the CA service, the About to expire state. This state indicates, as the name suggests, that the certificate will expire shortly. The current threshold is set to 30 days and cannot be configured. This state doesn't affect the validity of the certificate, but it is used to notify the PKI admins that the certificate is about to expire and they should take action. The CA service uses a relational database to store the issued certificates and basic information regarding the provisioned CAs. To configure the database connection, set the following environment variables: Environment Variable Description POSTGRES_HOSTNAME Hostname or address to connect to a running postgres database POSTGRES_PORT Port for the postgres instance POSTGRES_DATABASE Database to use POSTGRES_USERNAME Username credentials POSTGRES_PASSWORD Password credentials This service has been redesigned to support multiple crypto engines backends. Originally the only supported engine was the one provided by Hashicorp Vault, but the new redesign implementation allows for a more flexible golang like approach, that is by using the crypto.Signer interface. Any new crypto engine can be added by implementing this interface. To provision the CA service with a crypto engine set the following environment variable: Environment Variable Description ENGINE pkcs11 | gopem | vault The current supported crypto engines are: pkcs11 : To Use the HSM crypto engine, define the following environment variables before launching the CA service: Environment Variable Description PKCS11_DRIVER Path to the PKCS11 driver file PKCS11_LABEL Label used by the token to be used PKCS11_PIN PIN code to login and operate the token gopem - Files Environment Variable Description GOPEM_DATA Directory where the generated private keys belonging to each CA are stored Although this new design is easier to maintain and operate, we are also keeping the previous implementation of the Hashicorp Vault that does not follow the new interface. The reason being that in order to provide a Vault implementation that follows the new interface, the Enterprise Vault license is required. This is a limitation that we are working on to overcome with the new crypto engine design. The new standard deployment deprecates the use of Vault as the main backend and instead a Software HSM known as SoftHSM v2 . vault - Hashicorp Vault Environment Variable Description VAULT_ADDRESS Protocol, hostname and port to a vault instance: https://vault:8200 VAULT_ROLE_ID Role ID used by the CA service to login to vault VAULT_SECRET_ID Secret ID used by the CA service to login to vault VAULT_CA Path to the CA certificate file for https connections VAULT_UNSEAL_KEY_FILE Path to the unseal vault keys VAULT_PKI_CA_PATH Prefix to use while creating new PKI vault secrets DMS Manager The DMS Manager is the service in charge of managing the Registration Authority of the PKI. Instead of having a centralized Registration Authority, Lamassu uses a decentralized approach to be easily integrated by Device Manufacturing Systems. This way, each DMS has the authority to request the issuance of a certificate for a device being manufactured. Instead of relying on just one registration authority, Lamassu delegates the authorization of the issuance to the Local Registration Authority or LRA . Each DMS is entitled to authorize the issuance of a certificate to a subset of CAs of the entire PKI defined by the administrator. Each DMS has a list of authorized CAs that may be used during the enrollment process. Once an enrollment process is initiated, the PKI will check that the provided DMS certificate is authorized to issue certificates for the requested CA. The authorization list can be updated to add newly created CAs or remove CAs that are no longer needed. The DMS certificates that are used to authenticate the DMS are issued by an internal CA named LAMASSU-DMS-MANAGER . This CA is created by default when the PKI is deployed as stated earlier. Device manager At its core, the device manager is the main entry point for the enrollment process. It implements the EST protocol that must be used to obtain new certificates. On top of that, this service manages the registration of new devices and to keep a track of the device status. Similar to the CA service, the device manager also schedules a periodic task to check the status of the devices. This task is launched once a day to check the status of validity of all certificates associated by each device. Warning This feature does not perform well on deployments that have issued many certificates as it is performed on a sequential single threaded process. We are working on a solution to improve this. There are 5 different status a device can have: The Pending Provisioning state reflects that a device entity has been created but no certificate has been issued yet. The Fully Provisioned state indicates that a device has all the device slots with active certificates. The With warnings state indicates that a device has one or more slots with certificates that are either expired or have been revoked. The Requires Action state indicates that a device has one or more slots with certificates that are about to expire. The Decommissioned state indicates that a device has been decommissioned and no longer needs to be tracked by the PKI. Cloud Proxy Alerts OCSP Cloud Providers Add-ons","title":"Architecture"},{"location":"architecture/#architecture","text":"","title":"Architecture"},{"location":"architecture/#core-services","text":"Lamassu has been designed to be modular and keep the core services as simple as possible encapsulating on each service a set of well defined responsibilities. The core services are those that bring the main functionalities of a modern PKI for industrial IoT use cases. The core services are:","title":"Core Services"},{"location":"architecture/#ca","text":"The Certificate Authority is the service in charge of issuing and managing the life cycle of the certificate. This service manages two different types of certificates: PKI Certificates : This kind of certificates are used by regular end entities such as the devices that connect to the PKI. Internal Certificates : In contrast with the previous type of certificates, these certificate authorities have a more restricted use. Their creation should be limited to the most trusted entities of the PKI. For instance, DMS certificates are issued by an internal CA named LAMASSU-DMS-MANAGER that is created on boot up. For the moment this is the only internal CA that is supported by Lamassu, but we are exploring the possibility of managing the certificates used by the services themselves. On top of the regular functionalities that can be performed on this service such as creating new CAs, issuing or revoking certificates, this service is in charge of maintaining an accurate state of the managed entities (both CA certificates and regular certificates). In order to do so, a periodic task is scheduled once a day to check the status of validity of all certificates. Warning This feature does not perform well on deployments that have issued many certificates as it is performed on a sequential single threaded process. We are working on a solution to improve this. There are 4 different status that a certificate can have: The Active state indicates that a certificate is valid and can be trusted by end entities. The Expired state indicates that a certificate has reached its expiration date and is no longer valid and cannot be trusted anymore. The Revoked state is used by PKI admins when a security incident or unexpected situations arise and the certificate or CA certificate is no longer trusted. Recently a new state has been added to the CA service, the About to expire state. This state indicates, as the name suggests, that the certificate will expire shortly. The current threshold is set to 30 days and cannot be configured. This state doesn't affect the validity of the certificate, but it is used to notify the PKI admins that the certificate is about to expire and they should take action. The CA service uses a relational database to store the issued certificates and basic information regarding the provisioned CAs. To configure the database connection, set the following environment variables: Environment Variable Description POSTGRES_HOSTNAME Hostname or address to connect to a running postgres database POSTGRES_PORT Port for the postgres instance POSTGRES_DATABASE Database to use POSTGRES_USERNAME Username credentials POSTGRES_PASSWORD Password credentials This service has been redesigned to support multiple crypto engines backends. Originally the only supported engine was the one provided by Hashicorp Vault, but the new redesign implementation allows for a more flexible golang like approach, that is by using the crypto.Signer interface. Any new crypto engine can be added by implementing this interface. To provision the CA service with a crypto engine set the following environment variable: Environment Variable Description ENGINE pkcs11 | gopem | vault The current supported crypto engines are: pkcs11 : To Use the HSM crypto engine, define the following environment variables before launching the CA service: Environment Variable Description PKCS11_DRIVER Path to the PKCS11 driver file PKCS11_LABEL Label used by the token to be used PKCS11_PIN PIN code to login and operate the token gopem - Files Environment Variable Description GOPEM_DATA Directory where the generated private keys belonging to each CA are stored Although this new design is easier to maintain and operate, we are also keeping the previous implementation of the Hashicorp Vault that does not follow the new interface. The reason being that in order to provide a Vault implementation that follows the new interface, the Enterprise Vault license is required. This is a limitation that we are working on to overcome with the new crypto engine design. The new standard deployment deprecates the use of Vault as the main backend and instead a Software HSM known as SoftHSM v2 . vault - Hashicorp Vault Environment Variable Description VAULT_ADDRESS Protocol, hostname and port to a vault instance: https://vault:8200 VAULT_ROLE_ID Role ID used by the CA service to login to vault VAULT_SECRET_ID Secret ID used by the CA service to login to vault VAULT_CA Path to the CA certificate file for https connections VAULT_UNSEAL_KEY_FILE Path to the unseal vault keys VAULT_PKI_CA_PATH Prefix to use while creating new PKI vault secrets","title":"CA"},{"location":"architecture/#dms-manager","text":"The DMS Manager is the service in charge of managing the Registration Authority of the PKI. Instead of having a centralized Registration Authority, Lamassu uses a decentralized approach to be easily integrated by Device Manufacturing Systems. This way, each DMS has the authority to request the issuance of a certificate for a device being manufactured. Instead of relying on just one registration authority, Lamassu delegates the authorization of the issuance to the Local Registration Authority or LRA . Each DMS is entitled to authorize the issuance of a certificate to a subset of CAs of the entire PKI defined by the administrator. Each DMS has a list of authorized CAs that may be used during the enrollment process. Once an enrollment process is initiated, the PKI will check that the provided DMS certificate is authorized to issue certificates for the requested CA. The authorization list can be updated to add newly created CAs or remove CAs that are no longer needed. The DMS certificates that are used to authenticate the DMS are issued by an internal CA named LAMASSU-DMS-MANAGER . This CA is created by default when the PKI is deployed as stated earlier.","title":"DMS Manager"},{"location":"architecture/#device-manager","text":"At its core, the device manager is the main entry point for the enrollment process. It implements the EST protocol that must be used to obtain new certificates. On top of that, this service manages the registration of new devices and to keep a track of the device status. Similar to the CA service, the device manager also schedules a periodic task to check the status of the devices. This task is launched once a day to check the status of validity of all certificates associated by each device. Warning This feature does not perform well on deployments that have issued many certificates as it is performed on a sequential single threaded process. We are working on a solution to improve this. There are 5 different status a device can have: The Pending Provisioning state reflects that a device entity has been created but no certificate has been issued yet. The Fully Provisioned state indicates that a device has all the device slots with active certificates. The With warnings state indicates that a device has one or more slots with certificates that are either expired or have been revoked. The Requires Action state indicates that a device has one or more slots with certificates that are about to expire. The Decommissioned state indicates that a device has been decommissioned and no longer needs to be tracked by the PKI.","title":"Device manager"},{"location":"architecture/#cloud-proxy","text":"","title":"Cloud Proxy"},{"location":"architecture/#alerts","text":"","title":"Alerts"},{"location":"architecture/#ocsp","text":"","title":"OCSP"},{"location":"architecture/#cloud-providers-add-ons","text":"","title":"Cloud Providers Add-ons"},{"location":"manage/","text":"Managing Lamassu Certificate rotation By default, all self-signed certificates (both upstream and downstream) have a lifespan of 365 days. At that point it will be necessary to regenerate the expired certificates: Regenerate the certificates: cd tls-certificates ./gen-upstream-certs.sh ./gen-downstream-certs.sh cd .. Reboot all services: docker-compose down docker-compose up -d Backup strategy Restoring backups","title":"Managing Lamassu"},{"location":"manage/#managing-lamassu","text":"","title":"Managing Lamassu"},{"location":"manage/#certificate-rotation","text":"By default, all self-signed certificates (both upstream and downstream) have a lifespan of 365 days. At that point it will be necessary to regenerate the expired certificates: Regenerate the certificates: cd tls-certificates ./gen-upstream-certs.sh ./gen-downstream-certs.sh cd .. Reboot all services: docker-compose down docker-compose up -d","title":"Certificate rotation"},{"location":"manage/#backup-strategy","text":"","title":"Backup strategy"},{"location":"manage/#restoring-backups","text":"","title":"Restoring backups"},{"location":"protocols/","text":"Protocols Lamassu supports a set of standards to perform some of its key functionalities such as enrolling devices as well as validating the status of a given certificate. This section aims to describe those protocols as well as explaining how them with practical examples. OCSP The Online Certificate Status Protocol or OCSP for short, is a protocol used to determine the current status of a digital certificate without requiring the use of Certificate Revocation Lists (CRLs). As defined by the standard, there are two possible methods that can be used to perform the http request: Method Path Headers Body payload Used when GET {url}/{url-encoding of base-64 encoding of the DER encoding of the OCSPRequest} Recommended when the encoded request is less than 255 bytes PUT {url} Content-Type: application/ocsp-request Binary value of the DER encoding of the OCSPRequest Can always be used GET Request OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request OCSP_REQUEST=$(openssl ocsp -CAfile $CA_CERTIFICATE -issuer $CA_CERTIFICATE -cert $DEVICE_CERTIFICATE -reqout - | base64 -w 0) Check the status of the certificate curl --location --request GET \"https://$OCSP_SERVER/api/ocsp/$OCSP_REQUEST\" > ocspresponse.der openssl ocsp -respin ocspresponse.der -VAfile root-ca.pem -resp_text package main import ( \"crypto/x509\" \"encoding/base64\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } encodedRequest := base64 . StdEncoding . EncodeToString ( ocspRequestBytes ) fmt . Println ( encodedRequest ) reqURL := ocspServer + \"/\" + encodedRequest resp , err := http . Get ( reqURL ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) } POST Request OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request openssl ocsp -issuer ca.crt -cert dev.crt -reqout - > ocsp-request-post.der Check the status of the certificate curl --location --request POST \"https://$DOMAIN/api/ocsp/\" --header 'Content-Type: application/ocsp-request' --data-binary '@ocsp-request-post.der' > ocsp-response-post.der -k openssl ocsp -respin ocsp-response-post.der -VAfile root-ca.pem -resp_text package main import ( \"bytes\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } resp , err := http . Post ( ocspServer , \"application/ocsp-request\" , bytes . NewReader ( ocspRequestBytes )) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) } EST The core mechanism to obtain valid certificates for your devices is using the enrollment process described by the EST protocol. EST or Enrollment over Secure Transport establishes a set of standardized endpoints. The following table sums up all endpoints defined by the EST protocol and wether or not are supported by the current implementation. Operation Operation Path Required by RFC7030 Supported Distribution of CA Certificates /api/devmanager/.well-known/cacerts Enrollment of Clients /api/devmanager/.well-known/simpleenroll Re-enrollment of Clients /api/devmanager/.well-known/simplereenroll Full CMC /api/devmanager/.well-known/fullcmc Server-Side Key Generation /api/devmanager/.well-known/serverkeygen CSR Attributes /api/devmanager/.well-known/csrattrs Distribution of CA Certificates GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates estclient cacerts -server $DOMAIN/api/devmanager -explicit root-ca.pem -out cacerts.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" clientcrt := \"dms.crt\" clientkey := \"dms.key\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( clientcrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( clientkey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cas , err := estClient . CACerts ( context . Background ()) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } } Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates curl https://$DOMAIN/api/devmanager/.well-known/est/cacerts -o cacerts.p7 --cacert root-ca.pem openssl base64 -d -in cacerts.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cacerts.pem Enrollment of Devices GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with an existing private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient enroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out cert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecsr := \"device.csr\" devicecrt := \"device.crt\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Enroll ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with an existing private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/simpleenroll --cert $DMS_CRT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cert.pem Re-enrollment of Devices GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Reenrolling estclient reenroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -key $DEVICE_KEY -certs $DEVICE_CRT -out newcert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( devicecrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( devicekey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Reenroll ( context . Background (), csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key exprot DEVICE_CSR=device.csr Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device enroll CSR sed '/CERTIFICATE/d' device.csr > device_enroll.csr Reenrolling curl https://$DOMAIN/api/devmanager/.well-known/est/simplereenroll --cert $DEVICE_CRT --key $DEVICE_KEY -s -o newcert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in newcert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out $DEVICE_CRT Server Key Generation of Devices GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with a server-generated private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient serverkeygen -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out device.crt -keyout device.key package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , key , err := estClient . ServerKeyGen ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) b = pem . Block { Type : \"PRIVATE KEY\" , Bytes : key } keyPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicekey , keyPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with a server-generated private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/serverkeygen --cert $DMS_CERT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" cat cert.p7 | sed -ne '/application\\/pkcs7-mime/,/-estServerKeyGenBoundary/p' | sed '/-/d' > crt.p7 openssl base64 -d -in crt.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device.pem","title":"Protocols"},{"location":"protocols/#protocols","text":"Lamassu supports a set of standards to perform some of its key functionalities such as enrolling devices as well as validating the status of a given certificate. This section aims to describe those protocols as well as explaining how them with practical examples.","title":"Protocols"},{"location":"protocols/#ocsp","text":"The Online Certificate Status Protocol or OCSP for short, is a protocol used to determine the current status of a digital certificate without requiring the use of Certificate Revocation Lists (CRLs). As defined by the standard, there are two possible methods that can be used to perform the http request: Method Path Headers Body payload Used when GET {url}/{url-encoding of base-64 encoding of the DER encoding of the OCSPRequest} Recommended when the encoded request is less than 255 bytes PUT {url} Content-Type: application/ocsp-request Binary value of the DER encoding of the OCSPRequest Can always be used","title":"OCSP"},{"location":"protocols/#get-request","text":"OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request OCSP_REQUEST=$(openssl ocsp -CAfile $CA_CERTIFICATE -issuer $CA_CERTIFICATE -cert $DEVICE_CERTIFICATE -reqout - | base64 -w 0) Check the status of the certificate curl --location --request GET \"https://$OCSP_SERVER/api/ocsp/$OCSP_REQUEST\" > ocspresponse.der openssl ocsp -respin ocspresponse.der -VAfile root-ca.pem -resp_text package main import ( \"crypto/x509\" \"encoding/base64\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } encodedRequest := base64 . StdEncoding . EncodeToString ( ocspRequestBytes ) fmt . Println ( encodedRequest ) reqURL := ocspServer + \"/\" + encodedRequest resp , err := http . Get ( reqURL ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) }","title":"GET Request"},{"location":"protocols/#post-request","text":"OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request openssl ocsp -issuer ca.crt -cert dev.crt -reqout - > ocsp-request-post.der Check the status of the certificate curl --location --request POST \"https://$DOMAIN/api/ocsp/\" --header 'Content-Type: application/ocsp-request' --data-binary '@ocsp-request-post.der' > ocsp-response-post.der -k openssl ocsp -respin ocsp-response-post.der -VAfile root-ca.pem -resp_text package main import ( \"bytes\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } resp , err := http . Post ( ocspServer , \"application/ocsp-request\" , bytes . NewReader ( ocspRequestBytes )) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) }","title":"POST Request"},{"location":"protocols/#est","text":"The core mechanism to obtain valid certificates for your devices is using the enrollment process described by the EST protocol. EST or Enrollment over Secure Transport establishes a set of standardized endpoints. The following table sums up all endpoints defined by the EST protocol and wether or not are supported by the current implementation. Operation Operation Path Required by RFC7030 Supported Distribution of CA Certificates /api/devmanager/.well-known/cacerts Enrollment of Clients /api/devmanager/.well-known/simpleenroll Re-enrollment of Clients /api/devmanager/.well-known/simplereenroll Full CMC /api/devmanager/.well-known/fullcmc Server-Side Key Generation /api/devmanager/.well-known/serverkeygen CSR Attributes /api/devmanager/.well-known/csrattrs","title":"EST"},{"location":"protocols/#distribution-of-ca-certificates","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates estclient cacerts -server $DOMAIN/api/devmanager -explicit root-ca.pem -out cacerts.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" clientcrt := \"dms.crt\" clientkey := \"dms.key\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( clientcrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( clientkey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cas , err := estClient . CACerts ( context . Background ()) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } } Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates curl https://$DOMAIN/api/devmanager/.well-known/est/cacerts -o cacerts.p7 --cacert root-ca.pem openssl base64 -d -in cacerts.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cacerts.pem","title":"Distribution of CA Certificates"},{"location":"protocols/#enrollment-of-devices","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with an existing private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient enroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out cert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecsr := \"device.csr\" devicecrt := \"device.crt\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Enroll ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with an existing private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/simpleenroll --cert $DMS_CRT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cert.pem","title":"Enrollment of Devices"},{"location":"protocols/#re-enrollment-of-devices","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Reenrolling estclient reenroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -key $DEVICE_KEY -certs $DEVICE_CRT -out newcert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( devicecrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( devicekey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Reenroll ( context . Background (), csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key exprot DEVICE_CSR=device.csr Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device enroll CSR sed '/CERTIFICATE/d' device.csr > device_enroll.csr Reenrolling curl https://$DOMAIN/api/devmanager/.well-known/est/simplereenroll --cert $DEVICE_CRT --key $DEVICE_KEY -s -o newcert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in newcert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out $DEVICE_CRT","title":"Re-enrollment of Devices"},{"location":"protocols/#server-key-generation-of-devices","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with a server-generated private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient serverkeygen -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out device.crt -keyout device.key package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , key , err := estClient . ServerKeyGen ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) b = pem . Block { Type : \"PRIVATE KEY\" , Bytes : key } keyPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicekey , keyPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with a server-generated private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/serverkeygen --cert $DMS_CERT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" cat cert.p7 | sed -ne '/application\\/pkcs7-mime/,/-estServerKeyGenBoundary/p' | sed '/-/d' > crt.p7 openssl base64 -d -in crt.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device.pem","title":"Server Key Generation of Devices"},{"location":"setup/","text":"Setup with Lamassu Compose Lamassu Compose is the official release containing the scripts and resources required to deploy all microservices such as the CA component, the VA component or the RA components to name a few. Extended Architecture Lamassu Compose offers a SECURE deployment of the set of microservices required to manage an industrial PKI. The architecture presented on the following image reflects the interconnection of the different services mainly using the HTTP Protocol. The use of this deployment offers the following non functional requirements by leveraging the use of an API Gateway: Centralized point of access : Each microservice listens on a different port which ends up being challenging for developers and users. With the use of the API Gateway, the user will always access the same host and port address. Port 80 for HTTP connections and port 443 for HTTPS connections. Authentication : In order to invoke any endpoint, the API Gateway enforces each request to present a JWT. Upon receiving an HTTP request, the gateway validates the presented token against the authentication server. Authorization : Another key aspect is enforcing an authorization schema. Lamassu has been configured in such way that only specific endpoints are accessible by non admin users. Tracing : Logging the life of an HTTP request can be helpful during the debugging process of such complex application. The tracing aspect eases this process by injecting a unique identifier to each request that is then printed out by each microservice logs. Mutual TLS authentication : As mentioned earlier the gateway acts as the traffic orchestrator knowing where each service is and redirecting the traffic accordingly. To prevent any unauthorized request as well as protecting the communications channel between the Gateway itself and the upstream service, the API Gateway initiates a mutual TLS connection to ensure such thing. Requirements jq . Get the latest version: https://stedolan.github.io/jq/download/ docker and docker-compose : Get the latest version: https://docs.docker.com/engine/install/ubuntu/ and https://docs.docker.com/compose/install/ Have a working DNS server able to resolve the domain used during the installation process or add the following content to the /etc/hosts file, replacing the dev.lamassu.io domain with your own: 127.0.0.1 dev.lamassu.io 127.0.0.1 vault.dev.lamassu.io 127.0.0.1 auth.dev.lamassu.io 127.0.0.1 tracing.dev.lamassu.io 127.0.0.1 consul.dev.lamassu.io Setup Automatic deployment Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the next secret environment variables by exporting the following variables. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by exporting the DOMAIN variable. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env Run the installer: bash install.sh OPTIONAL : Import your certificates: The install.sh script also generates self-signed for the downstream certificates. It is possible to provide other valid certificates by replacing the following files: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt <----- Provide your certificate \u2514\u2500\u2500 tls.key <----- Provide your private key Once you replace this certificates, restart the api-gateway to obtain the imported certificates: docker-compose rm -s -f api-gateway dms-default docker-compose up -d api-gateway dms-default Final notes: \ud83d\ude80 You are ready to go \ud83d\ude80 Note Keycloak is your auth provider. During the install.sh the service is provisioned with 2 users with different roles: Username: enroller Password: enroller Role: admin Username: operator Password: operator Role: operator You can change those credentials (or create new users) using keycloak's UI available at: https://auth.<DOMAIN> Manual deployment To launch Lamassu follow the next steps: Set up your environment: Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the DB credentials variables used by the .env file. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by the .env file. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env The Gateway and TLS Certificates Lamassu uses a Gateway to expose all the deployed services. Moreover, the gateway is in charge of performing the following tasks: - Routing traffic to services - Enforcing authentication policies - Enforcing authorization policies - Logging & tracing - Healthchecking - Securely expose services using TLS The different APIs exposed through the gateway have been configured to ONLY accept request originates inside the platform via a mTLS authentication: Generate the upstream certificates. cd tls-certificates ./gen-upstream-certs.sh There are 2 options for the downstream certificate: Import an existing certificate : If you have valid certificates for your domain, you can use them by placing them under the downstream folder. The end result should be: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt \u2514\u2500\u2500 tls.key Generate a Self Signed certificate : If you need to create a new self-signed certificate, run the following command: ./gen-downstream-certs.sh Authentication service configuration: Run Keycloak: docker-compose up -d auth Keycloak image is configured with a Realm, a client and two different roles: admin and operator . Create a user with admin role to perform Enroller administrator tasks. (The command below creates a user named enroller with enroller as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u enroller -p enroller --roles admin Create a user with operator role to perform Device Manufacturing System tasks. This Device Manufacturing System must associate its CSR with this user matching the CN attribute and the username.(The command below creates a user named operator with operator as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u operator -p operator --roles operator Reload keyclok server docker-compose exec auth /opt/jboss/keycloak/bin/jboss-cli.sh --connect command=:reload If Keycloak display the following output, keycloak has successfully reloaded. Otherwise, run the command again until you see the expected output: { \"outcome\" => \"success\", \"result\" => undefined } Provision and configure Vault and Lamassu CA: Run Vault: docker-compose up -d vault consul-server api-gateway Initialize vault: This process generates vault's unseal keys as well as the root token: docker-compose exec vault vault operator init -key-shares=5 -key-threshold=3 -tls-skip-verify -format=json > vault-credentials.json Verify the vault-credentials.json file has the expected content. It should be similar to this: { \"unseal_keys_b64\": [ \"Hfx46iMq/PXoBPhDZ0EAMM9MDWS8GTCANFbAkzVEzFOD\", \"lfo48PHGFGHmpaFn6Z6rWTXTXVS53m9duxsvwVjRDc2L\", \"dcVw6N81i+/pY34WTHQYkV848to7jNeVkgdJOtgxnRkS\", \"Aut6oL7+GomXCrrTH0FCKhJwAs2PrWFYSnWpgjLfwsH0\", \"pprFM0HJEUR4m3kaIT5sga87aJ4AjXi32KVn6dgfivii\" ], \"unseal_keys_hex\": [ \"1dfc78ea232afcf5e804f84367410030cf4c0d64bc1930803456c0933544cc5383\", \"95fa38f0f1c61461e6a5a167e99eab5935d35d54b9de6f5dbb1b2fc158d10dcd8b\", \"75c570e8df358befe9637e164c7418915f38f2da3b8cd7959207493ad8319d1912\", \"02eb7aa0befe1a89970abad31f41422a127002cd8fad61584a75a98232dfc2c1f4\", \"a69ac53341c91144789b791a213e6c81af3b689e008d78b7d8a567e9d81f8af8a2\" ], \"unseal_shares\": 5, \"unseal_threshold\": 3, \"recovery_keys_b64\": [], \"recovery_keys_hex\": [], \"recovery_keys_shares\": 5, \"recovery_keys_threshold\": 3, \"root_token\": \"s.80Mpm0OmxlXzoSxZB2MMPcNu\" } Export the following variables: export VAULT_TOKEN=$(cat vault-credentials.json | jq .root_token -r) export VAULT_ADDR=https://vault.$DOMAIN Unseal Vault using the keys obtained with the previous command: curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[0])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[1])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[2])\\\" }\" Vault must be provisioned with some resources (authentication methods, policies and secret engines). That can be achieved by running the ca-provision.sh script. Vault will be provisioned with 4 Root CAs, 1 Special CA (Lamassu-DMS-Enroller) AppRole authentication method and one role and policy for each service or container that needs to exchange data with it. cd config/vault/provision/ ./provisioner.sh cd ../../../ Get RoleID and SecretID for each service and set those values in the empty fields of the .docker-compose.yml file. export CA_VAULT_ROLEID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/role-id | jq -r .data.role_id ) export CA_VAULT_SECRETID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" --request POST ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/secret-id | jq -r .data.secret_id) # Set RoleID and SecretID in docker-compose.yml file sed -i 's/<LAMASSU_CA_VAULT_ROLE_ID>/'$CA_VAULT_ROLEID'/g' docker-compose.yml sed -i 's/<LAMASSU_CA_VAULT_SECRET_ID>/'$CA_VAULT_SECRETID'/g' docker-compose.yml Configure the Device Manager: The Device Manage has a configurable variable that determines when a device can renew (also known as reenroll) its certificate. By default the reenrollment process can only be done 30 days prior to the cert's expiration time. This value can be changed by modifying the DEVICE_MANAGER_MINIMUM_REENROLL_DAYS variable located in the .env file. Start the remaining services: docker-compose up -d Configure the Default DMS First, authenticate against Keycloak: export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' |jq -r .access_token) Then, register a new DMS named Lamassu-Default-DMS: Note while registering new DMS instances with non admin users, it is necessary to register the DMS using the user's username as the common name, otherwise, the user won't see its DMSs export ENROLL_ADDR=$DOMAIN/api/dmsenroller export DMS_REGISTER_RESPONSE=$(curl -k --location --request POST \"https://$ENROLL_ADDR/v1/Lamassu-Default-DMS/form\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"url\\\":\\\"https://${DOMAIN}:5000\\\", \\\" subject\\\":{ \\\"common_name\\\": \\\"Lamassu-Default-DMS\\\",\\\"country\\\": \\\"\\\",\\\"locality\\\": \\\"\\\",\\\"organization\\\": \\\"\\\",\\\"organization_unit\\\": \\\"\\\",\\\"state\\\": \\\"\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 3072,\\\"type\\\": \\\"rsa\\\"}}\") echo $DMS_REGISTER_RESPONSE | jq -r .priv_key | sed 's/\\\\n/\\n/g' | sed -Ez '$ s/\\n+$//' | base64 -d > lamassu-default-dms/config/dms.key export DMS_ID=$(echo $DMS_REGISTER_RESPONSE | jq -r .dms.id) 3. Enroll the new DMS curl -k --location --request PUT \"https://$ENROLL_ADDR/v1/$DMS_ID\" --header \"Authorization: Bearer $TOKEN\" --header 'Content-Type: application/json' --data-raw '{\"status\": \"APPROVED\"}' 4. Get issued DMS Cert curl -k --location --request GET \"https://$ENROLL_ADDR/v1/$DMS _ID/crt\" --header \"Authorization: Bearer $TOKEN\" | base64 -d > lamassu-default-dms/config/dms.crt And finally, start the DMS \"server\": docker-compose rm -s -f dms-default docker-compose up -d dms-default Deploy AWS IoT Core connectors Requirements In order tu run the connector, you must have: NodeJS: https://nodejs.org/en/ AWS CDK v1: https://docs.aws.amazon.com/cdk/v1/guide/cli.html Deployment Download the AWS Connector source code: git clone https://github.com/lamassuiot/lamassu-aws-connector.git Configure the AWS Credentials. Those values will be used by the Lamassu AWS Connector as well as the CDK. export AWS_ACCESS_KEY_ID=<AWS_ACCESS_KEY_ID> export AWS_SECRET_ACCESS_KEY=<AWS_SECRET_ACCESS_KEY> export AWS_ACCOUNT_ID=<AWS_ACCOUNT_ID> export AWS_DEFAULT_REGION=<AWS_DEFAULT_REGION> Provide a friendly name for the Lamassu AWS Connector. This name will be displayed in the UI export CONNECTOR_NAME=Lamassu IoT AWS Account Substitute the aws-connector .env file: envsubst < .env | tee .env Generate the TLS certificates used by the connector. You must have access to the main CA certificate and private key that where generated during Lamassu installation. export INTERNAL_CA_CERT=<CHANGE_TO_LAMASSU_INSTALLATION_PATH>/tls-certificates/upstream/ca.crt export INTERNAL_CA_KEY=<CHANGE_TO_LAMASSU_INSTALLATION_PATH>/tls-certificates/upstream/ca.key After defining those variables, run the following OpenSSL commands: openssl genrsa -out aws-connector.key 4096 openssl req -new -key aws-connector.key -out aws-connector.csr -subj \"/CN=aws-connector\" openssl x509 -req -extfile <(printf \"subjectAltName=DNS:aws-connector\") -in aws-connector.csr -days 365 -CA $INTERNAL_CA_CERT -CAkey $INTERNAL_CA_KEY -CAcreateserial -out aws.crt Deploy the required AWS services by using the CDK: cd aws-connector npm i cdk deploy Start the connector: docker-compose up -d","title":"Setup with Lamassu Compose"},{"location":"setup/#setup-with-lamassu-compose","text":"Lamassu Compose is the official release containing the scripts and resources required to deploy all microservices such as the CA component, the VA component or the RA components to name a few.","title":"Setup with Lamassu Compose"},{"location":"setup/#extended-architecture","text":"Lamassu Compose offers a SECURE deployment of the set of microservices required to manage an industrial PKI. The architecture presented on the following image reflects the interconnection of the different services mainly using the HTTP Protocol. The use of this deployment offers the following non functional requirements by leveraging the use of an API Gateway: Centralized point of access : Each microservice listens on a different port which ends up being challenging for developers and users. With the use of the API Gateway, the user will always access the same host and port address. Port 80 for HTTP connections and port 443 for HTTPS connections. Authentication : In order to invoke any endpoint, the API Gateway enforces each request to present a JWT. Upon receiving an HTTP request, the gateway validates the presented token against the authentication server. Authorization : Another key aspect is enforcing an authorization schema. Lamassu has been configured in such way that only specific endpoints are accessible by non admin users. Tracing : Logging the life of an HTTP request can be helpful during the debugging process of such complex application. The tracing aspect eases this process by injecting a unique identifier to each request that is then printed out by each microservice logs. Mutual TLS authentication : As mentioned earlier the gateway acts as the traffic orchestrator knowing where each service is and redirecting the traffic accordingly. To prevent any unauthorized request as well as protecting the communications channel between the Gateway itself and the upstream service, the API Gateway initiates a mutual TLS connection to ensure such thing.","title":"Extended Architecture"},{"location":"setup/#requirements","text":"jq . Get the latest version: https://stedolan.github.io/jq/download/ docker and docker-compose : Get the latest version: https://docs.docker.com/engine/install/ubuntu/ and https://docs.docker.com/compose/install/ Have a working DNS server able to resolve the domain used during the installation process or add the following content to the /etc/hosts file, replacing the dev.lamassu.io domain with your own: 127.0.0.1 dev.lamassu.io 127.0.0.1 vault.dev.lamassu.io 127.0.0.1 auth.dev.lamassu.io 127.0.0.1 tracing.dev.lamassu.io 127.0.0.1 consul.dev.lamassu.io","title":"Requirements"},{"location":"setup/#setup","text":"","title":"Setup"},{"location":"setup/#automatic-deployment","text":"Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the next secret environment variables by exporting the following variables. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by exporting the DOMAIN variable. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env Run the installer: bash install.sh OPTIONAL : Import your certificates: The install.sh script also generates self-signed for the downstream certificates. It is possible to provide other valid certificates by replacing the following files: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt <----- Provide your certificate \u2514\u2500\u2500 tls.key <----- Provide your private key Once you replace this certificates, restart the api-gateway to obtain the imported certificates: docker-compose rm -s -f api-gateway dms-default docker-compose up -d api-gateway dms-default Final notes: \ud83d\ude80 You are ready to go \ud83d\ude80 Note Keycloak is your auth provider. During the install.sh the service is provisioned with 2 users with different roles: Username: enroller Password: enroller Role: admin Username: operator Password: operator Role: operator You can change those credentials (or create new users) using keycloak's UI available at: https://auth.<DOMAIN>","title":"Automatic deployment"},{"location":"setup/#manual-deployment","text":"To launch Lamassu follow the next steps: Set up your environment: Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the DB credentials variables used by the .env file. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by the .env file. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env The Gateway and TLS Certificates Lamassu uses a Gateway to expose all the deployed services. Moreover, the gateway is in charge of performing the following tasks: - Routing traffic to services - Enforcing authentication policies - Enforcing authorization policies - Logging & tracing - Healthchecking - Securely expose services using TLS The different APIs exposed through the gateway have been configured to ONLY accept request originates inside the platform via a mTLS authentication: Generate the upstream certificates. cd tls-certificates ./gen-upstream-certs.sh There are 2 options for the downstream certificate: Import an existing certificate : If you have valid certificates for your domain, you can use them by placing them under the downstream folder. The end result should be: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt \u2514\u2500\u2500 tls.key Generate a Self Signed certificate : If you need to create a new self-signed certificate, run the following command: ./gen-downstream-certs.sh Authentication service configuration: Run Keycloak: docker-compose up -d auth Keycloak image is configured with a Realm, a client and two different roles: admin and operator . Create a user with admin role to perform Enroller administrator tasks. (The command below creates a user named enroller with enroller as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u enroller -p enroller --roles admin Create a user with operator role to perform Device Manufacturing System tasks. This Device Manufacturing System must associate its CSR with this user matching the CN attribute and the username.(The command below creates a user named operator with operator as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u operator -p operator --roles operator Reload keyclok server docker-compose exec auth /opt/jboss/keycloak/bin/jboss-cli.sh --connect command=:reload If Keycloak display the following output, keycloak has successfully reloaded. Otherwise, run the command again until you see the expected output: { \"outcome\" => \"success\", \"result\" => undefined } Provision and configure Vault and Lamassu CA: Run Vault: docker-compose up -d vault consul-server api-gateway Initialize vault: This process generates vault's unseal keys as well as the root token: docker-compose exec vault vault operator init -key-shares=5 -key-threshold=3 -tls-skip-verify -format=json > vault-credentials.json Verify the vault-credentials.json file has the expected content. It should be similar to this: { \"unseal_keys_b64\": [ \"Hfx46iMq/PXoBPhDZ0EAMM9MDWS8GTCANFbAkzVEzFOD\", \"lfo48PHGFGHmpaFn6Z6rWTXTXVS53m9duxsvwVjRDc2L\", \"dcVw6N81i+/pY34WTHQYkV848to7jNeVkgdJOtgxnRkS\", \"Aut6oL7+GomXCrrTH0FCKhJwAs2PrWFYSnWpgjLfwsH0\", \"pprFM0HJEUR4m3kaIT5sga87aJ4AjXi32KVn6dgfivii\" ], \"unseal_keys_hex\": [ \"1dfc78ea232afcf5e804f84367410030cf4c0d64bc1930803456c0933544cc5383\", \"95fa38f0f1c61461e6a5a167e99eab5935d35d54b9de6f5dbb1b2fc158d10dcd8b\", \"75c570e8df358befe9637e164c7418915f38f2da3b8cd7959207493ad8319d1912\", \"02eb7aa0befe1a89970abad31f41422a127002cd8fad61584a75a98232dfc2c1f4\", \"a69ac53341c91144789b791a213e6c81af3b689e008d78b7d8a567e9d81f8af8a2\" ], \"unseal_shares\": 5, \"unseal_threshold\": 3, \"recovery_keys_b64\": [], \"recovery_keys_hex\": [], \"recovery_keys_shares\": 5, \"recovery_keys_threshold\": 3, \"root_token\": \"s.80Mpm0OmxlXzoSxZB2MMPcNu\" } Export the following variables: export VAULT_TOKEN=$(cat vault-credentials.json | jq .root_token -r) export VAULT_ADDR=https://vault.$DOMAIN Unseal Vault using the keys obtained with the previous command: curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[0])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[1])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[2])\\\" }\" Vault must be provisioned with some resources (authentication methods, policies and secret engines). That can be achieved by running the ca-provision.sh script. Vault will be provisioned with 4 Root CAs, 1 Special CA (Lamassu-DMS-Enroller) AppRole authentication method and one role and policy for each service or container that needs to exchange data with it. cd config/vault/provision/ ./provisioner.sh cd ../../../ Get RoleID and SecretID for each service and set those values in the empty fields of the .docker-compose.yml file. export CA_VAULT_ROLEID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/role-id | jq -r .data.role_id ) export CA_VAULT_SECRETID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" --request POST ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/secret-id | jq -r .data.secret_id) # Set RoleID and SecretID in docker-compose.yml file sed -i 's/<LAMASSU_CA_VAULT_ROLE_ID>/'$CA_VAULT_ROLEID'/g' docker-compose.yml sed -i 's/<LAMASSU_CA_VAULT_SECRET_ID>/'$CA_VAULT_SECRETID'/g' docker-compose.yml Configure the Device Manager: The Device Manage has a configurable variable that determines when a device can renew (also known as reenroll) its certificate. By default the reenrollment process can only be done 30 days prior to the cert's expiration time. This value can be changed by modifying the DEVICE_MANAGER_MINIMUM_REENROLL_DAYS variable located in the .env file. Start the remaining services: docker-compose up -d Configure the Default DMS First, authenticate against Keycloak: export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' |jq -r .access_token) Then, register a new DMS named Lamassu-Default-DMS: Note while registering new DMS instances with non admin users, it is necessary to register the DMS using the user's username as the common name, otherwise, the user won't see its DMSs export ENROLL_ADDR=$DOMAIN/api/dmsenroller export DMS_REGISTER_RESPONSE=$(curl -k --location --request POST \"https://$ENROLL_ADDR/v1/Lamassu-Default-DMS/form\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"url\\\":\\\"https://${DOMAIN}:5000\\\", \\\" subject\\\":{ \\\"common_name\\\": \\\"Lamassu-Default-DMS\\\",\\\"country\\\": \\\"\\\",\\\"locality\\\": \\\"\\\",\\\"organization\\\": \\\"\\\",\\\"organization_unit\\\": \\\"\\\",\\\"state\\\": \\\"\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 3072,\\\"type\\\": \\\"rsa\\\"}}\") echo $DMS_REGISTER_RESPONSE | jq -r .priv_key | sed 's/\\\\n/\\n/g' | sed -Ez '$ s/\\n+$//' | base64 -d > lamassu-default-dms/config/dms.key export DMS_ID=$(echo $DMS_REGISTER_RESPONSE | jq -r .dms.id) 3. Enroll the new DMS curl -k --location --request PUT \"https://$ENROLL_ADDR/v1/$DMS_ID\" --header \"Authorization: Bearer $TOKEN\" --header 'Content-Type: application/json' --data-raw '{\"status\": \"APPROVED\"}' 4. Get issued DMS Cert curl -k --location --request GET \"https://$ENROLL_ADDR/v1/$DMS _ID/crt\" --header \"Authorization: Bearer $TOKEN\" | base64 -d > lamassu-default-dms/config/dms.crt And finally, start the DMS \"server\": docker-compose rm -s -f dms-default docker-compose up -d dms-default","title":"Manual deployment"},{"location":"setup/#deploy-aws-iot-core-connectors","text":"","title":"Deploy AWS IoT Core connectors"},{"location":"setup/#requirements_1","text":"In order tu run the connector, you must have: NodeJS: https://nodejs.org/en/ AWS CDK v1: https://docs.aws.amazon.com/cdk/v1/guide/cli.html","title":"Requirements"},{"location":"setup/#deployment","text":"Download the AWS Connector source code: git clone https://github.com/lamassuiot/lamassu-aws-connector.git Configure the AWS Credentials. Those values will be used by the Lamassu AWS Connector as well as the CDK. export AWS_ACCESS_KEY_ID=<AWS_ACCESS_KEY_ID> export AWS_SECRET_ACCESS_KEY=<AWS_SECRET_ACCESS_KEY> export AWS_ACCOUNT_ID=<AWS_ACCOUNT_ID> export AWS_DEFAULT_REGION=<AWS_DEFAULT_REGION> Provide a friendly name for the Lamassu AWS Connector. This name will be displayed in the UI export CONNECTOR_NAME=Lamassu IoT AWS Account Substitute the aws-connector .env file: envsubst < .env | tee .env Generate the TLS certificates used by the connector. You must have access to the main CA certificate and private key that where generated during Lamassu installation. export INTERNAL_CA_CERT=<CHANGE_TO_LAMASSU_INSTALLATION_PATH>/tls-certificates/upstream/ca.crt export INTERNAL_CA_KEY=<CHANGE_TO_LAMASSU_INSTALLATION_PATH>/tls-certificates/upstream/ca.key After defining those variables, run the following OpenSSL commands: openssl genrsa -out aws-connector.key 4096 openssl req -new -key aws-connector.key -out aws-connector.csr -subj \"/CN=aws-connector\" openssl x509 -req -extfile <(printf \"subjectAltName=DNS:aws-connector\") -in aws-connector.csr -days 365 -CA $INTERNAL_CA_CERT -CAkey $INTERNAL_CA_KEY -CAcreateserial -out aws.crt Deploy the required AWS services by using the CDK: cd aws-connector npm i cdk deploy Start the connector: docker-compose up -d","title":"Deployment"},{"location":"usage/","text":"Getting Started with Lamassu Before jumping any further, please check out the installation process to deploy all Lamassu services. This section will guide you through the basic functionalities provided by our PKI to start provisioning your devices. Overview Create a new Certification Authority The first step to provision your devices with digital certificates is to create the Certification Authority. The role of a CA is to issue and manage all the certificates. To create a new CA, fill the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs. Register a new Device Manufacturing System Lamassu is a PKI designed for the industrial and IoT sector. To better integrate this PKI in real life manufacturing system, Lamassu delegates the issuance of device certificate to the factory itself. First lets dive into the Device Manufacturing System (DMS for short) registration step by step. After that, a couple of examples will demonstrate how to start enrolling your devices using the Lamassu's Virtual DMS software as well as using the UI. Device manufacturing process tend to be highly automated. Provisioning the devices with digital identities should not slow down the fabrication process. Lamassu addresses this challenge introducing the DMS concept as core. One of the factories operators stars the process by generating a DMS registration request contained in a Certificate Signing Request also referred as CSR. This CSR is then sent to the DMS Enroller service to be approved by one of the PKI Administrators: The Administrator then decides if the request is approved or denied. If it decision is to approve the DMS registration request, the Administrator must specify which CAs will that particular DSM be entitled to issue certificates with: Once, and only if, the DMS registration request is approved, then the Operator must retrieve the signed CSR and pass it to the DMS software that will be in charge off requesting the issuance of new digital certificates for the manufactured devices: Finally, the DMS is able to request new x509 certificates for its manufactured devices. The DMS may be assisted by additional tools to obtain the manufactured device unique identifier. Note Envoy is used as an API gateway in this project. Currently Envoy is written to use Boring SSl as the TLS provider. It does not support secp224r1 signing method, which is used to create ECDSA224 keys. Therefore, enroll and reenroll methods will return a error when using this key. Let's register a new DMS instance: Operator - Authenticate the user: OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Operator - Request the registration for a new DMS instance: DMS_NAME=MyDMS DMS_SUBJECT_COUNTRY=ES DMS_SUBJECT_STATE=Gipuzkoa DMS_SUBJECT_LOCALITY=Donostia DMS_SUBJECT_ORGANIZATION=Lamassu DMS_SUBJECT_ORGANIZATION_UNIT=IoT DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsenroller/v1/$DMS_NAME/form\" \\ --header \"Authorization: Bearer $OPERATOR_TOKEN\" \\ --data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"org\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}}\") DMS_ID=$(echo $DMS_REG_RESPONSE | jq -r .dms.id) echo $DMS_REG_RESPONSE | jq -r .priv_key | base64 -d > dms.key Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Authorize the enrollment with all the provisioned CAs AUTHORIZED_CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .[].name | jq -s) curl -k --location --request PUT \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" \\ --header \"Authorization: Bearer $ENROLLER_TOKEN\" \\ --data-raw \"{\\\"authorized_cas\\\":$AUTHORIZED_CAS, \\\"status\\\":\\\"APPROVED\\\"}\" Operator - Get the DMS certificate: curl -k \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .crt | base64 -d > dms.crt Provision your devices with x509 Certificates The enrollment process is the way to go to obtain a certificate issued by one of the provisioned CAs. As described in the RFC document, Lamassu requires the authentication of the client requesting the enrollment using a certificate as well as the private key of an issued DMS to perform a mutual TLS connection. By using this type of TLS connection, the client is able to authenticate the server, and also, the server is able to authenticate the client. Although the /api/devmanager/.well-known/cacerts endpoint returns the list containing all the manged CAs by the PKI, each DMS is entitled to request the issuance of a certificate with an authorized CA. For instance, the PKI may have the following CAs: CA1 , CA2 , CA3 and CA4 . The /api/devmanager/.well-known/cacerts would return all four CAs. Then, a new DMS is registered. the PKI administrator approves the DMS registration by authorizing such DMS to issue certificates with CA1 and CA4 . This process is known as the DMS registration process . Once the DMS is completely registered, it can now start performing the EST enrollment process. Check out the previous section to understand what a DMS does. Let's first obtain the CA list for a particular DMS: First, authenticate and obtain a valid JWT OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Obtain the CA list: ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .authorized_cas) Select one of the entitled the CAs from the previous list: Note You can manually spefify the SELECTED_CA . Otherwise you can enroll the device with the first entitled CA using the following command. SELECTED_CA=$(echo $ENTITLED_CAS | jq .[0] -r) Generate the device CSR: DEVICE_ID=mytestdevice-123 openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" Enroll the device: DMS_CRT_PATH=path/to/dms_crt DMS_KEY_PATH=path/to/dms_key openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem curl https://$DOMAIN/api/devmanager/.well-known/est/$SELECTED_CA/simpleenroll --cert $DMS_CRT_PATH --key $DMS_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem --data-binary @device.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem openssl x509 -text -in device-cert.pem Using the UI The UI is an easy manageable tool designed to ease the burdens to non-technical users in using Lamassu PKI. This project was bootstrapped with Create React App . You can learn more in the Create React App documentation . Deployment This section has moved here: https://facebook.github.io/create-react-app/docs/deployment Create a new Certification Authority There are two methos of creating a new CA from the UI. The first one, filling the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs. The other one, will be importing it. A Certificate and a Private Key will be required. Registration of a DMS using the UI Using the UI, creating a new DMS is as simple as filling the following form. Once the DMS has been created successfully, a prompt showing the generated private key will be shown. It is encouraged to download it just after the creation as this prompt will be shown only once. The status of the new created DMS will be Pending Approval , to approve it, we must select at least one CA from the list of registered CAs. The selected CAs will be the authorised ones to sign certificates from now on. Registration of a device using the UI To create a device, we will need to fill the following form taking into account: A device identification must be provided. A DMS must be assigned. Each device can have certificates signed by different authorised CAs. The certificates of each device as well as the cloud-connectors will be showned. Using the APIs The main 3 Open API documentation can be found on the following urls: https://dev.lamassu.io/api/dmsenroller/v1/docs/ https://dev.lamassu.io/api/ca/v1/docs/ https://dev.lamassu.io/api/devmanager/v1/docs/ Note The following endpoints defined in the Lamassu Device Manager Api specification are not correctly defined due to the limitations imposed by the Open API 3.0 schema. The current specification defines an OIDC security schema (meaning that a valid JWT token must be provided while requesting the API) while the implemented security schema uses the mTLS approach. This issue will be resolved once the specification is migrated to Open API 3.1 compliant. The affected endpoints are: Lamassu provides easy to use GO clients for most of its APIs to help speeding up the development of third-party applications. Before using thees clients, it is important to identify the path taken by the request. Unless the application using the GO clients (or any other http client such as curl ) is deployed within the same docker network, the request will be handled by the API Gateway component . Otherwise check the internal usage section. Through the API Gateway Go Curl package main import ( \"net/url\" lamassuCAClient \"github.com/lamassuiot/lamassuiot/pkg/ca/client\" caDTO \"github.com/lamassuiot/lamassuiot/pkg/ca/common/dto\" \"github.com/lamassuiot/lamassuiot/pkg/utils/client\" ) function main (){ lamassuGatewayURL := \"dev.lamassu.io\" apiCAFile := \"path/to/apigw.crt\" caClient := lamassuCAClient . NewLamassuCAClient ( client . ClientConfiguration { URL : & url . URL { Scheme : \"https\" , Host : lamassuGatewayURL , Path : \"/api/ca/\" , }, AuthMethod : client . JWT , AuthMethodConfig : & client . JWTConfig { Username : \"enroller\" , Password : \"enroller\" , URL : & url . URL { Scheme : \"https\" , Host : \"auth.\" + lamassuGatewayURL , }, CACertificate : apiCAFile , }, CACertificate : apiCAFile , }) ca , err = caClient . CreateCA ( context . Background (), caDTO . Pki , caName , caDTO . PrivateKeyMetadata { KeyType : \"rsa\" , KeyBits : 2048 }, caDTO . Subject { CN : caName }, 365 * time . Hour , 30 * time . Hour ) } Define the DOMAIN, TOKEN and CA_NAME export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' | jq -r .access_token) export CA_ADDR=$DOMAIN/api/ca export CA_NAME=$(uuidgen) Creting CA export CREATE_CA_RESP=$(curl -k -s --location --request POST \"https://$CA_ADDR/v1/pki/$CA_NAME\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"ca_ttl\\\": 262800, \\\"enroller_ttl\\\": 175200, \\\"subject\\\":{ \\\"common_name\\\": \\\"$CA_NAME\\\",\\\"country\\\": \\\"ES\\\",\\\"locality\\\": \\\"Arrasate\\\",\\\"organization\\\": \\\"LKS Next, S. Coop\\\",\\\"state\\\": \\\"Gipuzkoa\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 4096,\\\"type\\\": \\\"RSA\\\"}}\") Running Unit tests #For pretty printing go install github.com/haveyoudebuggedit/gotestfmt/v2/cmd/gotestfmt@v2.3.1 go test -json -v ./pkg/ca/server/api/service/ | gotestfmt go test -json -v ./pkg/dms-enroller/server/api/service/ | gotestfmt go test -json -v ./pkg/device-manager/server/api/service/ | gotestfmt Filtering, Sorting and Pagination Lamassu API supports filtering, sorting and pagination. The filter can be form by the following parameters, being each of them optional: filter= attribute[operator]=value sort_by=attribute.[asc|desc] limit=value . Limits the maximun number of results of the query offset=value . In addition to limit , implements pagination. It defines the index of the first value from the resulting query. Example /v1/devices?filter=id[contains]=device_id&sort_by=id.asc&limit=100&offset=15 /v1?filter=id[contains]=dms_id&sort_by=id.desc Operators Depending of the data type of the parameters, the supported operators will vary. Strings : equals , notequals , contains , notcontains Dates: before , after , is , isnot Enums: is , isnot Numbers: lessthan , greaterthan , lessorequal , gretaerorequal , equal , notequal","title":"Getting Started with Lamassu"},{"location":"usage/#getting-started-with-lamassu","text":"Before jumping any further, please check out the installation process to deploy all Lamassu services. This section will guide you through the basic functionalities provided by our PKI to start provisioning your devices.","title":"Getting Started with Lamassu"},{"location":"usage/#overview","text":"","title":"Overview"},{"location":"usage/#create-a-new-certification-authority","text":"The first step to provision your devices with digital certificates is to create the Certification Authority. The role of a CA is to issue and manage all the certificates. To create a new CA, fill the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs.","title":"Create a new Certification Authority"},{"location":"usage/#register-a-new-device-manufacturing-system","text":"Lamassu is a PKI designed for the industrial and IoT sector. To better integrate this PKI in real life manufacturing system, Lamassu delegates the issuance of device certificate to the factory itself. First lets dive into the Device Manufacturing System (DMS for short) registration step by step. After that, a couple of examples will demonstrate how to start enrolling your devices using the Lamassu's Virtual DMS software as well as using the UI. Device manufacturing process tend to be highly automated. Provisioning the devices with digital identities should not slow down the fabrication process. Lamassu addresses this challenge introducing the DMS concept as core. One of the factories operators stars the process by generating a DMS registration request contained in a Certificate Signing Request also referred as CSR. This CSR is then sent to the DMS Enroller service to be approved by one of the PKI Administrators: The Administrator then decides if the request is approved or denied. If it decision is to approve the DMS registration request, the Administrator must specify which CAs will that particular DSM be entitled to issue certificates with: Once, and only if, the DMS registration request is approved, then the Operator must retrieve the signed CSR and pass it to the DMS software that will be in charge off requesting the issuance of new digital certificates for the manufactured devices: Finally, the DMS is able to request new x509 certificates for its manufactured devices. The DMS may be assisted by additional tools to obtain the manufactured device unique identifier. Note Envoy is used as an API gateway in this project. Currently Envoy is written to use Boring SSl as the TLS provider. It does not support secp224r1 signing method, which is used to create ECDSA224 keys. Therefore, enroll and reenroll methods will return a error when using this key. Let's register a new DMS instance: Operator - Authenticate the user: OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Operator - Request the registration for a new DMS instance: DMS_NAME=MyDMS DMS_SUBJECT_COUNTRY=ES DMS_SUBJECT_STATE=Gipuzkoa DMS_SUBJECT_LOCALITY=Donostia DMS_SUBJECT_ORGANIZATION=Lamassu DMS_SUBJECT_ORGANIZATION_UNIT=IoT DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsenroller/v1/$DMS_NAME/form\" \\ --header \"Authorization: Bearer $OPERATOR_TOKEN\" \\ --data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"org\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}}\") DMS_ID=$(echo $DMS_REG_RESPONSE | jq -r .dms.id) echo $DMS_REG_RESPONSE | jq -r .priv_key | base64 -d > dms.key Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Authorize the enrollment with all the provisioned CAs AUTHORIZED_CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .[].name | jq -s) curl -k --location --request PUT \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" \\ --header \"Authorization: Bearer $ENROLLER_TOKEN\" \\ --data-raw \"{\\\"authorized_cas\\\":$AUTHORIZED_CAS, \\\"status\\\":\\\"APPROVED\\\"}\" Operator - Get the DMS certificate: curl -k \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .crt | base64 -d > dms.crt","title":"Register a new Device Manufacturing System"},{"location":"usage/#provision-your-devices-with-x509-certificates","text":"The enrollment process is the way to go to obtain a certificate issued by one of the provisioned CAs. As described in the RFC document, Lamassu requires the authentication of the client requesting the enrollment using a certificate as well as the private key of an issued DMS to perform a mutual TLS connection. By using this type of TLS connection, the client is able to authenticate the server, and also, the server is able to authenticate the client. Although the /api/devmanager/.well-known/cacerts endpoint returns the list containing all the manged CAs by the PKI, each DMS is entitled to request the issuance of a certificate with an authorized CA. For instance, the PKI may have the following CAs: CA1 , CA2 , CA3 and CA4 . The /api/devmanager/.well-known/cacerts would return all four CAs. Then, a new DMS is registered. the PKI administrator approves the DMS registration by authorizing such DMS to issue certificates with CA1 and CA4 . This process is known as the DMS registration process . Once the DMS is completely registered, it can now start performing the EST enrollment process. Check out the previous section to understand what a DMS does. Let's first obtain the CA list for a particular DMS: First, authenticate and obtain a valid JWT OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Obtain the CA list: ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .authorized_cas) Select one of the entitled the CAs from the previous list: Note You can manually spefify the SELECTED_CA . Otherwise you can enroll the device with the first entitled CA using the following command. SELECTED_CA=$(echo $ENTITLED_CAS | jq .[0] -r) Generate the device CSR: DEVICE_ID=mytestdevice-123 openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" Enroll the device: DMS_CRT_PATH=path/to/dms_crt DMS_KEY_PATH=path/to/dms_key openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem curl https://$DOMAIN/api/devmanager/.well-known/est/$SELECTED_CA/simpleenroll --cert $DMS_CRT_PATH --key $DMS_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem --data-binary @device.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem openssl x509 -text -in device-cert.pem","title":"Provision your devices with x509 Certificates"},{"location":"usage/#using-the-ui","text":"The UI is an easy manageable tool designed to ease the burdens to non-technical users in using Lamassu PKI. This project was bootstrapped with Create React App . You can learn more in the Create React App documentation .","title":"Using the UI"},{"location":"usage/#deployment","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/deployment","title":"Deployment"},{"location":"usage/#create-a-new-certification-authority_1","text":"There are two methos of creating a new CA from the UI. The first one, filling the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs. The other one, will be importing it. A Certificate and a Private Key will be required.","title":"Create a new Certification Authority"},{"location":"usage/#registration-of-a-dms-using-the-ui","text":"Using the UI, creating a new DMS is as simple as filling the following form. Once the DMS has been created successfully, a prompt showing the generated private key will be shown. It is encouraged to download it just after the creation as this prompt will be shown only once. The status of the new created DMS will be Pending Approval , to approve it, we must select at least one CA from the list of registered CAs. The selected CAs will be the authorised ones to sign certificates from now on.","title":"Registration of a DMS using the UI"},{"location":"usage/#registration-of-a-device-using-the-ui","text":"To create a device, we will need to fill the following form taking into account: A device identification must be provided. A DMS must be assigned. Each device can have certificates signed by different authorised CAs. The certificates of each device as well as the cloud-connectors will be showned.","title":"Registration of a device using the UI"},{"location":"usage/#using-the-apis","text":"The main 3 Open API documentation can be found on the following urls: https://dev.lamassu.io/api/dmsenroller/v1/docs/ https://dev.lamassu.io/api/ca/v1/docs/ https://dev.lamassu.io/api/devmanager/v1/docs/ Note The following endpoints defined in the Lamassu Device Manager Api specification are not correctly defined due to the limitations imposed by the Open API 3.0 schema. The current specification defines an OIDC security schema (meaning that a valid JWT token must be provided while requesting the API) while the implemented security schema uses the mTLS approach. This issue will be resolved once the specification is migrated to Open API 3.1 compliant. The affected endpoints are: Lamassu provides easy to use GO clients for most of its APIs to help speeding up the development of third-party applications. Before using thees clients, it is important to identify the path taken by the request. Unless the application using the GO clients (or any other http client such as curl ) is deployed within the same docker network, the request will be handled by the API Gateway component . Otherwise check the internal usage section.","title":"Using the APIs"},{"location":"usage/#through-the-api-gateway","text":"Go Curl package main import ( \"net/url\" lamassuCAClient \"github.com/lamassuiot/lamassuiot/pkg/ca/client\" caDTO \"github.com/lamassuiot/lamassuiot/pkg/ca/common/dto\" \"github.com/lamassuiot/lamassuiot/pkg/utils/client\" ) function main (){ lamassuGatewayURL := \"dev.lamassu.io\" apiCAFile := \"path/to/apigw.crt\" caClient := lamassuCAClient . NewLamassuCAClient ( client . ClientConfiguration { URL : & url . URL { Scheme : \"https\" , Host : lamassuGatewayURL , Path : \"/api/ca/\" , }, AuthMethod : client . JWT , AuthMethodConfig : & client . JWTConfig { Username : \"enroller\" , Password : \"enroller\" , URL : & url . URL { Scheme : \"https\" , Host : \"auth.\" + lamassuGatewayURL , }, CACertificate : apiCAFile , }, CACertificate : apiCAFile , }) ca , err = caClient . CreateCA ( context . Background (), caDTO . Pki , caName , caDTO . PrivateKeyMetadata { KeyType : \"rsa\" , KeyBits : 2048 }, caDTO . Subject { CN : caName }, 365 * time . Hour , 30 * time . Hour ) } Define the DOMAIN, TOKEN and CA_NAME export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' | jq -r .access_token) export CA_ADDR=$DOMAIN/api/ca export CA_NAME=$(uuidgen) Creting CA export CREATE_CA_RESP=$(curl -k -s --location --request POST \"https://$CA_ADDR/v1/pki/$CA_NAME\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"ca_ttl\\\": 262800, \\\"enroller_ttl\\\": 175200, \\\"subject\\\":{ \\\"common_name\\\": \\\"$CA_NAME\\\",\\\"country\\\": \\\"ES\\\",\\\"locality\\\": \\\"Arrasate\\\",\\\"organization\\\": \\\"LKS Next, S. Coop\\\",\\\"state\\\": \\\"Gipuzkoa\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 4096,\\\"type\\\": \\\"RSA\\\"}}\")","title":"Through the API Gateway"},{"location":"usage/#running-unit-tests","text":"#For pretty printing go install github.com/haveyoudebuggedit/gotestfmt/v2/cmd/gotestfmt@v2.3.1 go test -json -v ./pkg/ca/server/api/service/ | gotestfmt go test -json -v ./pkg/dms-enroller/server/api/service/ | gotestfmt go test -json -v ./pkg/device-manager/server/api/service/ | gotestfmt","title":"Running Unit tests"},{"location":"usage/#filtering-sorting-and-pagination","text":"Lamassu API supports filtering, sorting and pagination. The filter can be form by the following parameters, being each of them optional: filter= attribute[operator]=value sort_by=attribute.[asc|desc] limit=value . Limits the maximun number of results of the query offset=value . In addition to limit , implements pagination. It defines the index of the first value from the resulting query. Example /v1/devices?filter=id[contains]=device_id&sort_by=id.asc&limit=100&offset=15 /v1?filter=id[contains]=dms_id&sort_by=id.desc","title":"Filtering, Sorting and Pagination"},{"location":"usage/#operators","text":"Depending of the data type of the parameters, the supported operators will vary. Strings : equals , notequals , contains , notcontains Dates: before , after , is , isnot Enums: is , isnot Numbers: lessthan , greaterthan , lessorequal , gretaerorequal , equal , notequal","title":"Operators"},{"location":"virtual-device/","text":"Lamassu Virtual Device It is recommended to follow this directory layout when deploying different Lamassu tools: $HOME/ \u251c\u2500\u2500 lamassu-compose \u251c\u2500\u2500 lamassu-virtual-device \u2514\u2500\u2500 lamassu-virtual-dms Make sure to define the following variable with the absolute path LAMASSU_COMPOSE_DIR=$HOME/lamassu-compose LAMASSU_VDMS_DIR=$HOME/lamassu-virtual-dms Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-virtual-device.git cd lamassu-virtual-device Basic Virtual Device configuration: 2.1 Specify the directory where enrolled device certificates (and keys) are stored: export VDEV_DEVICE_CERTIFICATES_DIR=$LAMASSU_VDMS_DIR/device-certificates 2.2 Specify the URL pointing to the EST server: export VDEV_EST_SERVER_URL=dev.lamassu.io/api/devmanager 2.3 Specify the public certificate used by the EST server: export VDEV_EST_SERVER_CERT=$LAMASSU_COMPOSE_DIR/tls-certificates/downstream/tls.crt Optional - Configure the device to connect to AWS IoT core: 3.1 Define the AWS IoT core endpoint to be used. Replace the xxxxxx with the appropriated value as well as the AWS Region to be used: VDEV_AWS_IOT_CORE_ENDPOINT=xxxxxx-ats.iot.eu-west-1.amazonaws.com Run the Virtual Device: ./run.sh","title":"Lamassu Virtual Device"},{"location":"virtual-device/#lamassu-virtual-device","text":"It is recommended to follow this directory layout when deploying different Lamassu tools: $HOME/ \u251c\u2500\u2500 lamassu-compose \u251c\u2500\u2500 lamassu-virtual-device \u2514\u2500\u2500 lamassu-virtual-dms Make sure to define the following variable with the absolute path LAMASSU_COMPOSE_DIR=$HOME/lamassu-compose LAMASSU_VDMS_DIR=$HOME/lamassu-virtual-dms Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-virtual-device.git cd lamassu-virtual-device Basic Virtual Device configuration: 2.1 Specify the directory where enrolled device certificates (and keys) are stored: export VDEV_DEVICE_CERTIFICATES_DIR=$LAMASSU_VDMS_DIR/device-certificates 2.2 Specify the URL pointing to the EST server: export VDEV_EST_SERVER_URL=dev.lamassu.io/api/devmanager 2.3 Specify the public certificate used by the EST server: export VDEV_EST_SERVER_CERT=$LAMASSU_COMPOSE_DIR/tls-certificates/downstream/tls.crt Optional - Configure the device to connect to AWS IoT core: 3.1 Define the AWS IoT core endpoint to be used. Replace the xxxxxx with the appropriated value as well as the AWS Region to be used: VDEV_AWS_IOT_CORE_ENDPOINT=xxxxxx-ats.iot.eu-west-1.amazonaws.com Run the Virtual Device: ./run.sh","title":"Lamassu Virtual Device"},{"location":"virtual-dms/","text":"Lamassu Virtual DMS It is recommended to follow this directory layout when deploying different Lamassu tools: $HOME/ \u251c\u2500\u2500 lamassu-compose \u251c\u2500\u2500 lamassu-virtual-device \u2514\u2500\u2500 lamassu-virtual-dms Make sure to define the following variable with the absolute path LAMASSU_COMPOSE_DIR=$HOME/lamassu-compose Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-virtual-dms.git cd lamassu-virtual-dms Basic Virtual DMS configuration: 2.1 Locate the the public certificate used by the EST server: export VDMS_EST_SERVER_CERT=$LAMASSU_COMPOSE_DIR/tls-certificates/downstream/tls.crt 2.2 Configure the domain used by lamassu: export VDMS_DOMAIN=dev.lamassu.io 2.3 Provide the operator credentials to be used while creating a new DMS instance: export VDMS_USERNAME=enroller export VDMS_PASSWORD=enroller 2.4 Specify the default values while creating a new DMS instance: export VDMS_COUNTRY=ES export VDMS_STATE=gipuzkoa export VDMS_LOCALITY=donostia export VDMS_ORGANIZATION=lamassu export VDMS_ORGANIZATION_UNIT=iot Run the DMS application: run.sh","title":"Lamassu Virtual DMS"},{"location":"virtual-dms/#lamassu-virtual-dms","text":"It is recommended to follow this directory layout when deploying different Lamassu tools: $HOME/ \u251c\u2500\u2500 lamassu-compose \u251c\u2500\u2500 lamassu-virtual-device \u2514\u2500\u2500 lamassu-virtual-dms Make sure to define the following variable with the absolute path LAMASSU_COMPOSE_DIR=$HOME/lamassu-compose Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-virtual-dms.git cd lamassu-virtual-dms Basic Virtual DMS configuration: 2.1 Locate the the public certificate used by the EST server: export VDMS_EST_SERVER_CERT=$LAMASSU_COMPOSE_DIR/tls-certificates/downstream/tls.crt 2.2 Configure the domain used by lamassu: export VDMS_DOMAIN=dev.lamassu.io 2.3 Provide the operator credentials to be used while creating a new DMS instance: export VDMS_USERNAME=enroller export VDMS_PASSWORD=enroller 2.4 Specify the default values while creating a new DMS instance: export VDMS_COUNTRY=ES export VDMS_STATE=gipuzkoa export VDMS_LOCALITY=donostia export VDMS_ORGANIZATION=lamassu export VDMS_ORGANIZATION_UNIT=iot Run the DMS application: run.sh","title":"Lamassu Virtual DMS"}]}