{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Lamassu Iot Docs Lamassu is an IoT first PKI designed for industrial scenarios. Public key infrastructure are systems in charge of creating, storing and distributing digital certificates which are used to verify that a particular public key belongs to a certain entity. PKIs creates digital certificates which map to public keys to entities, securely stores these certificates in a central repository and revokes them if needed.","title":"Welcome to Lamassu Iot Docs"},{"location":"#welcome-to-lamassu-iot-docs","text":"Lamassu is an IoT first PKI designed for industrial scenarios. Public key infrastructure are systems in charge of creating, storing and distributing digital certificates which are used to verify that a particular public key belongs to a certain entity. PKIs creates digital certificates which map to public keys to entities, securely stores these certificates in a central repository and revokes them if needed.","title":"Welcome to Lamassu Iot Docs"},{"location":"aws/","text":"AWS Services used by Lamassu AWS Lambda AWS Lambda is a serverless, event-driven compute service that lets you run code for virtually any type of application or backend service without provisioning or managing servers. AWS IoT Core AWS IoT Core provides the cloud services that connect IoT devices to other devices and services in the AWS Cloud. AWS IoT provides device software that can help integrate IoT devices into solutions based on AWS IoT. If devices can connect to AWS IoT, AWS IoT can connect them to cloud services provided by AWS. AWS SQS To extend Lamassu to AWS cloud, whenever a opperation is triggered, an asynchronous messages are send via Amazon Simple Queue Service. Amazon SQS offers the possibility of establishing a message queue to store messages while they wait to be processed by different computers that are connected to the Internet. These messages can contain notifications for applications or lists of commands to be executed by applications, either in the cloud or on the Internet, allowing you to create automated workflows. The messages arrive at AWS cloud via lamassu-aws-connector . The connector will send a request to a the SDK to communicate with AWS Cloud. AWS Cloud Formation AWS Cloud Formation is a service that helps to model and set up AWS resources to spend less time managing resources. First, we need to create a template that describes the AWS resources that we want, then, CloudFormation takes care of provisioning and configuring those resources. There is no need to individually create and configure AWS resources and figure out what's dependent on what. References AWS Lambda web page: AWS Lambda AWS IoT Core web page: AWS IoT Core AWS Cloud Formation web page: AWS Cloud Formation","title":"AWS Services used by Lamassu"},{"location":"aws/#aws-services-used-by-lamassu","text":"","title":"AWS Services used by Lamassu"},{"location":"aws/#aws-lambda","text":"AWS Lambda is a serverless, event-driven compute service that lets you run code for virtually any type of application or backend service without provisioning or managing servers.","title":"AWS Lambda"},{"location":"aws/#aws-iot-core","text":"AWS IoT Core provides the cloud services that connect IoT devices to other devices and services in the AWS Cloud. AWS IoT provides device software that can help integrate IoT devices into solutions based on AWS IoT. If devices can connect to AWS IoT, AWS IoT can connect them to cloud services provided by AWS.","title":"AWS IoT Core"},{"location":"aws/#aws-sqs","text":"To extend Lamassu to AWS cloud, whenever a opperation is triggered, an asynchronous messages are send via Amazon Simple Queue Service. Amazon SQS offers the possibility of establishing a message queue to store messages while they wait to be processed by different computers that are connected to the Internet. These messages can contain notifications for applications or lists of commands to be executed by applications, either in the cloud or on the Internet, allowing you to create automated workflows. The messages arrive at AWS cloud via lamassu-aws-connector . The connector will send a request to a the SDK to communicate with AWS Cloud.","title":"AWS SQS"},{"location":"aws/#aws-cloud-formation","text":"AWS Cloud Formation is a service that helps to model and set up AWS resources to spend less time managing resources. First, we need to create a template that describes the AWS resources that we want, then, CloudFormation takes care of provisioning and configuring those resources. There is no need to individually create and configure AWS resources and figure out what's dependent on what.","title":"AWS Cloud Formation"},{"location":"aws/#references","text":"AWS Lambda web page: AWS Lambda AWS IoT Core web page: AWS IoT Core AWS Cloud Formation web page: AWS Cloud Formation","title":"References"},{"location":"azure/","text":"Azure Services used by Lamassu Azure functions Azure functions is an on-demand cloud service that provides all the continually updated infrastructure and resources needed to run your applications. Azure Queue Storage Azure Queue Storage Storage is a service for storing large amounts of messages, which can be accessed from anywhere in the world through authenticated calls using HTTP or HTTPS. Azure IoT Hub Azure IoT Hub provides a cloud-hosted solution back end to connect virtually any device. Extend your solution from the cloud to the edge with per-device authentication, built-in device management and scaled provisioning. Security-enhanced communication channel for sending and receiving data from IoT devices. Azure IoT Hub DPS Azure IoT Hub Device Provisioning Service (DPS) is an IoT Hub helper that provides Just-In-Time, zero-touch provisioning of the correct IoT Hub instance, enabling customers to securely provision millions of devices and scalable. References Azure functions web page: Azure functions Azure Queue Storage web page: Azure Queue Storage Azure IoT Hub web page: Azure IoT Hub Azure IoT Hub DPS web page: Azure DPS","title":"Azure Services used by Lamassu"},{"location":"azure/#azure-services-used-by-lamassu","text":"","title":"Azure Services used by Lamassu"},{"location":"azure/#azure-functions","text":"Azure functions is an on-demand cloud service that provides all the continually updated infrastructure and resources needed to run your applications.","title":"Azure functions"},{"location":"azure/#azure-queue-storage","text":"Azure Queue Storage Storage is a service for storing large amounts of messages, which can be accessed from anywhere in the world through authenticated calls using HTTP or HTTPS.","title":"Azure Queue Storage"},{"location":"azure/#azure-iot-hub","text":"Azure IoT Hub provides a cloud-hosted solution back end to connect virtually any device. Extend your solution from the cloud to the edge with per-device authentication, built-in device management and scaled provisioning. Security-enhanced communication channel for sending and receiving data from IoT devices.","title":"Azure IoT Hub"},{"location":"azure/#azure-iot-hub-dps","text":"Azure IoT Hub Device Provisioning Service (DPS) is an IoT Hub helper that provides Just-In-Time, zero-touch provisioning of the correct IoT Hub instance, enabling customers to securely provision millions of devices and scalable.","title":"Azure IoT Hub DPS"},{"location":"azure/#references","text":"Azure functions web page: Azure functions Azure Queue Storage web page: Azure Queue Storage Azure IoT Hub web page: Azure IoT Hub Azure IoT Hub DPS web page: Azure DPS","title":"References"},{"location":"extension/","text":"Extending Lamassu A PKI has three types of core compoents: CAs , RAs and VAs . Each PKI implementation must have an instance of those compoennts (at least) to be considered a mature digital identity provider. Certificate authority (CA) - Issues an entity's certificate and acts as a trusted component within a private PKI. Any certificate issued by the CA is trusted by all entities that trust the CA. The exact role of a CA will depend on its position within a CA hierarchy. Registration authority (RA) - Receives certificate signing requests and verifies the identity of an end entity. The RA will approve a request before the certificate can be issued by the CA. This is a very important stage of the process and it often involves a procedure to enrol end entities into the PKI. Validation authority (VA) - A VA allows an entity to check that a certificate has not been revoked. The VA role is often carried out by an online facility hosted by an organisation who operates the PKI. A validation authority will often use OCSP or CRL to advertise revoked certificates. Lamassu is no stranger to those concepts. In fact, Lamassu goes one step further by implementing LRAs or Local Registration Authorities also named DMSs. Local registration authority (LRA) - is an optional part of a public key infrastructure that maintains users' identities from which certification authorities can issue Digital Certificates. Extending the PKI is a core principal for Lamassu. There are multiple ways to customize Lamassu to the required needs by just modifying one of the core components or by developing and adding new ones. This section will describe some decissions that have been addopted to provide an extensible PKI that is able to integrate with some cloud providers such as AWS IoT Core or Azure IoT Hub . The AMQP Queue To get developers up to speed with new updates releated with Lamassu, a AMQP-based Queue service is deployed to provide real-time events. The core components ( Lamassu CA , Lamassu DeviceManager and Lamassu DMS Enroller ) publish new event messages if an update opperation is triggered. Update opperations are any tpye of function that end up modifying data in any way. Once a core component registers an update opperation, it then published a special crafted event message to the lamassu_events queue. Cloud Proxy A proxy server acts as a gateway between the service and the internet, and verifies and forwards incoming client requests to other servers for further communication. AWS Services used by Lamassu AWS Lambda AWS IoT Core AWS SQS AWS Cloud Formation Azure Services used by Lamassu Azure functions Azure storage queue Azure Iot Hub Azure Iot Hub DPS AWS Infraestructure Deployment To deploy the structure in AWS to proper function with Lamassu, AWS CDK is used. The AWS Cloud Development Kit (AWS CDK) is an open-source software development framework to define your cloud application resources using familiar programming languages. Directory layout /bin/lamassu-cdk.ts app entry point. It creates objects of classes defined in /lib. /lib it contains all the stacks for our project, were AWS resources are defined. cdk.json file tells the CDK Toolkit how to execute your app. Prerequisites Install nodejs 14.X, npm and jq. sudo apt install jq nodejs npm Install aws-cdk with npm: npm install -g aws-cdk@1.x Verify cdk is installed: cdk --version Install AWS cli and configure credentials: Install AWS CLI: https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html Configure AWS CLI: aws configure Provide your AWS access key ID, secret access key, and default region when prompted. You can also configure .aws/credentials file in your home directory instead. Usage NOTE : As some AWS features used in this project are still not implemented in AWS CDK, some of the steps are done via CLI. Go to cdk project home directory: cd lamassu-cdk Option 1 : Execute deploy script: bash deploy-lamassu.sh Option 2 : Execute it step by step: npm i npm i --prefix resources/sqsFilterLambda cdk deploy --outputs-file outputs.json aws lambda update-event-source-mapping --uuid $(cat outputs.json | jq -r .LamassuCdkStack.EventSourceMappingUUID) --filter-criteria file://filter-criteria.json Remove Lamassu resources: cdk destroy LamassuCdkStack Useful commands npm run build compile typescript to js npm run watch watch for changes and compile npm run test perform the jest unit tests cdk deploy deploy this stack to your default AWS account/region cdk diff compare deployed stack with current state cdk synth emits the synthesized CloudFormation template AWS Cloud-Trail When triggering an event of updating a certificate or a CA status, AWS CloudTrail will monitors and create records the activity. Event Type Source Description io.lamassu.iotcore.cert.status.update aws/cloud-trail io.lamassu.iotcore.ca.status.update aws/cloud-trail References AWS Docs on CDK: AWS CDK API reference for AWS CDK: API reference Cloud Events SDK for Go: Cloud Events SDK for GO Gokit, building microservices in go: (Gokit)","title":"Extending Lamassu"},{"location":"extension/#extending-lamassu","text":"A PKI has three types of core compoents: CAs , RAs and VAs . Each PKI implementation must have an instance of those compoennts (at least) to be considered a mature digital identity provider. Certificate authority (CA) - Issues an entity's certificate and acts as a trusted component within a private PKI. Any certificate issued by the CA is trusted by all entities that trust the CA. The exact role of a CA will depend on its position within a CA hierarchy. Registration authority (RA) - Receives certificate signing requests and verifies the identity of an end entity. The RA will approve a request before the certificate can be issued by the CA. This is a very important stage of the process and it often involves a procedure to enrol end entities into the PKI. Validation authority (VA) - A VA allows an entity to check that a certificate has not been revoked. The VA role is often carried out by an online facility hosted by an organisation who operates the PKI. A validation authority will often use OCSP or CRL to advertise revoked certificates. Lamassu is no stranger to those concepts. In fact, Lamassu goes one step further by implementing LRAs or Local Registration Authorities also named DMSs. Local registration authority (LRA) - is an optional part of a public key infrastructure that maintains users' identities from which certification authorities can issue Digital Certificates. Extending the PKI is a core principal for Lamassu. There are multiple ways to customize Lamassu to the required needs by just modifying one of the core components or by developing and adding new ones. This section will describe some decissions that have been addopted to provide an extensible PKI that is able to integrate with some cloud providers such as AWS IoT Core or Azure IoT Hub .","title":"Extending Lamassu"},{"location":"extension/#the-amqp-queue","text":"To get developers up to speed with new updates releated with Lamassu, a AMQP-based Queue service is deployed to provide real-time events. The core components ( Lamassu CA , Lamassu DeviceManager and Lamassu DMS Enroller ) publish new event messages if an update opperation is triggered. Update opperations are any tpye of function that end up modifying data in any way. Once a core component registers an update opperation, it then published a special crafted event message to the lamassu_events queue.","title":"The AMQP Queue"},{"location":"extension/#cloud-proxy","text":"A proxy server acts as a gateway between the service and the internet, and verifies and forwards incoming client requests to other servers for further communication.","title":"Cloud Proxy"},{"location":"extension/#aws-services-used-by-lamassu","text":"AWS Lambda AWS IoT Core AWS SQS AWS Cloud Formation","title":"AWS Services used by Lamassu"},{"location":"extension/#azure-services-used-by-lamassu","text":"Azure functions Azure storage queue Azure Iot Hub Azure Iot Hub DPS","title":"Azure Services used by Lamassu"},{"location":"extension/#aws-infraestructure-deployment","text":"To deploy the structure in AWS to proper function with Lamassu, AWS CDK is used. The AWS Cloud Development Kit (AWS CDK) is an open-source software development framework to define your cloud application resources using familiar programming languages.","title":"AWS Infraestructure Deployment"},{"location":"extension/#directory-layout","text":"/bin/lamassu-cdk.ts app entry point. It creates objects of classes defined in /lib. /lib it contains all the stacks for our project, were AWS resources are defined. cdk.json file tells the CDK Toolkit how to execute your app.","title":"Directory layout"},{"location":"extension/#prerequisites","text":"Install nodejs 14.X, npm and jq. sudo apt install jq nodejs npm Install aws-cdk with npm: npm install -g aws-cdk@1.x Verify cdk is installed: cdk --version Install AWS cli and configure credentials: Install AWS CLI: https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html Configure AWS CLI: aws configure Provide your AWS access key ID, secret access key, and default region when prompted. You can also configure .aws/credentials file in your home directory instead.","title":"Prerequisites"},{"location":"extension/#usage","text":"NOTE : As some AWS features used in this project are still not implemented in AWS CDK, some of the steps are done via CLI. Go to cdk project home directory: cd lamassu-cdk Option 1 : Execute deploy script: bash deploy-lamassu.sh Option 2 : Execute it step by step: npm i npm i --prefix resources/sqsFilterLambda cdk deploy --outputs-file outputs.json aws lambda update-event-source-mapping --uuid $(cat outputs.json | jq -r .LamassuCdkStack.EventSourceMappingUUID) --filter-criteria file://filter-criteria.json Remove Lamassu resources: cdk destroy LamassuCdkStack","title":"Usage"},{"location":"extension/#useful-commands","text":"npm run build compile typescript to js npm run watch watch for changes and compile npm run test perform the jest unit tests cdk deploy deploy this stack to your default AWS account/region cdk diff compare deployed stack with current state cdk synth emits the synthesized CloudFormation template","title":"Useful commands"},{"location":"extension/#aws-cloud-trail","text":"When triggering an event of updating a certificate or a CA status, AWS CloudTrail will monitors and create records the activity. Event Type Source Description io.lamassu.iotcore.cert.status.update aws/cloud-trail io.lamassu.iotcore.ca.status.update aws/cloud-trail","title":"AWS Cloud-Trail"},{"location":"extension/#references","text":"AWS Docs on CDK: AWS CDK API reference for AWS CDK: API reference Cloud Events SDK for Go: Cloud Events SDK for GO Gokit, building microservices in go: (Gokit)","title":"References"},{"location":"jitp/","text":"JITP (Just In Time Provisioning) Overview You can have your devices provisioned when they first attempt to connect to AWS IoT with just-in-time provisioning (JITP) . To provision the device, you must enable automatic registration and associate a provisioning template with the CA certificate used to sign the device certificate. When a device attempts to connect to AWS IoT by using a certificate signed by a registered CA certificate, AWS IoT loads the template from the CA certificate and uses it to register the thing. The JITP workflow first registers a certificate with a status value of PENDING_ACTIVATION. When the device provisioning flow is complete, the status of the certificate is changed to ACTIVE. Prerequisites To perform the tests, we need the following prerequisites: Install jq and mosquitto-clients apt install jq apt install mosquitto-clients Configure AWS CLI: AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY and REGION must be configured. Configure AWS CLI Flow Create a certificate authority and upload it to AWS. Attach a JITP template to the CA in AWS IoT Core. Enable auto-registration for that CA in AWS. Issue a certificate with that CA. Load the certificate in the device Connect to the IoT Core Enpoint using that certificate. The device will automatically register in AWS IoT Core with the corresponding certificate and the certificate would be attached to the policy stated in the JITP template. Now the device can interact with AWS. NOTE * : Device fails to connect to AWS on first attempt. Usage Steps to reproduce: Create a CA certificate in AWS. bash jitp_demo.sh Fill the following inputs and check that your CA has been correctly created in AWS IoT Core. Introduce CA name: Introduce demo device name: Introduce AWS Policy Name ( Must be unique in AWS ) : This script covers steps 1 to 4 in JITP flow. As a result of jitp_demo.sh script some test certificates have been created under test/certs folder. You can execute test/go/main.go or test/bash/mosquitto.sh to test connection to AWS IoT Core. If you are using mosquitto.sh : you need to change -i flag to be equal to the certificate common name and -t flag (topic) must be \" common_name / \" for the device to connect to AWS. For example, if CN=demodev: mosquitto_pub --cafile ../certs/awsRootCA.pem \\ --cert ../certs/deviceCertAndCACert.crt \\ --key ../certs/deviceCert.key \\ -h a3hczhtwc7h4es-ats.iot.eu-west-1.amazonaws.com \\ -p 8883 -q 1 \\ -t demodev -i demodev -m \"hello\" -d If you are using go main.go *: you need to change device Id and topic. Lines 103 and 118. opts . SetClientID ( \"demodev\" ). SetTLSConfig ( tlsconfig ) ... c . Publish ( \"demodev/hello\" , 0 , false , text ) Detailed JITPD Step 1: Create CA in AWS Iot Core AWS IoT Core requires to upload a verification certificate to be uploaded to register a CA certificate. A verification certificate is a certificate signed by that CA, this way we proof the CA we are uploading is ours. First we have to create a test CA certificate using openssl. For that we create a test OpenSSL config file: mkdir openssl touch openssl/deviceRootCA_openssl.conf deviceRootCA_openssl.conf: tee openssl/deviceRootCA_openssl.conf <<EOF [ req ] distinguished_name = req_distinguished_name extensions = v3_ca req_extensions = v3_ca [ v3_ca ] basicConstraints = CA:TRUE [ req_distinguished_name ] countryName = Country Name (2 letter code) countryName_default = IN countryName_min = 2 countryName_max = 2 organizationName = Organization Name (eg, company) organizationName_default = AMZ EOF Now create a folder to store the certificates that will be issued: mkdir -p test/certs Generate device CA private key: openssl genrsa -out test/certs/deviceRootCA.key 2048 ```` Create CSR for device root: ``` bash openssl req -new -sha256 -key test/certs/deviceRootCA.key -nodes -out test/certs/deviceRootCA.csr -config openssl/deviceRootCA_openssl.conf -subj \"/C=ES/O=testCAName\" Creating CA certificate: openssl x509 -req -days 3650 -extfile openssl/deviceRootCA_openssl.conf -extensions v3_ca -in test/certs/deviceRootCA.csr -signkey test/certs/deviceRootCA.key -out test/certs/deviceRootCA.pem Getting CA registration code from your AWS region: export region = <your AWS region> export reg_code = $( aws iot get-registration-code --region $region | jq -r .registrationCode ) Generation private key for CA verification certificate: openssl genrsa -out test/certs/verificationCert.key 2048 Generating CSR for CA verification certificate: openssl req -new -key test/certs/verificationCert.key -out test/certs/verificationCert.csr -subj \"/C=ES/ST=Gipuzkoa/L=Arrasate/O=testCAName/OU=Lamassu/CN= $reg_code \" Generating CA verification certificate: openssl x509 -req -in test/certs/verificationCert.csr -CA test/certs/deviceRootCA.pem -CAkey test/certs/deviceRootCA.key -CAcreateserial -out test/certs/verificationCert.crt -days 500 -sha256 Once the CA certificate is created and the verification certificate is signed we can upload the CA to AWS IoT Core: export certificate_id = $( aws iot register-ca-certificate --ca-certificate file://test/certs/deviceRootCA.pem --verification-cert file://test/certs/verificationCert.crt --set-as- | jq -r .certificateId ) Step 2: Create JITP Role To create service Role for JITP follow the following link: JITP Role Step 3: Attach a JITP template to CA on IoT Core Attach the registration configuration file to the CA uploaded in the previous step. First create a policy: mkdir templates touch templates/policy.json Export AWS account number export aws_account = <your account number> templates/policy.json tee templates/policy.json <<EOF { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"iot:Connect\" ], \"Resource\": [ \"arn:aws:iot:eu-west-1:$aws_account:client/${iot:Connection.Thing.ThingName}\" ] }, { \"Effect\": \"Allow\", \"Action\": [ \"iot:Publish\", \"iot:Receive\" ], \"Resource\": [ \"arn:aws:iot:eu-west-1:$aws_account:topic/${iot:Connection.Thing.ThingName}/*\" ] }, { \"Effect\": \"Allow\", \"Action\": [ \"iot:Subscribe\" ], \"Resource\": [ \"arn:aws:iot:eu-west-1:$aws_account:topicfilter/${iot:Connection.Thing.ThingName}/*\" ] } ] } EOF Register policy in AWS: aws iot create-policy --policy-name lamassu-test-policy --policy-document file://templates/policy.json Create the JITP template: templates/jitp_template.json tee templates/jitp_template.json <<EOF { \"templateBody\" : \"{ \\\"Parameters\\\" : { \\\"AWS::IoT::Certificate::CommonName\\\": { \\\"Type\\\": \\\"String\\\" }, \\\"AWS::IoT::Certificate::SerialNumber\\\": { \\\"Type\\\": \\\"String\\\" }, \\\"AWS::IoT::Certificate::Id\\\": { \\\"Type\\\": \\\"String\\\" } }, \\\"Resources\\\": { \\\"thing\\\": { \\\"Type\\\": \\\"AWS::IoT::Thing\\\", \\\"Properties\\\": { \\\"ThingName\\\": {\\\"Ref\\\": \\\"AWS::IoT::Certificate::CommonName\\\" }, \\\"AttributePayload\\\": {} }}, \\\"certificate\\\": { \\\"Type\\\": \\\"AWS::IoT::Certificate\\\", \\\"Properties\\\": { \\\"CertificateId\\\": {\\\"Ref\\\": \\\"AWS::IoT::Certificate::Id\\\" }, \\\"Status\\\": \\\"ACTIVE\\\" }}, \\\"policy\\\": { \\\"Type\\\": \\\"AWS::IoT::Policy\\\", \\\"Properties\\\": { \\\"PolicyName\\\": \\\"lamassu-test-policy\\\" } }}}\", \"roleArn\":\"arn:aws:iam::$aws_account:role/JITPRole\" } EOF NOTE : If policy name is changed it must be also changed in JITP template templateBody field. Update the CA certificate created in Step 1. aws iot update-ca-certificate --certificate-id $certificate_id --new-auto-registration-status ENABLE --registration-config file://templates/jitp_template.json Step 4: Issue a device certificate with that CA. Generate device private key: openssl genrsa -out test/certs/deviceCert.key 2048 Generating CSR for device: openssl req -new -key test/certs/deviceCert.key -out test/certs/deviceCert.csr -subj \"/C=ES/ST=Gipuzkoa/L=Arrasate/O=testCAName/OU=Lamassu/CN=testdeviceLamassu\" Generating device certificate: openssl x509 -req -in test/certs/deviceCert.csr -CA test/certs/deviceRootCA.pem -CAkey test/certs/deviceRootCA.key -CAcreateserial -out test/certs/deviceCert.crt -days 365 -sha256 Create certificate chain for the device: cat test/certs/deviceCert.crt test/certs/deviceRootCA.pem > test/certs/deviceCertAndCACert.crt Downloading AWS Root CA certificate, it is needed to check IoT Core endpoint certificate: wget https://www.amazontrust.com/repository/AmazonRootCA1.pem -O test/certs/awsRootCA.pem Step 5: Load the certificate in the device If a test device is used, you need to the following files into it: * test/certs/awsRootCA. * test/certs/deviceCertAndCACert.crt * test/certs/deviceCert.crt * test/certs/deviceCert.key Step 6: Connect to the IoT Core Enpoint using that certificate. First, get the IoT Core Endpoint: export iot_endpoint = $( aws iot describe-endpoint --endpoint-type iot:Data-ATS | jq -r .endpointAddress ) Test connection to IoT Core: bash mosquitto_pub --cafile test/certs/awsRootCA.pem \\ --cert test/certs/deviceCertAndCACert.crt \\ --key test/certs/deviceCert.key \\ -h $iot_endpoint \\ -p 8883 -q 1 \\ -t testdeviceLamassu -i testdeviceLamassu -m \"hello JITP\" -d NOTE : Topic should start with device common name \\ /* and device ID (-i flag) should be equal to certificate common name. References AWS JITP example : JITP demo example JITP official documentation : JITP documentation","title":"JITP (Just In Time Provisioning)"},{"location":"jitp/#jitp-just-in-time-provisioning","text":"","title":"JITP (Just In Time Provisioning)"},{"location":"jitp/#overview","text":"You can have your devices provisioned when they first attempt to connect to AWS IoT with just-in-time provisioning (JITP) . To provision the device, you must enable automatic registration and associate a provisioning template with the CA certificate used to sign the device certificate. When a device attempts to connect to AWS IoT by using a certificate signed by a registered CA certificate, AWS IoT loads the template from the CA certificate and uses it to register the thing. The JITP workflow first registers a certificate with a status value of PENDING_ACTIVATION. When the device provisioning flow is complete, the status of the certificate is changed to ACTIVE.","title":"Overview"},{"location":"jitp/#prerequisites","text":"To perform the tests, we need the following prerequisites: Install jq and mosquitto-clients apt install jq apt install mosquitto-clients Configure AWS CLI: AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY and REGION must be configured. Configure AWS CLI","title":"Prerequisites"},{"location":"jitp/#flow","text":"Create a certificate authority and upload it to AWS. Attach a JITP template to the CA in AWS IoT Core. Enable auto-registration for that CA in AWS. Issue a certificate with that CA. Load the certificate in the device Connect to the IoT Core Enpoint using that certificate. The device will automatically register in AWS IoT Core with the corresponding certificate and the certificate would be attached to the policy stated in the JITP template. Now the device can interact with AWS. NOTE * : Device fails to connect to AWS on first attempt.","title":"Flow"},{"location":"jitp/#usage","text":"Steps to reproduce: Create a CA certificate in AWS. bash jitp_demo.sh Fill the following inputs and check that your CA has been correctly created in AWS IoT Core. Introduce CA name: Introduce demo device name: Introduce AWS Policy Name ( Must be unique in AWS ) : This script covers steps 1 to 4 in JITP flow. As a result of jitp_demo.sh script some test certificates have been created under test/certs folder. You can execute test/go/main.go or test/bash/mosquitto.sh to test connection to AWS IoT Core. If you are using mosquitto.sh : you need to change -i flag to be equal to the certificate common name and -t flag (topic) must be \" common_name / \" for the device to connect to AWS. For example, if CN=demodev: mosquitto_pub --cafile ../certs/awsRootCA.pem \\ --cert ../certs/deviceCertAndCACert.crt \\ --key ../certs/deviceCert.key \\ -h a3hczhtwc7h4es-ats.iot.eu-west-1.amazonaws.com \\ -p 8883 -q 1 \\ -t demodev -i demodev -m \"hello\" -d If you are using go main.go *: you need to change device Id and topic. Lines 103 and 118. opts . SetClientID ( \"demodev\" ). SetTLSConfig ( tlsconfig ) ... c . Publish ( \"demodev/hello\" , 0 , false , text )","title":"Usage"},{"location":"jitp/#detailed-jitpd","text":"","title":"Detailed JITPD"},{"location":"jitp/#step-1-create-ca-in-aws-iot-core","text":"AWS IoT Core requires to upload a verification certificate to be uploaded to register a CA certificate. A verification certificate is a certificate signed by that CA, this way we proof the CA we are uploading is ours. First we have to create a test CA certificate using openssl. For that we create a test OpenSSL config file: mkdir openssl touch openssl/deviceRootCA_openssl.conf deviceRootCA_openssl.conf: tee openssl/deviceRootCA_openssl.conf <<EOF [ req ] distinguished_name = req_distinguished_name extensions = v3_ca req_extensions = v3_ca [ v3_ca ] basicConstraints = CA:TRUE [ req_distinguished_name ] countryName = Country Name (2 letter code) countryName_default = IN countryName_min = 2 countryName_max = 2 organizationName = Organization Name (eg, company) organizationName_default = AMZ EOF Now create a folder to store the certificates that will be issued: mkdir -p test/certs Generate device CA private key: openssl genrsa -out test/certs/deviceRootCA.key 2048 ```` Create CSR for device root: ``` bash openssl req -new -sha256 -key test/certs/deviceRootCA.key -nodes -out test/certs/deviceRootCA.csr -config openssl/deviceRootCA_openssl.conf -subj \"/C=ES/O=testCAName\" Creating CA certificate: openssl x509 -req -days 3650 -extfile openssl/deviceRootCA_openssl.conf -extensions v3_ca -in test/certs/deviceRootCA.csr -signkey test/certs/deviceRootCA.key -out test/certs/deviceRootCA.pem Getting CA registration code from your AWS region: export region = <your AWS region> export reg_code = $( aws iot get-registration-code --region $region | jq -r .registrationCode ) Generation private key for CA verification certificate: openssl genrsa -out test/certs/verificationCert.key 2048 Generating CSR for CA verification certificate: openssl req -new -key test/certs/verificationCert.key -out test/certs/verificationCert.csr -subj \"/C=ES/ST=Gipuzkoa/L=Arrasate/O=testCAName/OU=Lamassu/CN= $reg_code \" Generating CA verification certificate: openssl x509 -req -in test/certs/verificationCert.csr -CA test/certs/deviceRootCA.pem -CAkey test/certs/deviceRootCA.key -CAcreateserial -out test/certs/verificationCert.crt -days 500 -sha256 Once the CA certificate is created and the verification certificate is signed we can upload the CA to AWS IoT Core: export certificate_id = $( aws iot register-ca-certificate --ca-certificate file://test/certs/deviceRootCA.pem --verification-cert file://test/certs/verificationCert.crt --set-as- | jq -r .certificateId )","title":"Step 1: Create CA in AWS Iot Core"},{"location":"jitp/#step-2-create-jitp-role","text":"To create service Role for JITP follow the following link: JITP Role","title":"Step 2: Create JITP Role"},{"location":"jitp/#step-3-attach-a-jitp-template-to-ca-on-iot-core","text":"Attach the registration configuration file to the CA uploaded in the previous step. First create a policy: mkdir templates touch templates/policy.json Export AWS account number export aws_account = <your account number> templates/policy.json tee templates/policy.json <<EOF { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"iot:Connect\" ], \"Resource\": [ \"arn:aws:iot:eu-west-1:$aws_account:client/${iot:Connection.Thing.ThingName}\" ] }, { \"Effect\": \"Allow\", \"Action\": [ \"iot:Publish\", \"iot:Receive\" ], \"Resource\": [ \"arn:aws:iot:eu-west-1:$aws_account:topic/${iot:Connection.Thing.ThingName}/*\" ] }, { \"Effect\": \"Allow\", \"Action\": [ \"iot:Subscribe\" ], \"Resource\": [ \"arn:aws:iot:eu-west-1:$aws_account:topicfilter/${iot:Connection.Thing.ThingName}/*\" ] } ] } EOF Register policy in AWS: aws iot create-policy --policy-name lamassu-test-policy --policy-document file://templates/policy.json Create the JITP template: templates/jitp_template.json tee templates/jitp_template.json <<EOF { \"templateBody\" : \"{ \\\"Parameters\\\" : { \\\"AWS::IoT::Certificate::CommonName\\\": { \\\"Type\\\": \\\"String\\\" }, \\\"AWS::IoT::Certificate::SerialNumber\\\": { \\\"Type\\\": \\\"String\\\" }, \\\"AWS::IoT::Certificate::Id\\\": { \\\"Type\\\": \\\"String\\\" } }, \\\"Resources\\\": { \\\"thing\\\": { \\\"Type\\\": \\\"AWS::IoT::Thing\\\", \\\"Properties\\\": { \\\"ThingName\\\": {\\\"Ref\\\": \\\"AWS::IoT::Certificate::CommonName\\\" }, \\\"AttributePayload\\\": {} }}, \\\"certificate\\\": { \\\"Type\\\": \\\"AWS::IoT::Certificate\\\", \\\"Properties\\\": { \\\"CertificateId\\\": {\\\"Ref\\\": \\\"AWS::IoT::Certificate::Id\\\" }, \\\"Status\\\": \\\"ACTIVE\\\" }}, \\\"policy\\\": { \\\"Type\\\": \\\"AWS::IoT::Policy\\\", \\\"Properties\\\": { \\\"PolicyName\\\": \\\"lamassu-test-policy\\\" } }}}\", \"roleArn\":\"arn:aws:iam::$aws_account:role/JITPRole\" } EOF NOTE : If policy name is changed it must be also changed in JITP template templateBody field. Update the CA certificate created in Step 1. aws iot update-ca-certificate --certificate-id $certificate_id --new-auto-registration-status ENABLE --registration-config file://templates/jitp_template.json","title":"Step 3: Attach a JITP template to CA on IoT Core"},{"location":"jitp/#step-4-issue-a-device-certificate-with-that-ca","text":"Generate device private key: openssl genrsa -out test/certs/deviceCert.key 2048 Generating CSR for device: openssl req -new -key test/certs/deviceCert.key -out test/certs/deviceCert.csr -subj \"/C=ES/ST=Gipuzkoa/L=Arrasate/O=testCAName/OU=Lamassu/CN=testdeviceLamassu\" Generating device certificate: openssl x509 -req -in test/certs/deviceCert.csr -CA test/certs/deviceRootCA.pem -CAkey test/certs/deviceRootCA.key -CAcreateserial -out test/certs/deviceCert.crt -days 365 -sha256 Create certificate chain for the device: cat test/certs/deviceCert.crt test/certs/deviceRootCA.pem > test/certs/deviceCertAndCACert.crt Downloading AWS Root CA certificate, it is needed to check IoT Core endpoint certificate: wget https://www.amazontrust.com/repository/AmazonRootCA1.pem -O test/certs/awsRootCA.pem","title":"Step 4: Issue a device certificate with that CA."},{"location":"jitp/#step-5-load-the-certificate-in-the-device","text":"If a test device is used, you need to the following files into it: * test/certs/awsRootCA. * test/certs/deviceCertAndCACert.crt * test/certs/deviceCert.crt * test/certs/deviceCert.key","title":"Step 5: Load the certificate in the device"},{"location":"jitp/#step-6-connect-to-the-iot-core-enpoint-using-that-certificate","text":"First, get the IoT Core Endpoint: export iot_endpoint = $( aws iot describe-endpoint --endpoint-type iot:Data-ATS | jq -r .endpointAddress ) Test connection to IoT Core: bash mosquitto_pub --cafile test/certs/awsRootCA.pem \\ --cert test/certs/deviceCertAndCACert.crt \\ --key test/certs/deviceCert.key \\ -h $iot_endpoint \\ -p 8883 -q 1 \\ -t testdeviceLamassu -i testdeviceLamassu -m \"hello JITP\" -d NOTE : Topic should start with device common name \\ /* and device ID (-i flag) should be equal to certificate common name.","title":"Step 6: Connect to the IoT Core Enpoint using that certificate."},{"location":"jitp/#references","text":"AWS JITP example : JITP demo example JITP official documentation : JITP documentation","title":"References"},{"location":"manage/","text":"Managing Lamassu Certificate rotation By default, all self-signed certificates (both upstream and downstream) have a lifespan of 365 days. At that point it will be necessary to regenerate the expired certificates: Regenerate the certificates: cd tls-certificates ./gen-upstream-certs.sh ./gen-downstream-certs.sh cd .. Reboot all services: docker-compose down docker-compose up -d Backup strategy Restoring backups","title":"Managing Lamassu"},{"location":"manage/#managing-lamassu","text":"","title":"Managing Lamassu"},{"location":"manage/#certificate-rotation","text":"By default, all self-signed certificates (both upstream and downstream) have a lifespan of 365 days. At that point it will be necessary to regenerate the expired certificates: Regenerate the certificates: cd tls-certificates ./gen-upstream-certs.sh ./gen-downstream-certs.sh cd .. Reboot all services: docker-compose down docker-compose up -d","title":"Certificate rotation"},{"location":"manage/#backup-strategy","text":"","title":"Backup strategy"},{"location":"manage/#restoring-backups","text":"","title":"Restoring backups"},{"location":"pkcs/","text":"PKCS 11 Lamassu has a Go implementation of the PKCS 11 standard. It has been tested with SoftHSM.SoftHSM is an implementation of a cryptographic store accessible through a PKCS #11 interface. This is an implementation of the standard Golang crypto interfaces that uses PKCS#11 as a backend. The supported features are: Generation and retrieval of RSA, DSA and ECDSA keys. Importing and retrieval of x509 certificates PKCS#1 v1.5 signing. PKCS#1 PSS signing. PKCS#1 v1.5 decryption PKCS#1 OAEP decryption ECDSA signing. DSA signing. Random number generation. AES and DES3 encryption and decryption. HMAC support. Signing is done through the crypto.Signer interface and decryption through crypto.Decrypter . To verify signatures or encrypt messages, retrieve the public key and do it in software. See the documentation for details of various limitations, especially regarding symmetric crypto. SoftHSM Make it use a custom configuration file export SOFTHSM_CONF=$PWD/softhsm.conf Then use softhsm to init it softhsm --init-token --slot 0 --label test --pin 1234 Then use libsofthsm2.so as the pkcs11 module: p := pkcs11 . New ( \"/usr/lib/softhsm/libsofthsm2.so\" ) Testing To set up a slot: $ cat softhsm2.conf directories.tokendir = /home/rjk/go/src/github.com/ThalesIgnite/crypto11/tokens objectstore.backend = file log.level = INFO $ mkdir tokens $ export SOFTHSM2_CONF=`pwd`/softhsm2.conf $ softhsm2-util --init-token --slot 0 --label test === SO PIN (4-255 characters) === Please enter SO PIN: ******** Please reenter SO PIN: ******** === User PIN (4-255 characters) === Please enter user PIN: ******** Please reenter user PIN: ******** The token has been initialized. The configuration looks like this: $ cat config { \"Path\" : \"/usr/lib/softhsm/libsofthsm2.so\", \"TokenLabel\": \"test\", \"Pin\" : \"password\" } Installation Since v1.0.0, crypto11 requires Go v1.11+. Install the library by running: go get github.com/ThalesIgnite/crypto11 The crypto11 library needs to be configured with information about your PKCS#11 installation. This is either done programmatically (see the Config struct in the documentation ) or via a configuration file. The configuration file is a JSON representation of the Config struct. A minimal configuration file looks like this: { \"Path\" : \"/usr/lib/softhsm/libsofthsm2.so\" , \"TokenLabel\" : \"token1\" , \"Pin\" : \"password\" } Path points to the library from your PKCS#11 vendor. TokenLabel is the CKA_LABEL of the token you wish to use. Pin is the password for the CKU_USER user. PoC setup Regenerate PreSharedKey test.psk psk=$(openssl rand -base64 18 | xxd -p) echo \"test:$psk\" > test.psk HSM Server Build docker build -f softhsm-v2.Dockerfile -t softhsmv2 . PKC11 Client Build docker build -f pkcs11-client.Dockerfile -t pkcs11-client . HSM Server Run docker run -it -p 5657:5657 --name hsm softhsmv2 PKC11 Client Run docker run -it --link=hsm:hsm pkcs11-client bash ./pkcs11-go-client -module=/usr/local/lib/libpkcs11-proxy.so -pin=1234 ./crypto11-go-client -module /usr/local/lib/libpkcs11-proxy.so -token-label=lamassuHSM -pin=1234 pkcs11-tool --module=/usr/local/lib/libpkcs11-proxy.so -L","title":"PKCS 11"},{"location":"pkcs/#pkcs-11","text":"Lamassu has a Go implementation of the PKCS 11 standard. It has been tested with SoftHSM.SoftHSM is an implementation of a cryptographic store accessible through a PKCS #11 interface. This is an implementation of the standard Golang crypto interfaces that uses PKCS#11 as a backend. The supported features are: Generation and retrieval of RSA, DSA and ECDSA keys. Importing and retrieval of x509 certificates PKCS#1 v1.5 signing. PKCS#1 PSS signing. PKCS#1 v1.5 decryption PKCS#1 OAEP decryption ECDSA signing. DSA signing. Random number generation. AES and DES3 encryption and decryption. HMAC support. Signing is done through the crypto.Signer interface and decryption through crypto.Decrypter . To verify signatures or encrypt messages, retrieve the public key and do it in software. See the documentation for details of various limitations, especially regarding symmetric crypto.","title":"PKCS 11"},{"location":"pkcs/#softhsm","text":"Make it use a custom configuration file export SOFTHSM_CONF=$PWD/softhsm.conf Then use softhsm to init it softhsm --init-token --slot 0 --label test --pin 1234 Then use libsofthsm2.so as the pkcs11 module: p := pkcs11 . New ( \"/usr/lib/softhsm/libsofthsm2.so\" )","title":"SoftHSM"},{"location":"pkcs/#testing","text":"To set up a slot: $ cat softhsm2.conf directories.tokendir = /home/rjk/go/src/github.com/ThalesIgnite/crypto11/tokens objectstore.backend = file log.level = INFO $ mkdir tokens $ export SOFTHSM2_CONF=`pwd`/softhsm2.conf $ softhsm2-util --init-token --slot 0 --label test === SO PIN (4-255 characters) === Please enter SO PIN: ******** Please reenter SO PIN: ******** === User PIN (4-255 characters) === Please enter user PIN: ******** Please reenter user PIN: ******** The token has been initialized. The configuration looks like this: $ cat config { \"Path\" : \"/usr/lib/softhsm/libsofthsm2.so\", \"TokenLabel\": \"test\", \"Pin\" : \"password\" }","title":"Testing"},{"location":"pkcs/#installation","text":"Since v1.0.0, crypto11 requires Go v1.11+. Install the library by running: go get github.com/ThalesIgnite/crypto11 The crypto11 library needs to be configured with information about your PKCS#11 installation. This is either done programmatically (see the Config struct in the documentation ) or via a configuration file. The configuration file is a JSON representation of the Config struct. A minimal configuration file looks like this: { \"Path\" : \"/usr/lib/softhsm/libsofthsm2.so\" , \"TokenLabel\" : \"token1\" , \"Pin\" : \"password\" } Path points to the library from your PKCS#11 vendor. TokenLabel is the CKA_LABEL of the token you wish to use. Pin is the password for the CKU_USER user.","title":"Installation"},{"location":"pkcs/#poc-setup","text":"","title":"PoC setup"},{"location":"pkcs/#regenerate-presharedkey-testpsk","text":"psk=$(openssl rand -base64 18 | xxd -p) echo \"test:$psk\" > test.psk","title":"Regenerate PreSharedKey test.psk"},{"location":"pkcs/#hsm-server-build","text":"docker build -f softhsm-v2.Dockerfile -t softhsmv2 .","title":"HSM Server Build"},{"location":"pkcs/#pkc11-client-build","text":"docker build -f pkcs11-client.Dockerfile -t pkcs11-client .","title":"PKC11 Client Build"},{"location":"pkcs/#hsm-server-run","text":"docker run -it -p 5657:5657 --name hsm softhsmv2","title":"HSM Server Run"},{"location":"pkcs/#pkc11-client-run","text":"docker run -it --link=hsm:hsm pkcs11-client bash ./pkcs11-go-client -module=/usr/local/lib/libpkcs11-proxy.so -pin=1234 ./crypto11-go-client -module /usr/local/lib/libpkcs11-proxy.so -token-label=lamassuHSM -pin=1234 pkcs11-tool --module=/usr/local/lib/libpkcs11-proxy.so -L","title":"PKC11 Client Run"},{"location":"protocols/","text":"Protocols Lamassu supports a set of standards to perform some of its key functionalities such as enrolling devices as well as validating the status of a given certificate. This section aims to describe those protocols as well as explaining how them with practical examples. OCSP The Online Certificate Status Protocol or OCSP for short, is a protocol used to determine the current status of a digital certificate without requiring the use of Certificate Revocation Lists (CRLs). As defined by the standard, there are two possible methods that can be used to perform the http request: Method Path Headers Body payload Used when GET {url}/{url-encoding of base-64 encoding of the DER encoding of the OCSPRequest} Recommended when the encoded request is less than 255 bytes PUT {url} Content-Type: application/ocsp-request Binary value of the DER encoding of the OCSPRequest Can always be used GET Request OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request OCSP_REQUEST=$(openssl ocsp -CAfile $CA_CERTIFICATE -issuer $CA_CERTIFICATE -cert $DEVICE_CERTIFICATE -reqout - | base64 -w 0) Check the status of the certificate curl --location --request GET \"https://$OCSP_SERVER/api/ocsp/$OCSP_REQUEST\" > ocspresponse.der openssl ocsp -respin ocspresponse.der -VAfile root-ca.pem -resp_text package main import ( \"crypto/x509\" \"encoding/base64\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } encodedRequest := base64 . StdEncoding . EncodeToString ( ocspRequestBytes ) fmt . Println ( encodedRequest ) reqURL := ocspServer + \"/\" + encodedRequest resp , err := http . Get ( reqURL ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) } POST Request OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request openssl ocsp -issuer ca.crt -cert dev.crt -reqout - > ocsp-request-post.der Check the status of the certificate curl --location --request POST \"https://$DOMAIN/api/ocsp/\" --header 'Content-Type: application/ocsp-request' --data-binary '@ocsp-request-post.der' > ocsp-response-post.der -k openssl ocsp -respin ocsp-response-post.der -VAfile root-ca.pem -resp_text package main import ( \"bytes\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } resp , err := http . Post ( ocspServer , \"application/ocsp-request\" , bytes . NewReader ( ocspRequestBytes )) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) } EST The core mechanism to obtain valid certificates for your devices is using the enrollment process described by the EST protocol. EST or Enrollment over Secure Transport establishes a set of standardized endpoints. The following table sums up all endpoints defined by the EST protocol and wether or not are supported by the current implementation. Operation Operation Path Required by RFC7030 Supported Distribution of CA Certificates /api/devmanager/.well-known/cacerts Enrollment of Clients /api/devmanager/.well-known/simpleenroll Re-enrollment of Clients /api/devmanager/.well-known/simplereenroll Full CMC /api/devmanager/.well-known/fullcmc Server-Side Key Generation /api/devmanager/.well-known/serverkeygen CSR Attributes /api/devmanager/.well-known/csrattrs Distribution of CA Certificates GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates estclient cacerts -server $DOMAIN/api/devmanager -explicit root-ca.pem -out cacerts.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" clientcrt := \"dms.crt\" clientkey := \"dms.key\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( clientcrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( clientkey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cas , err := estClient . CACerts ( context . Background ()) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } } Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates curl https://$DOMAIN/api/devmanager/.well-known/est/cacerts -o cacerts.p7 --cacert root-ca.pem openssl base64 -d -in cacerts.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cacerts.pem Enrollment of Devices GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with an existing private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient enroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out cert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecsr := \"device.csr\" devicecrt := \"device.crt\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Enroll ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with an existing private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/simpleenroll --cert $DMS_CRT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cert.pem Re-enrollment of Devices GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Reenrolling estclient reenroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -key $DEVICE_KEY -certs $DEVICE_CRT -out newcert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( devicecrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( devicekey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Reenroll ( context . Background (), csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key exprot DEVICE_CSR=device.csr Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device enroll CSR sed '/CERTIFICATE/d' device.csr > device_enroll.csr Reenrolling curl https://$DOMAIN/api/devmanager/.well-known/est/simplereenroll --cert $DEVICE_CRT --key $DEVICE_KEY -s -o newcert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in newcert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out $DEVICE_CRT Server Key Generation of Devices GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with a server-generated private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient serverkeygen -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out device.crt -keyout device.key package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , key , err := estClient . ServerKeyGen ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) b = pem . Block { Type : \"PRIVATE KEY\" , Bytes : key } keyPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicekey , keyPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with a server-generated private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/serverkeygen --cert $DMS_CERT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" cat cert.p7 | sed -ne '/application\\/pkcs7-mime/,/-estServerKeyGenBoundary/p' | sed '/-/d' > crt.p7 openssl base64 -d -in crt.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device.pem","title":"Protocols"},{"location":"protocols/#protocols","text":"Lamassu supports a set of standards to perform some of its key functionalities such as enrolling devices as well as validating the status of a given certificate. This section aims to describe those protocols as well as explaining how them with practical examples.","title":"Protocols"},{"location":"protocols/#ocsp","text":"The Online Certificate Status Protocol or OCSP for short, is a protocol used to determine the current status of a digital certificate without requiring the use of Certificate Revocation Lists (CRLs). As defined by the standard, there are two possible methods that can be used to perform the http request: Method Path Headers Body payload Used when GET {url}/{url-encoding of base-64 encoding of the DER encoding of the OCSPRequest} Recommended when the encoded request is less than 255 bytes PUT {url} Content-Type: application/ocsp-request Binary value of the DER encoding of the OCSPRequest Can always be used","title":"OCSP"},{"location":"protocols/#get-request","text":"OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request OCSP_REQUEST=$(openssl ocsp -CAfile $CA_CERTIFICATE -issuer $CA_CERTIFICATE -cert $DEVICE_CERTIFICATE -reqout - | base64 -w 0) Check the status of the certificate curl --location --request GET \"https://$OCSP_SERVER/api/ocsp/$OCSP_REQUEST\" > ocspresponse.der openssl ocsp -respin ocspresponse.der -VAfile root-ca.pem -resp_text package main import ( \"crypto/x509\" \"encoding/base64\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } encodedRequest := base64 . StdEncoding . EncodeToString ( ocspRequestBytes ) fmt . Println ( encodedRequest ) reqURL := ocspServer + \"/\" + encodedRequest resp , err := http . Get ( reqURL ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) }","title":"GET Request"},{"location":"protocols/#post-request","text":"OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request openssl ocsp -issuer ca.crt -cert dev.crt -reqout - > ocsp-request-post.der Check the status of the certificate curl --location --request POST \"https://$DOMAIN/api/ocsp/\" --header 'Content-Type: application/ocsp-request' --data-binary '@ocsp-request-post.der' > ocsp-response-post.der -k openssl ocsp -respin ocsp-response-post.der -VAfile root-ca.pem -resp_text package main import ( \"bytes\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } resp , err := http . Post ( ocspServer , \"application/ocsp-request\" , bytes . NewReader ( ocspRequestBytes )) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) }","title":"POST Request"},{"location":"protocols/#est","text":"The core mechanism to obtain valid certificates for your devices is using the enrollment process described by the EST protocol. EST or Enrollment over Secure Transport establishes a set of standardized endpoints. The following table sums up all endpoints defined by the EST protocol and wether or not are supported by the current implementation. Operation Operation Path Required by RFC7030 Supported Distribution of CA Certificates /api/devmanager/.well-known/cacerts Enrollment of Clients /api/devmanager/.well-known/simpleenroll Re-enrollment of Clients /api/devmanager/.well-known/simplereenroll Full CMC /api/devmanager/.well-known/fullcmc Server-Side Key Generation /api/devmanager/.well-known/serverkeygen CSR Attributes /api/devmanager/.well-known/csrattrs","title":"EST"},{"location":"protocols/#distribution-of-ca-certificates","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates estclient cacerts -server $DOMAIN/api/devmanager -explicit root-ca.pem -out cacerts.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" clientcrt := \"dms.crt\" clientkey := \"dms.key\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( clientcrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( clientkey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cas , err := estClient . CACerts ( context . Background ()) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } } Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates curl https://$DOMAIN/api/devmanager/.well-known/est/cacerts -o cacerts.p7 --cacert root-ca.pem openssl base64 -d -in cacerts.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cacerts.pem","title":"Distribution of CA Certificates"},{"location":"protocols/#enrollment-of-devices","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with an existing private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient enroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out cert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecsr := \"device.csr\" devicecrt := \"device.crt\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Enroll ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with an existing private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/simpleenroll --cert $DMS_CRT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cert.pem","title":"Enrollment of Devices"},{"location":"protocols/#re-enrollment-of-devices","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Reenrolling estclient reenroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -key $DEVICE_KEY -certs $DEVICE_CRT -out newcert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( devicecrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( devicekey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Reenroll ( context . Background (), csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key exprot DEVICE_CSR=device.csr Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device enroll CSR sed '/CERTIFICATE/d' device.csr > device_enroll.csr Reenrolling curl https://$DOMAIN/api/devmanager/.well-known/est/simplereenroll --cert $DEVICE_CRT --key $DEVICE_KEY -s -o newcert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in newcert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out $DEVICE_CRT","title":"Re-enrollment of Devices"},{"location":"protocols/#server-key-generation-of-devices","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with a server-generated private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient serverkeygen -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out device.crt -keyout device.key package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , key , err := estClient . ServerKeyGen ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) b = pem . Block { Type : \"PRIVATE KEY\" , Bytes : key } keyPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicekey , keyPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with a server-generated private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/serverkeygen --cert $DMS_CERT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" cat cert.p7 | sed -ne '/application\\/pkcs7-mime/,/-estServerKeyGenBoundary/p' | sed '/-/d' > crt.p7 openssl base64 -d -in crt.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device.pem","title":"Server Key Generation of Devices"},{"location":"setup/","text":"Install Lamassu Compose Lamassu Compose is the official release containing the scripts and resources required to deploy all microservices such as the CA component, the VA component or the RA components to name a few. Architecture Lamassu Compose offers a SECURE deployment of the set of microservices required to manage an industrial PKI. The architecture presented on the following image reflects the interconnection of the different services mainly using the HTTP Protocol. The use of this deployment offers the following non functional requirements by leveraging the use of an API Gateway: Centralized point of access : Each microservice listens on a different port which ends up being challenging for developers and users. With the use of the API Gateway, the user will always access the same host and port address. Port 80 for HTTP connections and port 443 for HTTPS connections. Authentication : In order to invoke any endpoint, the API Gateway enforces each request to present a JWT. Upon receiving an HTTP request, the gateway validates the presented token against the authentication server. Authorization : Another key aspect is enforcing an authorization schema. Lamassu has been configured in such way that only specific endpoints are accessible by non admin users. Tracing : Logging the life of an HTTP request can be helpful during the debugging process of such complex application. The tracing aspect eases this process by injecting a unique identifier to each request that is then printed out by each microservice logs. Mutual TLS authentication : As mentioned earlier the gateway acts as the traffic orchestrator knowing where each service is and redirecting the traffic accordingly. To prevent any unauthorized request as well as protecting the communications channel between the Gateway itself and the upstream service, the API Gateway initiates a mutual TLS connection to ensure such thing. Requirements jq . Get the latest version: https://stedolan.github.io/jq/download/ docker and docker-compose : Get the latest version: https://docs.docker.com/engine/install/ubuntu/ and https://docs.docker.com/compose/install/ Have a working DNS server able to resolve the domain used during the installation process or add the following content to the /etc/hosts file, replacing the dev.lamassu.io domain with your own: 127.0.0.1 dev.lamassu.io 127.0.0.1 vault.dev.lamassu.io 127.0.0.1 auth.dev.lamassu.io 127.0.0.1 tracing.dev.lamassu.io 127.0.0.1 consul.dev.lamassu.io Setup Automatic deployment Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the next secret environment variables by exporting the following variables. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by exporting the DOMAIN variable. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env Run the installer: bash install.sh OPTIONAL : Import your certificates: The install.sh script also generates self-signed for the downstream certificates. It is possible to provide other valid certificates by replacing the following files: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt <----- Provide your certificate \u2514\u2500\u2500 tls.key <----- Provide your private key Once you replace this certificates, restart the api-gateway to obtain the imported certificates: docker-compose rm -s -f api-gateway dms-default docker-compose up -d api-gateway dms-default Final notes: \ud83d\ude80 You are ready to go \ud83d\ude80 Note Keycloak is your auth provider. During the install.sh the service is provisioned with 2 users with different roles: Username: enroller Password: enroller Role: admin Username: operator Password: operator Role: operator You can change those credentials (or create new users) using keycloak's UI available at: https://auth.<DOMAIN> Manual deployment To launch Lamassu follow the next steps: Set up your environment: Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the DB credentials variables used by the .env file. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by the .env file. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env The Gateway and TLS Certificates Lamassu uses a Gateway to expose all the deployed services. Moreover, the gateway is in charge of performing the following tasks: - Routing traffic to services - Enforcing authentication policies - Enforcing authorization policies - Logging & tracing - Healthchecking - Securely expose services using TLS The different APIs exposed through the gateway have been configured to ONLY accept request originates inside the platform via a mTLS authentication: Generate the upstream certificates. cd tls-certificates ./gen-upstream-certs.sh There are 2 options for the downstream certificate: Import an existing certificate : If you have valid certificates for your domain, you can use them by placing them under the downstream folder. The end result should be: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt \u2514\u2500\u2500 tls.key Generate a Self Signed certificate : If you need to create a new self-signed certificate, run the following command: ./gen-downstream-certs.sh Authentication service configuration: Run Keycloak: docker-compose up -d auth Keycloak image is configured with a Realm, a client and two different roles: admin and operator . Create a user with admin role to perform Enroller administrator tasks. (The command below creates a user named enroller with enroller as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u enroller -p enroller --roles admin Create a user with operator role to perform Device Manufacturing System tasks. This Device Manufacturing System must associate its CSR with this user matching the CN attribute and the username.(The command below creates a user named operator with operator as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u operator -p operator --roles operator Reload keyclok server docker-compose exec auth /opt/jboss/keycloak/bin/jboss-cli.sh --connect command=:reload If Keycloak display the following output, keycloak has successfully reloaded. Otherwise, run the command again until you see the expected output: { \"outcome\" => \"success\", \"result\" => undefined } Provision and configure Vault and Lamassu CA: Run Vault: docker-compose up -d vault consul-server api-gateway Initialize vault: This process generates vault's unseal keys as well as the root token: docker-compose exec vault vault operator init -key-shares=5 -key-threshold=3 -tls-skip-verify -format=json > vault-credentials.json Verify the vault-credentials.json file has the expected content. It should be similar to this: { \"unseal_keys_b64\": [ \"Hfx46iMq/PXoBPhDZ0EAMM9MDWS8GTCANFbAkzVEzFOD\", \"lfo48PHGFGHmpaFn6Z6rWTXTXVS53m9duxsvwVjRDc2L\", \"dcVw6N81i+/pY34WTHQYkV848to7jNeVkgdJOtgxnRkS\", \"Aut6oL7+GomXCrrTH0FCKhJwAs2PrWFYSnWpgjLfwsH0\", \"pprFM0HJEUR4m3kaIT5sga87aJ4AjXi32KVn6dgfivii\" ], \"unseal_keys_hex\": [ \"1dfc78ea232afcf5e804f84367410030cf4c0d64bc1930803456c0933544cc5383\", \"95fa38f0f1c61461e6a5a167e99eab5935d35d54b9de6f5dbb1b2fc158d10dcd8b\", \"75c570e8df358befe9637e164c7418915f38f2da3b8cd7959207493ad8319d1912\", \"02eb7aa0befe1a89970abad31f41422a127002cd8fad61584a75a98232dfc2c1f4\", \"a69ac53341c91144789b791a213e6c81af3b689e008d78b7d8a567e9d81f8af8a2\" ], \"unseal_shares\": 5, \"unseal_threshold\": 3, \"recovery_keys_b64\": [], \"recovery_keys_hex\": [], \"recovery_keys_shares\": 5, \"recovery_keys_threshold\": 3, \"root_token\": \"s.80Mpm0OmxlXzoSxZB2MMPcNu\" } Export the following variables: export VAULT_TOKEN=$(cat vault-credentials.json | jq .root_token -r) export VAULT_ADDR=https://vault.$DOMAIN Unseal Vault using the keys obtained with the previous command: curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[0])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[1])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[2])\\\" }\" Vault must be provisioned with some resources (authentication methods, policies and secret engines). That can be achieved by running the ca-provision.sh script. Vault will be provisioned with 4 Root CAs, 1 Special CA (Lamassu-DMS-Enroller) AppRole authentication method and one role and policy for each service or container that needs to exchange data with it. cd config/vault/provision/ ./provisioner.sh cd ../../../ Get RoleID and SecretID for each service and set those values in the empty fields of the .docker-compose.yml file. export CA_VAULT_ROLEID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/role-id | jq -r .data.role_id ) export CA_VAULT_SECRETID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" --request POST ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/secret-id | jq -r .data.secret_id) # Set RoleID and SecretID in docker-compose.yml file sed -i 's/<LAMASSU_CA_VAULT_ROLE_ID>/'$CA_VAULT_ROLEID'/g' docker-compose.yml sed -i 's/<LAMASSU_CA_VAULT_SECRET_ID>/'$CA_VAULT_SECRETID'/g' docker-compose.yml Configure the Device Manager: The Device Manage has a configurable variable that determines when a device can renew (also known as reenroll) its certificate. By default the reenrollment process can only be done 30 days prior to the cert's expiration time. This value can be changed by modifying the DEVICE_MANAGER_MINIMUM_REENROLL_DAYS variable located in the .env file. Start the remaining services: docker-compose up -d Configure the Default DMS First, authenticate against Keycloak: export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' |jq -r .access_token) Then, register a new DMS named Lamassu-Default-DMS: Note while registering new DMS instances with non admin users, it is necessary to register the DMS using the user's username as the common name, otherwise, the user won't see its DMSs export ENROLL_ADDR=$DOMAIN/api/dmsenroller export DMS_REGISTER_RESPONSE=$(curl -k --location --request POST \"https://$ENROLL_ADDR/v1/Lamassu-Default-DMS/form\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"url\\\":\\\"https://${DOMAIN}:5000\\\", \\\" subject\\\":{ \\\"common_name\\\": \\\"Lamassu-Default-DMS\\\",\\\"country\\\": \\\"\\\",\\\"locality\\\": \\\"\\\",\\\"organization\\\": \\\"\\\",\\\"organization_unit\\\": \\\"\\\",\\\"state\\\": \\\"\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 3072,\\\"type\\\": \\\"rsa\\\"}}\") echo $DMS_REGISTER_RESPONSE | jq -r .priv_key | sed 's/\\\\n/\\n/g' | sed -Ez '$ s/\\n+$//' | base64 -d > lamassu-default-dms/config/dms.key export DMS_ID=$(echo $DMS_REGISTER_RESPONSE | jq -r .dms.id) 3. Enroll the new DMS curl -k --location --request PUT \"https://$ENROLL_ADDR/v1/$DMS_ID\" --header \"Authorization: Bearer $TOKEN\" --header 'Content-Type: application/json' --data-raw '{\"status\": \"APPROVED\"}' 4. Get issued DMS Cert curl -k --location --request GET \"https://$ENROLL_ADDR/v1/$DMS _ID/crt\" --header \"Authorization: Bearer $TOKEN\" | base64 -d > lamassu-default-dms/config/dms.crt And finally, start the DMS \"server\": docker-compose rm -s -f dms-default docker-compose up -d dms-default Deploy AWS IoT Core connectors Requirements In order tu run the connector, you must have: NodeJS: https://nodejs.org/en/ AWS CDK v1: https://docs.aws.amazon.com/cdk/v1/guide/cli.html Deployment Download the AWS Connector source code: git clone https://github.com/lamassuiot/lamassu-aws-connector.git Configure the AWS Credentials. Those values will be used by the Lamassu AWS Connector as well as the CDK. export AWS_ACCESS_KEY_ID=<AWS_ACCESS_KEY_ID> export AWS_SECRET_ACCESS_KEY=<AWS_SECRET_ACCESS_KEY> export AWS_ACCOUNT_ID=<AWS_ACCOUNT_ID> export AWS_DEFAULT_REGION=<AWS_DEFAULT_REGION> Provide a friendly name for the Lamassu AWS Connector. This name will be displayed in the UI export CONNECTOR_NAME=Lamassu IoT AWS Account Substitute the aws-connector .env file: envsubst < .env | tee .env Generate the TLS certificates used by the connector. You must have access to the main CA certificate and private key that where generated during Lamassu installation. export INTERNAL_CA_CERT=<CHANGE_TO_LAMASSU_INSTALLATION_PATH>/tls-certificates/upstream/ca.crt export INTERNAL_CA_KEY=<CHANGE_TO_LAMASSU_INSTALLATION_PATH>/tls-certificates/upstream/ca.key After defining those variables, run the following OpenSSL commands: openssl genrsa -out aws.key 4096 openssl req -new -key aws-connector.key -out aws-connector.csr -subj \"/CN=aws-connector\" openssl x509 -req -extfile <(printf \"subjectAltName=DNS:aws-connector\") -in upstream/$1/tls.csr -days 365 -CA $INTERNAL_CA_CERT -CAkey $INTERNAL_CA_KEY -CAcreateserial -out aws.crt Deploy the required AWS services by using the CDK: cdk deploy Start the connector: docker-compose up -d","title":"Install Lamassu Compose"},{"location":"setup/#install-lamassu-compose","text":"Lamassu Compose is the official release containing the scripts and resources required to deploy all microservices such as the CA component, the VA component or the RA components to name a few.","title":"Install Lamassu Compose"},{"location":"setup/#architecture","text":"Lamassu Compose offers a SECURE deployment of the set of microservices required to manage an industrial PKI. The architecture presented on the following image reflects the interconnection of the different services mainly using the HTTP Protocol. The use of this deployment offers the following non functional requirements by leveraging the use of an API Gateway: Centralized point of access : Each microservice listens on a different port which ends up being challenging for developers and users. With the use of the API Gateway, the user will always access the same host and port address. Port 80 for HTTP connections and port 443 for HTTPS connections. Authentication : In order to invoke any endpoint, the API Gateway enforces each request to present a JWT. Upon receiving an HTTP request, the gateway validates the presented token against the authentication server. Authorization : Another key aspect is enforcing an authorization schema. Lamassu has been configured in such way that only specific endpoints are accessible by non admin users. Tracing : Logging the life of an HTTP request can be helpful during the debugging process of such complex application. The tracing aspect eases this process by injecting a unique identifier to each request that is then printed out by each microservice logs. Mutual TLS authentication : As mentioned earlier the gateway acts as the traffic orchestrator knowing where each service is and redirecting the traffic accordingly. To prevent any unauthorized request as well as protecting the communications channel between the Gateway itself and the upstream service, the API Gateway initiates a mutual TLS connection to ensure such thing.","title":"Architecture"},{"location":"setup/#requirements","text":"jq . Get the latest version: https://stedolan.github.io/jq/download/ docker and docker-compose : Get the latest version: https://docs.docker.com/engine/install/ubuntu/ and https://docs.docker.com/compose/install/ Have a working DNS server able to resolve the domain used during the installation process or add the following content to the /etc/hosts file, replacing the dev.lamassu.io domain with your own: 127.0.0.1 dev.lamassu.io 127.0.0.1 vault.dev.lamassu.io 127.0.0.1 auth.dev.lamassu.io 127.0.0.1 tracing.dev.lamassu.io 127.0.0.1 consul.dev.lamassu.io","title":"Requirements"},{"location":"setup/#setup","text":"","title":"Setup"},{"location":"setup/#automatic-deployment","text":"Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the next secret environment variables by exporting the following variables. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by exporting the DOMAIN variable. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env Run the installer: bash install.sh OPTIONAL : Import your certificates: The install.sh script also generates self-signed for the downstream certificates. It is possible to provide other valid certificates by replacing the following files: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt <----- Provide your certificate \u2514\u2500\u2500 tls.key <----- Provide your private key Once you replace this certificates, restart the api-gateway to obtain the imported certificates: docker-compose rm -s -f api-gateway dms-default docker-compose up -d api-gateway dms-default Final notes: \ud83d\ude80 You are ready to go \ud83d\ude80 Note Keycloak is your auth provider. During the install.sh the service is provisioned with 2 users with different roles: Username: enroller Password: enroller Role: admin Username: operator Password: operator Role: operator You can change those credentials (or create new users) using keycloak's UI available at: https://auth.<DOMAIN>","title":"Automatic deployment"},{"location":"setup/#manual-deployment","text":"To launch Lamassu follow the next steps: Set up your environment: Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the DB credentials variables used by the .env file. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by the .env file. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env The Gateway and TLS Certificates Lamassu uses a Gateway to expose all the deployed services. Moreover, the gateway is in charge of performing the following tasks: - Routing traffic to services - Enforcing authentication policies - Enforcing authorization policies - Logging & tracing - Healthchecking - Securely expose services using TLS The different APIs exposed through the gateway have been configured to ONLY accept request originates inside the platform via a mTLS authentication: Generate the upstream certificates. cd tls-certificates ./gen-upstream-certs.sh There are 2 options for the downstream certificate: Import an existing certificate : If you have valid certificates for your domain, you can use them by placing them under the downstream folder. The end result should be: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt \u2514\u2500\u2500 tls.key Generate a Self Signed certificate : If you need to create a new self-signed certificate, run the following command: ./gen-downstream-certs.sh Authentication service configuration: Run Keycloak: docker-compose up -d auth Keycloak image is configured with a Realm, a client and two different roles: admin and operator . Create a user with admin role to perform Enroller administrator tasks. (The command below creates a user named enroller with enroller as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u enroller -p enroller --roles admin Create a user with operator role to perform Device Manufacturing System tasks. This Device Manufacturing System must associate its CSR with this user matching the CN attribute and the username.(The command below creates a user named operator with operator as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u operator -p operator --roles operator Reload keyclok server docker-compose exec auth /opt/jboss/keycloak/bin/jboss-cli.sh --connect command=:reload If Keycloak display the following output, keycloak has successfully reloaded. Otherwise, run the command again until you see the expected output: { \"outcome\" => \"success\", \"result\" => undefined } Provision and configure Vault and Lamassu CA: Run Vault: docker-compose up -d vault consul-server api-gateway Initialize vault: This process generates vault's unseal keys as well as the root token: docker-compose exec vault vault operator init -key-shares=5 -key-threshold=3 -tls-skip-verify -format=json > vault-credentials.json Verify the vault-credentials.json file has the expected content. It should be similar to this: { \"unseal_keys_b64\": [ \"Hfx46iMq/PXoBPhDZ0EAMM9MDWS8GTCANFbAkzVEzFOD\", \"lfo48PHGFGHmpaFn6Z6rWTXTXVS53m9duxsvwVjRDc2L\", \"dcVw6N81i+/pY34WTHQYkV848to7jNeVkgdJOtgxnRkS\", \"Aut6oL7+GomXCrrTH0FCKhJwAs2PrWFYSnWpgjLfwsH0\", \"pprFM0HJEUR4m3kaIT5sga87aJ4AjXi32KVn6dgfivii\" ], \"unseal_keys_hex\": [ \"1dfc78ea232afcf5e804f84367410030cf4c0d64bc1930803456c0933544cc5383\", \"95fa38f0f1c61461e6a5a167e99eab5935d35d54b9de6f5dbb1b2fc158d10dcd8b\", \"75c570e8df358befe9637e164c7418915f38f2da3b8cd7959207493ad8319d1912\", \"02eb7aa0befe1a89970abad31f41422a127002cd8fad61584a75a98232dfc2c1f4\", \"a69ac53341c91144789b791a213e6c81af3b689e008d78b7d8a567e9d81f8af8a2\" ], \"unseal_shares\": 5, \"unseal_threshold\": 3, \"recovery_keys_b64\": [], \"recovery_keys_hex\": [], \"recovery_keys_shares\": 5, \"recovery_keys_threshold\": 3, \"root_token\": \"s.80Mpm0OmxlXzoSxZB2MMPcNu\" } Export the following variables: export VAULT_TOKEN=$(cat vault-credentials.json | jq .root_token -r) export VAULT_ADDR=https://vault.$DOMAIN Unseal Vault using the keys obtained with the previous command: curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[0])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[1])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[2])\\\" }\" Vault must be provisioned with some resources (authentication methods, policies and secret engines). That can be achieved by running the ca-provision.sh script. Vault will be provisioned with 4 Root CAs, 1 Special CA (Lamassu-DMS-Enroller) AppRole authentication method and one role and policy for each service or container that needs to exchange data with it. cd config/vault/provision/ ./provisioner.sh cd ../../../ Get RoleID and SecretID for each service and set those values in the empty fields of the .docker-compose.yml file. export CA_VAULT_ROLEID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/role-id | jq -r .data.role_id ) export CA_VAULT_SECRETID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" --request POST ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/secret-id | jq -r .data.secret_id) # Set RoleID and SecretID in docker-compose.yml file sed -i 's/<LAMASSU_CA_VAULT_ROLE_ID>/'$CA_VAULT_ROLEID'/g' docker-compose.yml sed -i 's/<LAMASSU_CA_VAULT_SECRET_ID>/'$CA_VAULT_SECRETID'/g' docker-compose.yml Configure the Device Manager: The Device Manage has a configurable variable that determines when a device can renew (also known as reenroll) its certificate. By default the reenrollment process can only be done 30 days prior to the cert's expiration time. This value can be changed by modifying the DEVICE_MANAGER_MINIMUM_REENROLL_DAYS variable located in the .env file. Start the remaining services: docker-compose up -d Configure the Default DMS First, authenticate against Keycloak: export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' |jq -r .access_token) Then, register a new DMS named Lamassu-Default-DMS: Note while registering new DMS instances with non admin users, it is necessary to register the DMS using the user's username as the common name, otherwise, the user won't see its DMSs export ENROLL_ADDR=$DOMAIN/api/dmsenroller export DMS_REGISTER_RESPONSE=$(curl -k --location --request POST \"https://$ENROLL_ADDR/v1/Lamassu-Default-DMS/form\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"url\\\":\\\"https://${DOMAIN}:5000\\\", \\\" subject\\\":{ \\\"common_name\\\": \\\"Lamassu-Default-DMS\\\",\\\"country\\\": \\\"\\\",\\\"locality\\\": \\\"\\\",\\\"organization\\\": \\\"\\\",\\\"organization_unit\\\": \\\"\\\",\\\"state\\\": \\\"\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 3072,\\\"type\\\": \\\"rsa\\\"}}\") echo $DMS_REGISTER_RESPONSE | jq -r .priv_key | sed 's/\\\\n/\\n/g' | sed -Ez '$ s/\\n+$//' | base64 -d > lamassu-default-dms/config/dms.key export DMS_ID=$(echo $DMS_REGISTER_RESPONSE | jq -r .dms.id) 3. Enroll the new DMS curl -k --location --request PUT \"https://$ENROLL_ADDR/v1/$DMS_ID\" --header \"Authorization: Bearer $TOKEN\" --header 'Content-Type: application/json' --data-raw '{\"status\": \"APPROVED\"}' 4. Get issued DMS Cert curl -k --location --request GET \"https://$ENROLL_ADDR/v1/$DMS _ID/crt\" --header \"Authorization: Bearer $TOKEN\" | base64 -d > lamassu-default-dms/config/dms.crt And finally, start the DMS \"server\": docker-compose rm -s -f dms-default docker-compose up -d dms-default","title":"Manual deployment"},{"location":"setup/#deploy-aws-iot-core-connectors","text":"","title":"Deploy AWS IoT Core connectors"},{"location":"setup/#requirements_1","text":"In order tu run the connector, you must have: NodeJS: https://nodejs.org/en/ AWS CDK v1: https://docs.aws.amazon.com/cdk/v1/guide/cli.html","title":"Requirements"},{"location":"setup/#deployment","text":"Download the AWS Connector source code: git clone https://github.com/lamassuiot/lamassu-aws-connector.git Configure the AWS Credentials. Those values will be used by the Lamassu AWS Connector as well as the CDK. export AWS_ACCESS_KEY_ID=<AWS_ACCESS_KEY_ID> export AWS_SECRET_ACCESS_KEY=<AWS_SECRET_ACCESS_KEY> export AWS_ACCOUNT_ID=<AWS_ACCOUNT_ID> export AWS_DEFAULT_REGION=<AWS_DEFAULT_REGION> Provide a friendly name for the Lamassu AWS Connector. This name will be displayed in the UI export CONNECTOR_NAME=Lamassu IoT AWS Account Substitute the aws-connector .env file: envsubst < .env | tee .env Generate the TLS certificates used by the connector. You must have access to the main CA certificate and private key that where generated during Lamassu installation. export INTERNAL_CA_CERT=<CHANGE_TO_LAMASSU_INSTALLATION_PATH>/tls-certificates/upstream/ca.crt export INTERNAL_CA_KEY=<CHANGE_TO_LAMASSU_INSTALLATION_PATH>/tls-certificates/upstream/ca.key After defining those variables, run the following OpenSSL commands: openssl genrsa -out aws.key 4096 openssl req -new -key aws-connector.key -out aws-connector.csr -subj \"/CN=aws-connector\" openssl x509 -req -extfile <(printf \"subjectAltName=DNS:aws-connector\") -in upstream/$1/tls.csr -days 365 -CA $INTERNAL_CA_CERT -CAkey $INTERNAL_CA_KEY -CAcreateserial -out aws.crt Deploy the required AWS services by using the CDK: cdk deploy Start the connector: docker-compose up -d","title":"Deployment"},{"location":"usage/","text":"Getting Started Before jumping any further, please check out the installation process to deploy all Lamassu services. This section will guide you through the basic functionalities provided by our PKI to start provisioning your devices. Overview Create a new Certification Authority The first step to provision your devices with digital certificates is to create the Certification Authority. The role of a CA is to issue and manage all the certificates. To create a new CA, fill the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs. Register a new Device Manufacturing System Lamassu is a PKI designed for the industrial and IoT sector. To better integrate this PKI in real life manufacturing system, Lamassu delegates the issuance of device certificate to the factory itself. First lets dive into the Device Manufacturing System (DMS for short) registration step by step. After that, a couple of examples will demonstrate how to start enrolling your devices using the Lamassu's Virtual DMS software as well as using the UI. Device manufacturing process tend to be highly automated. Provisioning the devices with digital identities should not slow down the fabrication process. Lamassu addresses this challenge introducing the DMS concept as core. One of the factories operators stars the process by generating a DMS registration request contained in a Certificate Signing Request also referred as CSR. This CSR is then sent to the DMS Enroller service to be approved by one of the PKI Administrators: The Administrator then decides if the request is approved or denied. If it decision is to approve the DMS registration request, the Administrator must specify which CAs will that particular DSM be entitled to issue certificates with: Once, and only if, the DMS registration request is approved, then the Operator must retrieve the signed CSR and pass it to the DMS software that will be in charge off requesting the issuance of new digital certificates for the manufactured devices: Finally, the DMS is able to request new x509 certificates for its manufactured devices. The DMS may be assisted by additional tools to obtain the manufactured device unique identifier. Note Envoy is used as an API gateway in this project. Currently Envoy is written to use Boring SSl as the TLS provider. It does not support secp224r1 signing method, which is used to create ECDSA224 keys. Therefore, enroll and reenroll methods will return a error when using this key. Let's register a new DMS instance: Operator - Authenticate the user: OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Operator - Request the registration for a new DMS instance: DMS_NAME=MyDMS DMS_SUBJECT_COUNTRY=ES DMS_SUBJECT_STATE=Gipuzkoa DMS_SUBJECT_LOCALITY=Donostia DMS_SUBJECT_ORGANIZATION=Lamassu DMS_SUBJECT_ORGANIZATION_UNIT=IoT DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsenroller/v1/$DMS_NAME/form\" \\ --header \"Authorization: Bearer $OPERATOR_TOKEN\" \\ --data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"org\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}}\") DMS_ID=$(echo $DMS_REG_RESPONSE | jq -r .dms.id) echo $DMS_REG_RESPONSE | jq -r .priv_key | base64 -d > dms.key Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Authorize the enrollment with all the provisioned CAs AUTHORIZED_CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .[].name | jq -s) curl -k --location --request PUT \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" \\ --header \"Authorization: Bearer $ENROLLER_TOKEN\" \\ --data-raw \"{\\\"authorized_cas\\\":$AUTHORIZED_CAS, \\\"status\\\":\\\"APPROVED\\\"}\" Operator - Get the DMS certificate: curl -k \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .crt | base64 -d > dms.crt Provision your devices with x509 Certificates The enrollment process is the way to go to obtain a certificate issued by one of the provisioned CAs. As described in the RFC document, Lamassu requires the authentication of the client requesting the enrollment using a certificate as well as the private key of an issued DMS to perform a mutual TLS connection. By using this type of TLS connection, the client is able to authenticate the server, and also, the server is able to authenticate the client. Although the /api/devmanager/.well-known/cacerts endpoint returns the list containing all the manged CAs by the PKI, each DMS is entitled to request the issuance of a certificate with an authorized CA. For instance, the PKI may have the following CAs: CA1 , CA2 , CA3 and CA4 . The /api/devmanager/.well-known/cacerts would return all four CAs. Then, a new DMS is registered. the PKI administrator approves the DMS registration by authorizing such DMS to issue certificates with CA1 and CA4 . This process is known as the DMS registration process . Once the DMS is completely registered, it can now start performing the EST enrollment process. Check out the previous section to understand what a DMS does. Let's first obtain the CA list for a particular DMS: First, authenticate and obtain a valid JWT OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Obtain the CA list: ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .authorized_cas) Select one of the entitled the CAs from the previous list: Note You can manually spefify the SELECTED_CA . Otherwise you can enroll the device with the first entitled CA using the following command. SELECTED_CA=$(echo $ENTITLED_CAS | jq .[0] -r) Generate the device CSR: DEVICE_ID=mytestdevice-123 openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" Enroll the device: DMS_CRT_PATH=path/to/dms_crt DMS_KEY_PATH=path/to/dms_key openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem curl https://$DOMAIN/api/devmanager/.well-known/est/$SELECTED_CA/simpleenroll --cert $DMS_CRT_PATH --key $DMS_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem --data-binary @device.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem openssl x509 -text -in device-cert.pem Using the UI The UI is an easy manageable tool designed to ease the burdens to non-technical users in using Lamassu PKI. This project was bootstrapped with Create React App . You can learn more in the Create React App documentation . Deployment This section has moved here: https://facebook.github.io/create-react-app/docs/deployment Create a new Certification Authority There are two methos of creating a new CA from the UI. The first one, filling the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs. The other one, will be importing it. A Certificate and a Private Key will be required. Registration of a DMS using the UI Using the UI, creating a new DMS is as simple as filling the following form. Once the DMS has been created successfully, a prompt showing the generated private key will be shown. It is encouraged to download it just after the creation as this prompt will be shown only once. The status of the new created DMS will be Pending Approval , to approve it, we must select at least one CA from the list of registered CAs. The selected CAs will be the authorised ones to sign certificates from now on. Registration of a device using the UI To create a device, we will need to fill the following form taking into account: A device identification must be provided. A DMS must be assigned. Each device can have certificates signed by different authorised CAs. The certificates of each device as well as the cloud-connectors will be showned. Using the APIs The main 3 Open API documentation can be found on the following urls: https://dev.lamassu.io/api/dmsenroller/v1/docs/ https://dev.lamassu.io/api/ca/v1/docs/ https://dev.lamassu.io/api/devmanager/v1/docs/ Note The following endpoints defined in the Lamassu Device Manager Api specification are not correctly defined due to the limitations imposed by the Open API 3.0 schema. The current specification defines an OIDC security schema (meaning that a valid JWT token must be provided while requesting the API) while the implemented security schema uses the mTLS approach. This issue will be resolved once the specification is migrated to Open API 3.1 compliant. The affected endpoints are: Lamassu provides easy to use GO clients for most of its APIs to help speeding up the development of third-party applications. Before using thees clients, it is important to identify the path taken by the request. Unless the application using the GO clients (or any other http client such as curl ) is deployed within the same docker network, the request will be handled by the API Gateway component . Otherwise check the internal usage section. Through the API Gateway Go Curl package main import ( \"net/url\" lamassuCAClient \"github.com/lamassuiot/lamassuiot/pkg/ca/client\" caDTO \"github.com/lamassuiot/lamassuiot/pkg/ca/common/dto\" \"github.com/lamassuiot/lamassuiot/pkg/utils/client\" ) function main (){ lamassuGatewayURL := \"dev.lamassu.io\" apiCAFile := \"path/to/apigw.crt\" caClient := lamassuCAClient . NewLamassuCAClient ( client . ClientConfiguration { URL : & url . URL { Scheme : \"https\" , Host : lamassuGatewayURL , Path : \"/api/ca/\" , }, AuthMethod : client . JWT , AuthMethodConfig : & client . JWTConfig { Username : \"enroller\" , Password : \"enroller\" , URL : & url . URL { Scheme : \"https\" , Host : \"auth.\" + lamassuGatewayURL , }, CACertificate : apiCAFile , }, CACertificate : apiCAFile , }) ca , err = caClient . CreateCA ( context . Background (), caDTO . Pki , caName , caDTO . PrivateKeyMetadata { KeyType : \"rsa\" , KeyBits : 2048 }, caDTO . Subject { CN : caName }, 365 * time . Hour , 30 * time . Hour ) } Define the DOMAIN, TOKEN and CA_NAME export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' | jq -r .access_token) export CA_ADDR=$DOMAIN/api/ca export CA_NAME=$(uuidgen) Creting CA export CREATE_CA_RESP=$(curl -k -s --location --request POST \"https://$CA_ADDR/v1/pki/$CA_NAME\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"ca_ttl\\\": 262800, \\\"enroller_ttl\\\": 175200, \\\"subject\\\":{ \\\"common_name\\\": \\\"$CA_NAME\\\",\\\"country\\\": \\\"ES\\\",\\\"locality\\\": \\\"Arrasate\\\",\\\"organization\\\": \\\"LKS Next, S. Coop\\\",\\\"state\\\": \\\"Gipuzkoa\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 4096,\\\"type\\\": \\\"RSA\\\"}}\") Running Unit tests #For pretty printing go install github.com/haveyoudebuggedit/gotestfmt/v2/cmd/gotestfmt@v2.3.1 go test -json -v ./pkg/ca/server/api/service/ | gotestfmt go test -json -v ./pkg/dms-enroller/server/api/service/ | gotestfmt go test -json -v ./pkg/device-manager/server/api/service/ | gotestfmt Filtering, Sorting and Pagination Lamassu API supports filtering, sorting and pagination. The filter can be form by the following parameters, being each of them optional: filter= attribute[operator]=value sort_by=attribute.[asc|desc] limit=value . Limits the maximun number of results of the query offset=value . In addition to limit , implements pagination. It defines the index of the first value from the resulting query. Example /v1/devices?filter=id[contains]=device_id&sort_by=id.asc&limit=100&offset=15 /v1?filter=id[contains]=dms_id&sort_by=id.desc Operators Depending of the data type of the parameters, the supported operators will vary. Strings : equals , notequals , contains , notcontains Dates: before , after , is , isnot Enums: is , isnot Numbers: lessthan , greaterthan , lessorequal , gretaerorequal , equal , notequal","title":"Getting Started"},{"location":"usage/#getting-started","text":"Before jumping any further, please check out the installation process to deploy all Lamassu services. This section will guide you through the basic functionalities provided by our PKI to start provisioning your devices.","title":"Getting Started"},{"location":"usage/#overview","text":"","title":"Overview"},{"location":"usage/#create-a-new-certification-authority","text":"The first step to provision your devices with digital certificates is to create the Certification Authority. The role of a CA is to issue and manage all the certificates. To create a new CA, fill the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs.","title":"Create a new Certification Authority"},{"location":"usage/#register-a-new-device-manufacturing-system","text":"Lamassu is a PKI designed for the industrial and IoT sector. To better integrate this PKI in real life manufacturing system, Lamassu delegates the issuance of device certificate to the factory itself. First lets dive into the Device Manufacturing System (DMS for short) registration step by step. After that, a couple of examples will demonstrate how to start enrolling your devices using the Lamassu's Virtual DMS software as well as using the UI. Device manufacturing process tend to be highly automated. Provisioning the devices with digital identities should not slow down the fabrication process. Lamassu addresses this challenge introducing the DMS concept as core. One of the factories operators stars the process by generating a DMS registration request contained in a Certificate Signing Request also referred as CSR. This CSR is then sent to the DMS Enroller service to be approved by one of the PKI Administrators: The Administrator then decides if the request is approved or denied. If it decision is to approve the DMS registration request, the Administrator must specify which CAs will that particular DSM be entitled to issue certificates with: Once, and only if, the DMS registration request is approved, then the Operator must retrieve the signed CSR and pass it to the DMS software that will be in charge off requesting the issuance of new digital certificates for the manufactured devices: Finally, the DMS is able to request new x509 certificates for its manufactured devices. The DMS may be assisted by additional tools to obtain the manufactured device unique identifier. Note Envoy is used as an API gateway in this project. Currently Envoy is written to use Boring SSl as the TLS provider. It does not support secp224r1 signing method, which is used to create ECDSA224 keys. Therefore, enroll and reenroll methods will return a error when using this key. Let's register a new DMS instance: Operator - Authenticate the user: OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Operator - Request the registration for a new DMS instance: DMS_NAME=MyDMS DMS_SUBJECT_COUNTRY=ES DMS_SUBJECT_STATE=Gipuzkoa DMS_SUBJECT_LOCALITY=Donostia DMS_SUBJECT_ORGANIZATION=Lamassu DMS_SUBJECT_ORGANIZATION_UNIT=IoT DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsenroller/v1/$DMS_NAME/form\" \\ --header \"Authorization: Bearer $OPERATOR_TOKEN\" \\ --data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"org\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}}\") DMS_ID=$(echo $DMS_REG_RESPONSE | jq -r .dms.id) echo $DMS_REG_RESPONSE | jq -r .priv_key | base64 -d > dms.key Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Authorize the enrollment with all the provisioned CAs AUTHORIZED_CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .[].name | jq -s) curl -k --location --request PUT \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" \\ --header \"Authorization: Bearer $ENROLLER_TOKEN\" \\ --data-raw \"{\\\"authorized_cas\\\":$AUTHORIZED_CAS, \\\"status\\\":\\\"APPROVED\\\"}\" Operator - Get the DMS certificate: curl -k \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .crt | base64 -d > dms.crt","title":"Register a new Device Manufacturing System"},{"location":"usage/#provision-your-devices-with-x509-certificates","text":"The enrollment process is the way to go to obtain a certificate issued by one of the provisioned CAs. As described in the RFC document, Lamassu requires the authentication of the client requesting the enrollment using a certificate as well as the private key of an issued DMS to perform a mutual TLS connection. By using this type of TLS connection, the client is able to authenticate the server, and also, the server is able to authenticate the client. Although the /api/devmanager/.well-known/cacerts endpoint returns the list containing all the manged CAs by the PKI, each DMS is entitled to request the issuance of a certificate with an authorized CA. For instance, the PKI may have the following CAs: CA1 , CA2 , CA3 and CA4 . The /api/devmanager/.well-known/cacerts would return all four CAs. Then, a new DMS is registered. the PKI administrator approves the DMS registration by authorizing such DMS to issue certificates with CA1 and CA4 . This process is known as the DMS registration process . Once the DMS is completely registered, it can now start performing the EST enrollment process. Check out the previous section to understand what a DMS does. Let's first obtain the CA list for a particular DMS: First, authenticate and obtain a valid JWT OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Obtain the CA list: ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .authorized_cas) Select one of the entitled the CAs from the previous list: Note You can manually spefify the SELECTED_CA . Otherwise you can enroll the device with the first entitled CA using the following command. SELECTED_CA=$(echo $ENTITLED_CAS | jq .[0] -r) Generate the device CSR: DEVICE_ID=mytestdevice-123 openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" Enroll the device: DMS_CRT_PATH=path/to/dms_crt DMS_KEY_PATH=path/to/dms_key openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem curl https://$DOMAIN/api/devmanager/.well-known/est/$SELECTED_CA/simpleenroll --cert $DMS_CRT_PATH --key $DMS_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem --data-binary @device.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem openssl x509 -text -in device-cert.pem","title":"Provision your devices with x509 Certificates"},{"location":"usage/#using-the-ui","text":"The UI is an easy manageable tool designed to ease the burdens to non-technical users in using Lamassu PKI. This project was bootstrapped with Create React App . You can learn more in the Create React App documentation .","title":"Using the UI"},{"location":"usage/#deployment","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/deployment","title":"Deployment"},{"location":"usage/#create-a-new-certification-authority_1","text":"There are two methos of creating a new CA from the UI. The first one, filling the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs. The other one, will be importing it. A Certificate and a Private Key will be required.","title":"Create a new Certification Authority"},{"location":"usage/#registration-of-a-dms-using-the-ui","text":"Using the UI, creating a new DMS is as simple as filling the following form. Once the DMS has been created successfully, a prompt showing the generated private key will be shown. It is encouraged to download it just after the creation as this prompt will be shown only once. The status of the new created DMS will be Pending Approval , to approve it, we must select at least one CA from the list of registered CAs. The selected CAs will be the authorised ones to sign certificates from now on.","title":"Registration of a DMS using the UI"},{"location":"usage/#registration-of-a-device-using-the-ui","text":"To create a device, we will need to fill the following form taking into account: A device identification must be provided. A DMS must be assigned. Each device can have certificates signed by different authorised CAs. The certificates of each device as well as the cloud-connectors will be showned.","title":"Registration of a device using the UI"},{"location":"usage/#using-the-apis","text":"The main 3 Open API documentation can be found on the following urls: https://dev.lamassu.io/api/dmsenroller/v1/docs/ https://dev.lamassu.io/api/ca/v1/docs/ https://dev.lamassu.io/api/devmanager/v1/docs/ Note The following endpoints defined in the Lamassu Device Manager Api specification are not correctly defined due to the limitations imposed by the Open API 3.0 schema. The current specification defines an OIDC security schema (meaning that a valid JWT token must be provided while requesting the API) while the implemented security schema uses the mTLS approach. This issue will be resolved once the specification is migrated to Open API 3.1 compliant. The affected endpoints are: Lamassu provides easy to use GO clients for most of its APIs to help speeding up the development of third-party applications. Before using thees clients, it is important to identify the path taken by the request. Unless the application using the GO clients (or any other http client such as curl ) is deployed within the same docker network, the request will be handled by the API Gateway component . Otherwise check the internal usage section.","title":"Using the APIs"},{"location":"usage/#through-the-api-gateway","text":"Go Curl package main import ( \"net/url\" lamassuCAClient \"github.com/lamassuiot/lamassuiot/pkg/ca/client\" caDTO \"github.com/lamassuiot/lamassuiot/pkg/ca/common/dto\" \"github.com/lamassuiot/lamassuiot/pkg/utils/client\" ) function main (){ lamassuGatewayURL := \"dev.lamassu.io\" apiCAFile := \"path/to/apigw.crt\" caClient := lamassuCAClient . NewLamassuCAClient ( client . ClientConfiguration { URL : & url . URL { Scheme : \"https\" , Host : lamassuGatewayURL , Path : \"/api/ca/\" , }, AuthMethod : client . JWT , AuthMethodConfig : & client . JWTConfig { Username : \"enroller\" , Password : \"enroller\" , URL : & url . URL { Scheme : \"https\" , Host : \"auth.\" + lamassuGatewayURL , }, CACertificate : apiCAFile , }, CACertificate : apiCAFile , }) ca , err = caClient . CreateCA ( context . Background (), caDTO . Pki , caName , caDTO . PrivateKeyMetadata { KeyType : \"rsa\" , KeyBits : 2048 }, caDTO . Subject { CN : caName }, 365 * time . Hour , 30 * time . Hour ) } Define the DOMAIN, TOKEN and CA_NAME export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' | jq -r .access_token) export CA_ADDR=$DOMAIN/api/ca export CA_NAME=$(uuidgen) Creting CA export CREATE_CA_RESP=$(curl -k -s --location --request POST \"https://$CA_ADDR/v1/pki/$CA_NAME\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"ca_ttl\\\": 262800, \\\"enroller_ttl\\\": 175200, \\\"subject\\\":{ \\\"common_name\\\": \\\"$CA_NAME\\\",\\\"country\\\": \\\"ES\\\",\\\"locality\\\": \\\"Arrasate\\\",\\\"organization\\\": \\\"LKS Next, S. Coop\\\",\\\"state\\\": \\\"Gipuzkoa\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 4096,\\\"type\\\": \\\"RSA\\\"}}\")","title":"Through the API Gateway"},{"location":"usage/#running-unit-tests","text":"#For pretty printing go install github.com/haveyoudebuggedit/gotestfmt/v2/cmd/gotestfmt@v2.3.1 go test -json -v ./pkg/ca/server/api/service/ | gotestfmt go test -json -v ./pkg/dms-enroller/server/api/service/ | gotestfmt go test -json -v ./pkg/device-manager/server/api/service/ | gotestfmt","title":"Running Unit tests"},{"location":"usage/#filtering-sorting-and-pagination","text":"Lamassu API supports filtering, sorting and pagination. The filter can be form by the following parameters, being each of them optional: filter= attribute[operator]=value sort_by=attribute.[asc|desc] limit=value . Limits the maximun number of results of the query offset=value . In addition to limit , implements pagination. It defines the index of the first value from the resulting query. Example /v1/devices?filter=id[contains]=device_id&sort_by=id.asc&limit=100&offset=15 /v1?filter=id[contains]=dms_id&sort_by=id.desc","title":"Filtering, Sorting and Pagination"},{"location":"usage/#operators","text":"Depending of the data type of the parameters, the supported operators will vary. Strings : equals , notequals , contains , notcontains Dates: before , after , is , isnot Enums: is , isnot Numbers: lessthan , greaterthan , lessorequal , gretaerorequal , equal , notequal","title":"Operators"},{"location":"virtualDMS/","text":"Lamassu Virtual DMS To launch Lamassu-Virtual-DMS follow the next steps: Clone the repository and get into the directory: https://github.com/lamassuiot/lamassu-virtual-dms.git && cd lamassu-virtual-dms . Change the configuration variables of the config.json file. { \"dms\": { \"device_store\": \"<DEVICES_STORE>\", // Folder where device certificates are stored \"dms_store\": \"<DMS_STORE>\", // Folder where DMS certificates are stored \"endpoint\":\"<DMS_SERVER>\", // DMS server endpoint \"dms_name\":\"<DEFAULT_DMS>\", // DMS Name \"common_name\":\"<DEFAULT_DMS>\", // Common_name to create the CSR \"country\":\"<COUNTRY>\", // Country to create the CSR \"locality\":\"<LOCALITY>\", // Locality to create the CSR \"organization\":\"<ORGANIZATION>\", // Organization to create the CSR \"organization_unit\":\"<ORGANIZATION_UNIT>\", // Organization_unit to create the CSR \"state\":\"<STATE>\" // State to create the CSR }, \"devmanager\":{ \"devcrt\": \"<DEV_CERTIFICATE>\", // Public certificate to connect to the device-manager \"addr\": \"<DEVMANAGER_SERVER>\" //Device Manager Server Endpoint }, \"auth\":{ \"endpoint\":\"<AUTH_SERVER>\", // Authentication Server endpoint \"username\":\"<PASSWORD>\", // User name to connect to the authentication server \"password\":\"<PASSWORD>\" // Password to connect to the authentication server } } 3. Create directories to store DMS and device certificates mkdir -p /home/$USER/virtual-dms-data/devices_certificates mkdir -p /home/$USER/virtual-dms-data/dms_certificates 4. config.json file with default values { \"dms\": { \"device_store\": \"/home/$USER/virtual-dms-data/devices_certificates\", \"dms_store\": \"/home/$USER/virtual-dms-data/dms_certificates\", \"endpoint\":\"dev.lamassu.io/api/dmsenroller\", \"dms_name\":\"Virtual DMS\", \"common_name\":\"Virtual DMS\", \"country\":\"ES\", \"locality\":\"Mondragon\", \"organization\":\"LKS\", \"organization_unit\":\"LKS PKI\", \"state\":\"Guipuzcoa\" }, \"devmanager\":{ \"devcrt\": \"<DEV_CERTIFICATE>\", \"addr\": \"dev.lamassu.io/api/devmanager\" }, \"auth\":{ \"endpoint\":\"auth.dev.lamassu.io\", \"username\":\"enroller\", \"password\":\"enroller\" } } 5. Run the Lamassu-Default-DMS UI: go run cmd/main.go Lamassu Virtual DMS operating modes The virtual DMS has two modes of operation, on the one hand, there is the mode of creating a DMS and once the DMS is created and approved, the devices are automatically enrolled using the DMS. On the other hand, if a DMS has already been created and approved, devices can be directly enrolled without having to create a DMS. In the second case it is necessary to make sure that the certificate and the DMS key are in the directory where the DMS certificates are stored. If the Virtual-DMS is not used to create the DMS, in the directory where the certificates are stored, the certificates and keys must be created with the following format: \u251c\u2500\u2500 devices_certificates \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 dms_certificates \u251c\u2500\u2500 dms-<DMS_ID>.crt <----- Provide your certificate \u2514\u2500\u2500 dms-<DMS_ID>.key <----- Provide your private key Create the DMS, once the DMS is created, the Auto_Enroll of the devices is done. 2. Make the Auto_Enroll of the devices indicating the ID of a DMS.","title":"Lamassu Virtual DMS"},{"location":"virtualDMS/#lamassu-virtual-dms","text":"To launch Lamassu-Virtual-DMS follow the next steps: Clone the repository and get into the directory: https://github.com/lamassuiot/lamassu-virtual-dms.git && cd lamassu-virtual-dms . Change the configuration variables of the config.json file. { \"dms\": { \"device_store\": \"<DEVICES_STORE>\", // Folder where device certificates are stored \"dms_store\": \"<DMS_STORE>\", // Folder where DMS certificates are stored \"endpoint\":\"<DMS_SERVER>\", // DMS server endpoint \"dms_name\":\"<DEFAULT_DMS>\", // DMS Name \"common_name\":\"<DEFAULT_DMS>\", // Common_name to create the CSR \"country\":\"<COUNTRY>\", // Country to create the CSR \"locality\":\"<LOCALITY>\", // Locality to create the CSR \"organization\":\"<ORGANIZATION>\", // Organization to create the CSR \"organization_unit\":\"<ORGANIZATION_UNIT>\", // Organization_unit to create the CSR \"state\":\"<STATE>\" // State to create the CSR }, \"devmanager\":{ \"devcrt\": \"<DEV_CERTIFICATE>\", // Public certificate to connect to the device-manager \"addr\": \"<DEVMANAGER_SERVER>\" //Device Manager Server Endpoint }, \"auth\":{ \"endpoint\":\"<AUTH_SERVER>\", // Authentication Server endpoint \"username\":\"<PASSWORD>\", // User name to connect to the authentication server \"password\":\"<PASSWORD>\" // Password to connect to the authentication server } } 3. Create directories to store DMS and device certificates mkdir -p /home/$USER/virtual-dms-data/devices_certificates mkdir -p /home/$USER/virtual-dms-data/dms_certificates 4. config.json file with default values { \"dms\": { \"device_store\": \"/home/$USER/virtual-dms-data/devices_certificates\", \"dms_store\": \"/home/$USER/virtual-dms-data/dms_certificates\", \"endpoint\":\"dev.lamassu.io/api/dmsenroller\", \"dms_name\":\"Virtual DMS\", \"common_name\":\"Virtual DMS\", \"country\":\"ES\", \"locality\":\"Mondragon\", \"organization\":\"LKS\", \"organization_unit\":\"LKS PKI\", \"state\":\"Guipuzcoa\" }, \"devmanager\":{ \"devcrt\": \"<DEV_CERTIFICATE>\", \"addr\": \"dev.lamassu.io/api/devmanager\" }, \"auth\":{ \"endpoint\":\"auth.dev.lamassu.io\", \"username\":\"enroller\", \"password\":\"enroller\" } } 5. Run the Lamassu-Default-DMS UI: go run cmd/main.go","title":"Lamassu Virtual DMS"},{"location":"virtualDMS/#lamassu-virtual-dms-operating-modes","text":"The virtual DMS has two modes of operation, on the one hand, there is the mode of creating a DMS and once the DMS is created and approved, the devices are automatically enrolled using the DMS. On the other hand, if a DMS has already been created and approved, devices can be directly enrolled without having to create a DMS. In the second case it is necessary to make sure that the certificate and the DMS key are in the directory where the DMS certificates are stored. If the Virtual-DMS is not used to create the DMS, in the directory where the certificates are stored, the certificates and keys must be created with the following format: \u251c\u2500\u2500 devices_certificates \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 dms_certificates \u251c\u2500\u2500 dms-<DMS_ID>.crt <----- Provide your certificate \u2514\u2500\u2500 dms-<DMS_ID>.key <----- Provide your private key Create the DMS, once the DMS is created, the Auto_Enroll of the devices is done. 2. Make the Auto_Enroll of the devices indicating the ID of a DMS.","title":"Lamassu Virtual DMS operating modes"},{"location":"virtualDevice/","text":"Lamassu Virtual Device To launch Lamassu-Virtual-Device follow the next steps: Clone the repository and get into the directory: https://github.com/lamassuiot/lamassu-virtual-device.git && cd lamassu-virtual-device . Change the configuration variables of the config.json file. { \"certificates_dir\": \"<DEVICES_CERTIFICATES>\", // Folder where device certificates are stored \"devmanager\": { \"est_server\": \"<DEVICE_MANAGER_SERVER>\", // Device Manager Server Endpoint \"cert\":\"<DEVMANAGER_CERT>\" // Public certificate to connect to the device-manager }, \"aws\":{ \"iot_core_ca_file\": \"<AWS_CA_CERT>\", // AWS IoT Core CA Certificate \"iot_core_endpoint\": \"<AWS_ENDPOINT>\", // AWS IoT Core endpoint \"test_lambda\": \"<LAMBDA>\" // Lambda name } } 3. config.json file with default values { \"certificates_dir\": \"/home/$USER/virtual-dms-data/devices_certificates\", \"devmanager\": { \"est_server\": \"dev.lamassu.io/api/devmanager\", \"cert\":\"<DEVMANAGER_CERT>\" }, \"aws\":{ \"iot_core_ca_file\": \"<AWS_CA_CERT>\", \"iot_core_endpoint\": \"<AWS_ENDPOINT>\", \"test_lambda\": \"<LAMBDA>\" } } In case of not using the Virtual-DMS to register the devices, in the directory where the certificates are stored the certificates and keys must be created with the following format: \u251c\u2500\u2500 devices_certificates \u2502 \u251c\u2500\u2500 device-<DMS_NAME>-<DEVICE_ID> \u2502 \u2502 \u251c\u2500\u2500 certificates \u2502 \u2502 \u2502 \u251c\u2500\u2500 <CERT_SN>.crt <----- Provide your Device certificate \u2502 \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2502 \u251c\u2500\u2500 <DEVICE_ID>.csr <----- Provide your Device certificate request \u2502 \u2502 \u2514\u2500\u2500 <DEVICE_ID>.key <----- Provide your Device private key \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 dms_certificates \u251c\u2500\u2500 dms-<DMS_ID>.crt <----- Provide your DMS certificate \u2514\u2500\u2500 dms-<DMS_ID>.key <----- Provide your DMS private key 4. Run the Lamassu-Virtua-Device UI: go run cmd/main.go Lamassu Virtual device pages Lamassu Virtual Device has the following pages: Device Information View: a page showing each device's information. Choose from the dropdown the DeviceId and the Serial Number of the Certificateof to visualize the details. AWS Integration: a page to check AWS connectivity Reenroll: each device has the option to reenroll","title":"Lamassu Virtual Device"},{"location":"virtualDevice/#lamassu-virtual-device","text":"To launch Lamassu-Virtual-Device follow the next steps: Clone the repository and get into the directory: https://github.com/lamassuiot/lamassu-virtual-device.git && cd lamassu-virtual-device . Change the configuration variables of the config.json file. { \"certificates_dir\": \"<DEVICES_CERTIFICATES>\", // Folder where device certificates are stored \"devmanager\": { \"est_server\": \"<DEVICE_MANAGER_SERVER>\", // Device Manager Server Endpoint \"cert\":\"<DEVMANAGER_CERT>\" // Public certificate to connect to the device-manager }, \"aws\":{ \"iot_core_ca_file\": \"<AWS_CA_CERT>\", // AWS IoT Core CA Certificate \"iot_core_endpoint\": \"<AWS_ENDPOINT>\", // AWS IoT Core endpoint \"test_lambda\": \"<LAMBDA>\" // Lambda name } } 3. config.json file with default values { \"certificates_dir\": \"/home/$USER/virtual-dms-data/devices_certificates\", \"devmanager\": { \"est_server\": \"dev.lamassu.io/api/devmanager\", \"cert\":\"<DEVMANAGER_CERT>\" }, \"aws\":{ \"iot_core_ca_file\": \"<AWS_CA_CERT>\", \"iot_core_endpoint\": \"<AWS_ENDPOINT>\", \"test_lambda\": \"<LAMBDA>\" } } In case of not using the Virtual-DMS to register the devices, in the directory where the certificates are stored the certificates and keys must be created with the following format: \u251c\u2500\u2500 devices_certificates \u2502 \u251c\u2500\u2500 device-<DMS_NAME>-<DEVICE_ID> \u2502 \u2502 \u251c\u2500\u2500 certificates \u2502 \u2502 \u2502 \u251c\u2500\u2500 <CERT_SN>.crt <----- Provide your Device certificate \u2502 \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2502 \u251c\u2500\u2500 <DEVICE_ID>.csr <----- Provide your Device certificate request \u2502 \u2502 \u2514\u2500\u2500 <DEVICE_ID>.key <----- Provide your Device private key \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 dms_certificates \u251c\u2500\u2500 dms-<DMS_ID>.crt <----- Provide your DMS certificate \u2514\u2500\u2500 dms-<DMS_ID>.key <----- Provide your DMS private key 4. Run the Lamassu-Virtua-Device UI: go run cmd/main.go","title":"Lamassu Virtual Device"},{"location":"virtualDevice/#lamassu-virtual-device-pages","text":"Lamassu Virtual Device has the following pages: Device Information View: a page showing each device's information. Choose from the dropdown the DeviceId and the Serial Number of the Certificateof to visualize the details. AWS Integration: a page to check AWS connectivity Reenroll: each device has the option to reenroll","title":"Lamassu Virtual device pages"}]}