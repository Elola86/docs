{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Lamassu Iot Docs Lamassu is an IoT first PKI designed for industrial scenarios. Public key infrastructure are systems in charge of creating, storing and distributing digital certificates which are used to verify that a particular public key belongs to a certain entity. PKIs creates digital certificates which map to public keys to entities, securely stores these certificates in a central repository and revokes them if needed.","title":"Welcome to Lamassu Iot Docs"},{"location":"#welcome-to-lamassu-iot-docs","text":"Lamassu is an IoT first PKI designed for industrial scenarios. Public key infrastructure are systems in charge of creating, storing and distributing digital certificates which are used to verify that a particular public key belongs to a certain entity. PKIs creates digital certificates which map to public keys to entities, securely stores these certificates in a central repository and revokes them if needed.","title":"Welcome to Lamassu Iot Docs"},{"location":"manage/","text":"Managing Lamassu Certificate rotation By default, all self-signed certificates (both upstream and downstream) have a lifespan of 365 days. At that point it will be necessary to regenerate the expired certificates: Regenerate the certificates: cd tls-certificates ./gen-upstream-certs.sh ./gen-downstream-certs.sh cd .. Reboot all services: docker-compose down docker-compose up -d Backup strategy Restoring backups","title":"Managing Lamassu"},{"location":"manage/#managing-lamassu","text":"","title":"Managing Lamassu"},{"location":"manage/#certificate-rotation","text":"By default, all self-signed certificates (both upstream and downstream) have a lifespan of 365 days. At that point it will be necessary to regenerate the expired certificates: Regenerate the certificates: cd tls-certificates ./gen-upstream-certs.sh ./gen-downstream-certs.sh cd .. Reboot all services: docker-compose down docker-compose up -d","title":"Certificate rotation"},{"location":"manage/#backup-strategy","text":"","title":"Backup strategy"},{"location":"manage/#restoring-backups","text":"","title":"Restoring backups"},{"location":"protocols/","text":"Protocols Lamassu supports a set of standards to perform some of its key functionalities such as enrolling devices as well as validating the status of a given certificate. This section aims to describe those protocols as well as explaining how them with practical examples. OCSP The Online Certificate Status Protocol or OCSP for short, is a protocol used to determine the current status of a digital certificate without requiring the use of Certificate Revocation Lists (CRLs). As defined by the standard, there are two possible methods that can be used to perform the http request: Method Path Headers Body payload Used when GET {url}/{url-encoding of base-64 encoding of the DER encoding of the OCSPRequest} Recommended when the encoded request is less than 255 bytes PUT {url} Content-Type: application/ocsp-request Binary value of the DER encoding of the OCSPRequest Can always be used GET Request OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request OCSP_REQUEST=$(openssl ocsp -CAfile $CA_CERTIFICATE -issuer $CA_CERTIFICATE -cert $DEVICE_CERTIFICATE -reqout - | base64 -w 0) Check the status of the certificate curl --location --request GET \"$OCSP_SERVER/api/ocsp/$OCSP_REQUEST\" > ocspresponse.der openssl ocsp -respin ocspresponse.der -VAfile root-ca.pem -resp_text package main import ( \"crypto/x509\" \"encoding/base64\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } encodedRequest := base64 . StdEncoding . EncodeToString ( ocspRequestBytes ) fmt . Println ( encodedRequest ) reqURL := ocspServer + \"/\" + encodedRequest resp , err := http . Get ( reqURL ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) } POST Request EST CA Certificates GlobalSign Go Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates estclient cacerts -server $DOMAIN/api/devmanager -explicit root-ca.pem -out cacerts.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" clientcrt := \"dms.crt\" clientkey := \"dms.key\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( clientcrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( clientkey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cas , err := estClient . CACerts ( context . Background ()) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } } https://datatracker.ietf.org/doc/html/rfc7030","title":"Protocols"},{"location":"protocols/#protocols","text":"Lamassu supports a set of standards to perform some of its key functionalities such as enrolling devices as well as validating the status of a given certificate. This section aims to describe those protocols as well as explaining how them with practical examples.","title":"Protocols"},{"location":"protocols/#ocsp","text":"The Online Certificate Status Protocol or OCSP for short, is a protocol used to determine the current status of a digital certificate without requiring the use of Certificate Revocation Lists (CRLs). As defined by the standard, there are two possible methods that can be used to perform the http request: Method Path Headers Body payload Used when GET {url}/{url-encoding of base-64 encoding of the DER encoding of the OCSPRequest} Recommended when the encoded request is less than 255 bytes PUT {url} Content-Type: application/ocsp-request Binary value of the DER encoding of the OCSPRequest Can always be used","title":"OCSP"},{"location":"protocols/#get-request","text":"OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request OCSP_REQUEST=$(openssl ocsp -CAfile $CA_CERTIFICATE -issuer $CA_CERTIFICATE -cert $DEVICE_CERTIFICATE -reqout - | base64 -w 0) Check the status of the certificate curl --location --request GET \"$OCSP_SERVER/api/ocsp/$OCSP_REQUEST\" > ocspresponse.der openssl ocsp -respin ocspresponse.der -VAfile root-ca.pem -resp_text package main import ( \"crypto/x509\" \"encoding/base64\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } encodedRequest := base64 . StdEncoding . EncodeToString ( ocspRequestBytes ) fmt . Println ( encodedRequest ) reqURL := ocspServer + \"/\" + encodedRequest resp , err := http . Get ( reqURL ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) }","title":"GET Request"},{"location":"protocols/#post-request","text":"","title":"POST Request"},{"location":"protocols/#est","text":"","title":"EST"},{"location":"protocols/#ca-certificates","text":"GlobalSign Go Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates estclient cacerts -server $DOMAIN/api/devmanager -explicit root-ca.pem -out cacerts.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" clientcrt := \"dms.crt\" clientkey := \"dms.key\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( clientcrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( clientkey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cas , err := estClient . CACerts ( context . Background ()) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } } https://datatracker.ietf.org/doc/html/rfc7030","title":"CA Certificates"},{"location":"setup/","text":"Install Lamassu Compose Lamassu Compose is the official release containing the scripts and resources required to deploy all microservices such as the CA component, the VA component or the RA components to name a few. Architecture Lamassu Compose offers a SECURE deployment of the set of microservices required to manage an industrial PKI. The architecture presented on the following image reflects the interconnection of the different services mainly using the HTTP Protocol. The use of this deployment offers the following non functional requirements by leveraging the use of an API Gateway: Centralized point of access : Each microservice listens on a different port which ends up being challenging for developers and users. With the use of the API Gateway, the user will always access the same host and port address. Port 80 for HTTP connections and port 443 for HTTPS connections. Authentication : In order to invoke any endpoint, the API Gateway enforces each request to present a JWT. Upon receiving an HTTP request, the gateway validates the presented token against the authentication server. Authorization : Another key aspect is enforcing an authorization schema. Lamassu has been configured in such way that only specific endpoints are accessible by non admin users. Tracing : Logging the life of an HTTP request can be helpful during the debugging process of such complex application. The tracing aspect eases this process by injecting a unique identifier to each request that is then printed out by each microservice logs. Mutual TLS authentication : As mentioned earlier the gateway acts as the traffic orchestrator knowing where each service is and redirecting the traffic accordingly. To prevent any unauthorized request as well as protecting the communications channel between the Gateway itself and the upstream service, the API Gateway initiates a mutual TLS connection to ensure such thing. Requirements jq . Get the latest version: https://stedolan.github.io/jq/download/ docker and docker-compose : Get the latest version: https://docs.docker.com/engine/install/ubuntu/ and https://docs.docker.com/compose/install/ Have a working DNS server able to resolve the domain used during the installation process or add the following content to the /etc/hosts file, replacing the dev.lamassu.io domain with your own: 127.0.0.1 dev.lamassu.io 127.0.0.1 vault.dev.lamassu.io 127.0.0.1 auth.dev.lamassu.io 127.0.0.1 tracing.dev.lamassu.io 127.0.0.1 consul.dev.lamassu.io Setup Automatic deployment Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the next secret environment variables by exporting the following variables. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by exporting the DOMAIN variable. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env Run the installer: bash install.sh OPTIONAL : Import your certificates: The install.sh script also generates self-signed for the downstream certificates. It is possible to provide other valid certificates by replacing the following files: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt <----- Provide your certificate \u2514\u2500\u2500 tls.key <----- Provide your private key Once you replace this certificates, restart the api-gateway to obtain the imported certificates: docker-compose rm -s -f api-gateway dms-default docker-compose up -d api-gateway dms-default Final notes: \ud83d\ude80 You are ready to go \ud83d\ude80 Note Keycloak is your auth provider. During the install.sh the service is provisioned with 2 users with different roles: Username: enroller Password: enroller Role: admin Username: operator Password: operator Role: operator You can change those credentials (or create new users) using keycloak's UI available at: https://auth.<DOMAIN> Manual deployment To launch Lamassu follow the next steps: Set up your environment: Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the DB credentials variables used by the .env file. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by the .env file. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env The Gateway and TLS Certificates Lamassu uses a Gateway to expose all the deployed services. Moreover, the gateway is in charge of performing the following tasks: - Routing traffic to services - Enforcing authentication policies - Enforcing authorization policies - Logging & tracing - Healthchecking - Securely expose services using TLS The different APIs exposed through the gateway have been configured to ONLY accept request originates inside the platform via a mTLS authentication: Generate the upstream certificates. cd tls-certificates ./gen-upstream-certs.sh There are 2 options for the downstream certificate: Import an existing certificate : If you have valid certificates for your domain, you can use them by placing them under the downstream folder. The end result should be: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt \u2514\u2500\u2500 tls.key Generate a Self Signed certificate : If you need to create a new self-signed certificate, run the following command: ./gen-downstream-certs.sh Authentication service configuration: Run Keycloak: docker-compose up -d auth Keycloak image is configured with a Realm, a client and two different roles: admin and operator . Create a user with admin role to perform Enroller administrator tasks. (The command below creates a user named enroller with enroller as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u enroller -p enroller --roles admin Create a user with operator role to perform Device Manufacturing System tasks. This Device Manufacturing System must associate its CSR with this user matching the CN attribute and the username.(The command below creates a user named operator with operator as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u operator -p operator --roles operator Reload keyclok server docker-compose exec auth /opt/jboss/keycloak/bin/jboss-cli.sh --connect command=:reload If Keycloak display the following output, keycloak has successfully reloaded. Otherwise, run the command again until you see the expected output: { \"outcome\" => \"success\", \"result\" => undefined } Provision and configure Vault and Lamassu CA: Run Vault: docker-compose up -d vault consul-server api-gateway Initialize vault: This process generates vault's unseal keys as well as the root token: docker-compose exec vault vault operator init -key-shares=5 -key-threshold=3 -tls-skip-verify -format=json > vault-credentials.json Verify the vault-credentials.json file has the expected content. It should be similar to this: { \"unseal_keys_b64\": [ \"Hfx46iMq/PXoBPhDZ0EAMM9MDWS8GTCANFbAkzVEzFOD\", \"lfo48PHGFGHmpaFn6Z6rWTXTXVS53m9duxsvwVjRDc2L\", \"dcVw6N81i+/pY34WTHQYkV848to7jNeVkgdJOtgxnRkS\", \"Aut6oL7+GomXCrrTH0FCKhJwAs2PrWFYSnWpgjLfwsH0\", \"pprFM0HJEUR4m3kaIT5sga87aJ4AjXi32KVn6dgfivii\" ], \"unseal_keys_hex\": [ \"1dfc78ea232afcf5e804f84367410030cf4c0d64bc1930803456c0933544cc5383\", \"95fa38f0f1c61461e6a5a167e99eab5935d35d54b9de6f5dbb1b2fc158d10dcd8b\", \"75c570e8df358befe9637e164c7418915f38f2da3b8cd7959207493ad8319d1912\", \"02eb7aa0befe1a89970abad31f41422a127002cd8fad61584a75a98232dfc2c1f4\", \"a69ac53341c91144789b791a213e6c81af3b689e008d78b7d8a567e9d81f8af8a2\" ], \"unseal_shares\": 5, \"unseal_threshold\": 3, \"recovery_keys_b64\": [], \"recovery_keys_hex\": [], \"recovery_keys_shares\": 5, \"recovery_keys_threshold\": 3, \"root_token\": \"s.80Mpm0OmxlXzoSxZB2MMPcNu\" } Export the following variables: export VAULT_TOKEN=$(cat vault-credentials.json | jq .root_token -r) export VAULT_ADDR=https://vault.$DOMAIN Unseal Vault using the keys obtained with the previous command: curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[0])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[1])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[2])\\\" }\" Vault must be provisioned with some resources (authentication methods, policies and secret engines). That can be achieved by running the ca-provision.sh script. Vault will be provisioned with 4 Root CAs, 1 Special CA (Lamassu-DMS-Enroller) AppRole authentication method and one role and policy for each service or container that needs to exchange data with it. cd config/vault/provision/ ./provisioner.sh cd ../../../ Get RoleID and SecretID for each service and set those values in the empty fields of the .docker-compose.yml file. export CA_VAULT_ROLEID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/role-id | jq -r .data.role_id ) export CA_VAULT_SECRETID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" --request POST ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/secret-id | jq -r .data.secret_id) # Set RoleID and SecretID in docker-compose.yml file sed -i 's/<LAMASSU_CA_VAULT_ROLE_ID>/'$CA_VAULT_ROLEID'/g' docker-compose.yml sed -i 's/<LAMASSU_CA_VAULT_SECRET_ID>/'$CA_VAULT_SECRETID'/g' docker-compose.yml Configure the Device Manager: The Device Manage has a configurable variable that determines when a device can renew (also known as reenroll) its certificate. By default the reenrollment process can only be done 30 days prior to the cert's expiration time. This value can be changed by modifying the DEVICE_MANAGER_MINIMUM_REENROLL_DAYS variable located in the .env file. Start the remaining services: docker-compose up -d Configure the Default DMS First, authenticate against Keycloak: export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' |jq -r .access_token) Then, register a new DMS named Lamassu-Default-DMS: Note while registering new DMS instances with non admin users, it is necessary to register the DMS using the user's username as the common name, otherwise, the user won't see its DMSs export ENROLL_ADDR=$DOMAIN/api/dmsenroller export DMS_REGISTER_RESPONSE=$(curl -k --location --request POST \"https://$ENROLL_ADDR/v1/Lamassu-Default-DMS/form\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"url\\\":\\\"https://${DOMAIN}:5000\\\", \\\" subject\\\":{ \\\"common_name\\\": \\\"Lamassu-Default-DMS\\\",\\\"country\\\": \\\"\\\",\\\"locality\\\": \\\"\\\",\\\"organization\\\": \\\"\\\",\\\"organization_unit\\\": \\\"\\\",\\\"state\\\": \\\"\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 3072,\\\"type\\\": \\\"rsa\\\"}}\") echo $DMS_REGISTER_RESPONSE | jq -r .priv_key | sed 's/\\\\n/\\n/g' | sed -Ez '$ s/\\n+$//' | base64 -d > lamassu-default-dms/config/dms.key export DMS_ID=$(echo $DMS_REGISTER_RESPONSE | jq -r .dms.id) 3. Enroll the new DMS curl -k --location --request PUT \"https://$ENROLL_ADDR/v1/$DMS_ID\" --header \"Authorization: Bearer $TOKEN\" --header 'Content-Type: application/json' --data-raw '{\"status\": \"APPROVED\"}' 4. Get issued DMS Cert curl -k --location --request GET \"https://$ENROLL_ADDR/v1/$DMS _ID/crt\" --header \"Authorization: Bearer $TOKEN\" | base64 -d > lamassu-default-dms/config/dms.crt And finally, start the DMS \"server\": docker-compose rm -s -f dms-default docker-compose up -d dms-default Deploy AWS and Azure PKI connectors","title":"Install Lamassu Compose"},{"location":"setup/#install-lamassu-compose","text":"Lamassu Compose is the official release containing the scripts and resources required to deploy all microservices such as the CA component, the VA component or the RA components to name a few.","title":"Install Lamassu Compose"},{"location":"setup/#architecture","text":"Lamassu Compose offers a SECURE deployment of the set of microservices required to manage an industrial PKI. The architecture presented on the following image reflects the interconnection of the different services mainly using the HTTP Protocol. The use of this deployment offers the following non functional requirements by leveraging the use of an API Gateway: Centralized point of access : Each microservice listens on a different port which ends up being challenging for developers and users. With the use of the API Gateway, the user will always access the same host and port address. Port 80 for HTTP connections and port 443 for HTTPS connections. Authentication : In order to invoke any endpoint, the API Gateway enforces each request to present a JWT. Upon receiving an HTTP request, the gateway validates the presented token against the authentication server. Authorization : Another key aspect is enforcing an authorization schema. Lamassu has been configured in such way that only specific endpoints are accessible by non admin users. Tracing : Logging the life of an HTTP request can be helpful during the debugging process of such complex application. The tracing aspect eases this process by injecting a unique identifier to each request that is then printed out by each microservice logs. Mutual TLS authentication : As mentioned earlier the gateway acts as the traffic orchestrator knowing where each service is and redirecting the traffic accordingly. To prevent any unauthorized request as well as protecting the communications channel between the Gateway itself and the upstream service, the API Gateway initiates a mutual TLS connection to ensure such thing.","title":"Architecture"},{"location":"setup/#requirements","text":"jq . Get the latest version: https://stedolan.github.io/jq/download/ docker and docker-compose : Get the latest version: https://docs.docker.com/engine/install/ubuntu/ and https://docs.docker.com/compose/install/ Have a working DNS server able to resolve the domain used during the installation process or add the following content to the /etc/hosts file, replacing the dev.lamassu.io domain with your own: 127.0.0.1 dev.lamassu.io 127.0.0.1 vault.dev.lamassu.io 127.0.0.1 auth.dev.lamassu.io 127.0.0.1 tracing.dev.lamassu.io 127.0.0.1 consul.dev.lamassu.io","title":"Requirements"},{"location":"setup/#setup","text":"","title":"Setup"},{"location":"setup/#automatic-deployment","text":"Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the next secret environment variables by exporting the following variables. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by exporting the DOMAIN variable. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env Run the installer: bash install.sh OPTIONAL : Import your certificates: The install.sh script also generates self-signed for the downstream certificates. It is possible to provide other valid certificates by replacing the following files: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt <----- Provide your certificate \u2514\u2500\u2500 tls.key <----- Provide your private key Once you replace this certificates, restart the api-gateway to obtain the imported certificates: docker-compose rm -s -f api-gateway dms-default docker-compose up -d api-gateway dms-default Final notes: \ud83d\ude80 You are ready to go \ud83d\ude80 Note Keycloak is your auth provider. During the install.sh the service is provisioned with 2 users with different roles: Username: enroller Password: enroller Role: admin Username: operator Password: operator Role: operator You can change those credentials (or create new users) using keycloak's UI available at: https://auth.<DOMAIN>","title":"Automatic deployment"},{"location":"setup/#manual-deployment","text":"To launch Lamassu follow the next steps: Set up your environment: Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the DB credentials variables used by the .env file. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by the .env file. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env The Gateway and TLS Certificates Lamassu uses a Gateway to expose all the deployed services. Moreover, the gateway is in charge of performing the following tasks: - Routing traffic to services - Enforcing authentication policies - Enforcing authorization policies - Logging & tracing - Healthchecking - Securely expose services using TLS The different APIs exposed through the gateway have been configured to ONLY accept request originates inside the platform via a mTLS authentication: Generate the upstream certificates. cd tls-certificates ./gen-upstream-certs.sh There are 2 options for the downstream certificate: Import an existing certificate : If you have valid certificates for your domain, you can use them by placing them under the downstream folder. The end result should be: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt \u2514\u2500\u2500 tls.key Generate a Self Signed certificate : If you need to create a new self-signed certificate, run the following command: ./gen-downstream-certs.sh Authentication service configuration: Run Keycloak: docker-compose up -d auth Keycloak image is configured with a Realm, a client and two different roles: admin and operator . Create a user with admin role to perform Enroller administrator tasks. (The command below creates a user named enroller with enroller as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u enroller -p enroller --roles admin Create a user with operator role to perform Device Manufacturing System tasks. This Device Manufacturing System must associate its CSR with this user matching the CN attribute and the username.(The command below creates a user named operator with operator as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u operator -p operator --roles operator Reload keyclok server docker-compose exec auth /opt/jboss/keycloak/bin/jboss-cli.sh --connect command=:reload If Keycloak display the following output, keycloak has successfully reloaded. Otherwise, run the command again until you see the expected output: { \"outcome\" => \"success\", \"result\" => undefined } Provision and configure Vault and Lamassu CA: Run Vault: docker-compose up -d vault consul-server api-gateway Initialize vault: This process generates vault's unseal keys as well as the root token: docker-compose exec vault vault operator init -key-shares=5 -key-threshold=3 -tls-skip-verify -format=json > vault-credentials.json Verify the vault-credentials.json file has the expected content. It should be similar to this: { \"unseal_keys_b64\": [ \"Hfx46iMq/PXoBPhDZ0EAMM9MDWS8GTCANFbAkzVEzFOD\", \"lfo48PHGFGHmpaFn6Z6rWTXTXVS53m9duxsvwVjRDc2L\", \"dcVw6N81i+/pY34WTHQYkV848to7jNeVkgdJOtgxnRkS\", \"Aut6oL7+GomXCrrTH0FCKhJwAs2PrWFYSnWpgjLfwsH0\", \"pprFM0HJEUR4m3kaIT5sga87aJ4AjXi32KVn6dgfivii\" ], \"unseal_keys_hex\": [ \"1dfc78ea232afcf5e804f84367410030cf4c0d64bc1930803456c0933544cc5383\", \"95fa38f0f1c61461e6a5a167e99eab5935d35d54b9de6f5dbb1b2fc158d10dcd8b\", \"75c570e8df358befe9637e164c7418915f38f2da3b8cd7959207493ad8319d1912\", \"02eb7aa0befe1a89970abad31f41422a127002cd8fad61584a75a98232dfc2c1f4\", \"a69ac53341c91144789b791a213e6c81af3b689e008d78b7d8a567e9d81f8af8a2\" ], \"unseal_shares\": 5, \"unseal_threshold\": 3, \"recovery_keys_b64\": [], \"recovery_keys_hex\": [], \"recovery_keys_shares\": 5, \"recovery_keys_threshold\": 3, \"root_token\": \"s.80Mpm0OmxlXzoSxZB2MMPcNu\" } Export the following variables: export VAULT_TOKEN=$(cat vault-credentials.json | jq .root_token -r) export VAULT_ADDR=https://vault.$DOMAIN Unseal Vault using the keys obtained with the previous command: curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[0])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[1])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[2])\\\" }\" Vault must be provisioned with some resources (authentication methods, policies and secret engines). That can be achieved by running the ca-provision.sh script. Vault will be provisioned with 4 Root CAs, 1 Special CA (Lamassu-DMS-Enroller) AppRole authentication method and one role and policy for each service or container that needs to exchange data with it. cd config/vault/provision/ ./provisioner.sh cd ../../../ Get RoleID and SecretID for each service and set those values in the empty fields of the .docker-compose.yml file. export CA_VAULT_ROLEID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/role-id | jq -r .data.role_id ) export CA_VAULT_SECRETID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" --request POST ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/secret-id | jq -r .data.secret_id) # Set RoleID and SecretID in docker-compose.yml file sed -i 's/<LAMASSU_CA_VAULT_ROLE_ID>/'$CA_VAULT_ROLEID'/g' docker-compose.yml sed -i 's/<LAMASSU_CA_VAULT_SECRET_ID>/'$CA_VAULT_SECRETID'/g' docker-compose.yml Configure the Device Manager: The Device Manage has a configurable variable that determines when a device can renew (also known as reenroll) its certificate. By default the reenrollment process can only be done 30 days prior to the cert's expiration time. This value can be changed by modifying the DEVICE_MANAGER_MINIMUM_REENROLL_DAYS variable located in the .env file. Start the remaining services: docker-compose up -d Configure the Default DMS First, authenticate against Keycloak: export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' |jq -r .access_token) Then, register a new DMS named Lamassu-Default-DMS: Note while registering new DMS instances with non admin users, it is necessary to register the DMS using the user's username as the common name, otherwise, the user won't see its DMSs export ENROLL_ADDR=$DOMAIN/api/dmsenroller export DMS_REGISTER_RESPONSE=$(curl -k --location --request POST \"https://$ENROLL_ADDR/v1/Lamassu-Default-DMS/form\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"url\\\":\\\"https://${DOMAIN}:5000\\\", \\\" subject\\\":{ \\\"common_name\\\": \\\"Lamassu-Default-DMS\\\",\\\"country\\\": \\\"\\\",\\\"locality\\\": \\\"\\\",\\\"organization\\\": \\\"\\\",\\\"organization_unit\\\": \\\"\\\",\\\"state\\\": \\\"\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 3072,\\\"type\\\": \\\"rsa\\\"}}\") echo $DMS_REGISTER_RESPONSE | jq -r .priv_key | sed 's/\\\\n/\\n/g' | sed -Ez '$ s/\\n+$//' | base64 -d > lamassu-default-dms/config/dms.key export DMS_ID=$(echo $DMS_REGISTER_RESPONSE | jq -r .dms.id) 3. Enroll the new DMS curl -k --location --request PUT \"https://$ENROLL_ADDR/v1/$DMS_ID\" --header \"Authorization: Bearer $TOKEN\" --header 'Content-Type: application/json' --data-raw '{\"status\": \"APPROVED\"}' 4. Get issued DMS Cert curl -k --location --request GET \"https://$ENROLL_ADDR/v1/$DMS _ID/crt\" --header \"Authorization: Bearer $TOKEN\" | base64 -d > lamassu-default-dms/config/dms.crt And finally, start the DMS \"server\": docker-compose rm -s -f dms-default docker-compose up -d dms-default","title":"Manual deployment"},{"location":"setup/#deploy-aws-and-azure-pki-connectors","text":"","title":"Deploy AWS and Azure PKI connectors"},{"location":"usage/","text":"Getting Started Before jumping any further, please check out the installation process to deploy all Lamassu services. This section will guide you through the basic functionalities provided by our PKI to start provisioning your devices. Overview Create a new Certification Authority The first step to provision your devices with digital certificates is to create the Certification Authority. The role of a CA is to issue and manage all the certificates. To create a new CA, fill the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs. Register a new Device Manufacturing System Lamassu is a PKI designed for the industrial and iot sector. To better integrate this PKI in real life manufacturing system, Lamassu delegates the issuance of device certificate to the factory itself. First lets dive into the Device Manufacturing System (DMS for short) registration step by step. After that, a couple of examples will demonstrate how to start enrolling your devices using the Lamassu's Virtual DMS software as well as using the UI. Device manufacturing process tend to be highly automated. Provisioning the devices with digital identities should not slow down the fabrication process. Lamassu addresses this challenge introducing the DMS concept as core. One of the factories operators stars the process by generating a DMS registration request contained in a Certificate Signing Request also referred as CSR. This CSR is then sent to the DMS Enroller service to be approved by one of the PKI Administrators: The Administrator then decides if the request is approved or denied. If it decision is to approve the DMS registration request, the Administrator must specify which CAs will that particular DSM be entitled to issue certificates with: Once, and only if, the DMS registration request is approved, then the Operator must retrieve the signed CSR and pass it to the DMS software that will be in charge off requesting the issuance of new digital certificates for the manufactured devices: Finally, the DMS is able to request new x509 certificates for its manufactured devices. The DMS may be assisted by additional tools to obtain the manufactured device unique identifier. Let's register a new DMS instance: Operator - Authenticate the user: OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Operator - Request the registration for a new DMS instance: DMS_NAME=MyDMS DMS_SUBJECT_COUNTRY=ES DMS_SUBJECT_STATE=Gipuzkoa DMS_SUBJECT_LOCALITY=Donostia DMS_SUBJECT_ORGANIZATION=Lamassu DMS_SUBJECT_ORGANIZATION_UNIT=IoT DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsenroller/v1/$DMS_NAME/form\" \\ --header \"Authorization: Bearer $OPERATOR_TOKEN\" \\ --data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"org\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}}\") DMS_ID=$(echo $DMS_REG_RESPONSE | jq -r .dms.id) echo $DMS_REG_RESPONSE | jq -r .priv_key | base64 -d > dms.key Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Authorize the enrollment with all the provisioned CAs AUTHORIZED_CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .[].name | jq -s) curl -k --location --request PUT \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" \\ --header \"Authorization: Bearer $ENROLLER_TOKEN\" \\ --data-raw \"{\\\"authorized_cas\\\":$AUTHORIZED_CAS, \\\"status\\\":\\\"APPROVED\\\"}\" Operator - Get the DMS certificate: curl -k \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .crt | base64 -d > dms.crt Provision your devices with x509 Certificates The enrollment process is the way to go to obtain a certificate issued by one of the provisioned CAs. As described in the RFC document, Lamassu requires the authentication of the client requesting the enrollment using a certificate as well as the private key of an issued DMS to perform a mutual TLS connection. By using this type of TLS connection, the client is able to authenticate the server, and also, the server is able to authenticate the client. Although the /api/devmanager/.well-known/cacerts endpoint returns the list containing all the manged CAs by the PKI, each DMS is entitled to request the issuance of a certificate with an authorized CA. For instance, the PKI may have the following CAs: CA1 , CA2 , CA3 and CA4 . The /api/devmanager/.well-known/cacerts would return all four CAs. Then, a new DMS is registered. the PKI administrator approves the DMS registration by authorizing such DMS to issue certificates with CA1 and CA4 . This process is known as the DMS registration process . Once the DMS is completely registered, it can now start performing the EST enrollment process. Check out the previous section to understand what a DMS does. Let's first obtain the CA list for a particular DMS: First, authenticate and obtain a valid JWT OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Obtain the CA list: ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .authorized_cas) Select one of the entitled the CAs from the previous list: Note You can manually spefify the SELECTED_CA . Otherwise you can enroll the device with the first entitled CA using the following command. SELECTED_CA=$(echo $ENTITLED_CAS | jq .[0] -r) Generate the device CSR: DEVICE_ID=mytestdevice-123 openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" Enroll the device: DMS_CRT_PATH=path/to/dms_crt DMS_KEY_PATH=path/to/dms_key openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem curl https://$DOMAIN/api/devmanager/.well-known/est/$SELECTED_CA/simpleenroll --cert $DMS_CRT_PATH --key $DMS_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem --data-binary @device.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem openssl x509 -text -in device-cert.pem Using the APIs The main 3 Open API documentation can be found on the following urls: https://dev.lamassu.io/api/dmsenroller/v1/docs/ https://dev.lamassu.io/api/ca/v1/docs/ https://dev.lamassu.io/api/devmanager/v1/docs/ Note The following endpoints defined in the Lamassu Device Manager Api specification are not correctly defined due to the limitations imposed by the Open API 3.0 schema. The current specification defines an OIDC security schema (meaning that a valid JWT token must be provided while requesting the API) while the implemented security schema uses the mTLS approach. This issue will be resolved once the specification is migrated to Open API 3.1 compliant. The affected endpoints are: Lamassu provides easy to use GO clients for most of its APIs to help speeding up the development of third-party applications. Before using thees clients, it is important to identify the path taken by the request. Unless the application using the GO clients (or any other http client such as curl ) is deployed within the same docker network, the request will be handled by the API Gateway component . Otherwise check the internal usage section. Through the API Gateway Go Curl package main import ( \"net/url\" lamassuCAClient \"github.com/lamassuiot/lamassuiot/pkg/ca/client\" caDTO \"github.com/lamassuiot/lamassuiot/pkg/ca/common/dto\" \"github.com/lamassuiot/lamassuiot/pkg/utils/client\" ) function main (){ lamassuGatewayURL := \"dev.lamassu.io\" apiCAFile := \"path/to/apigw.crt\" caClient := lamassuCAClient . NewLamassuCAClient ( client . ClientConfiguration { URL : & url . URL { Scheme : \"https\" , Host : lamassuGatewayURL , Path : \"/api/ca/\" , }, AuthMethod : client . JWT , AuthMethodConfig : & client . JWTConfig { Username : \"enroller\" , Password : \"enroller\" , URL : & url . URL { Scheme : \"https\" , Host : \"auth.\" + lamassuGatewayURL , }, CACertificate : apiCAFile , }, CACertificate : apiCAFile , }) ca , err = caClient . CreateCA ( context . Background (), caDTO . Pki , caName , caDTO . PrivateKeyMetadata { KeyType : \"rsa\" , KeyBits : 2048 }, caDTO . Subject { CN : caName }, 365 * time . Hour , 30 * time . Hour ) } Internal usage","title":"Getting Started"},{"location":"usage/#getting-started","text":"Before jumping any further, please check out the installation process to deploy all Lamassu services. This section will guide you through the basic functionalities provided by our PKI to start provisioning your devices.","title":"Getting Started"},{"location":"usage/#overview","text":"","title":"Overview"},{"location":"usage/#create-a-new-certification-authority","text":"The first step to provision your devices with digital certificates is to create the Certification Authority. The role of a CA is to issue and manage all the certificates. To create a new CA, fill the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs.","title":"Create a new Certification Authority"},{"location":"usage/#register-a-new-device-manufacturing-system","text":"Lamassu is a PKI designed for the industrial and iot sector. To better integrate this PKI in real life manufacturing system, Lamassu delegates the issuance of device certificate to the factory itself. First lets dive into the Device Manufacturing System (DMS for short) registration step by step. After that, a couple of examples will demonstrate how to start enrolling your devices using the Lamassu's Virtual DMS software as well as using the UI. Device manufacturing process tend to be highly automated. Provisioning the devices with digital identities should not slow down the fabrication process. Lamassu addresses this challenge introducing the DMS concept as core. One of the factories operators stars the process by generating a DMS registration request contained in a Certificate Signing Request also referred as CSR. This CSR is then sent to the DMS Enroller service to be approved by one of the PKI Administrators: The Administrator then decides if the request is approved or denied. If it decision is to approve the DMS registration request, the Administrator must specify which CAs will that particular DSM be entitled to issue certificates with: Once, and only if, the DMS registration request is approved, then the Operator must retrieve the signed CSR and pass it to the DMS software that will be in charge off requesting the issuance of new digital certificates for the manufactured devices: Finally, the DMS is able to request new x509 certificates for its manufactured devices. The DMS may be assisted by additional tools to obtain the manufactured device unique identifier. Let's register a new DMS instance: Operator - Authenticate the user: OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Operator - Request the registration for a new DMS instance: DMS_NAME=MyDMS DMS_SUBJECT_COUNTRY=ES DMS_SUBJECT_STATE=Gipuzkoa DMS_SUBJECT_LOCALITY=Donostia DMS_SUBJECT_ORGANIZATION=Lamassu DMS_SUBJECT_ORGANIZATION_UNIT=IoT DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsenroller/v1/$DMS_NAME/form\" \\ --header \"Authorization: Bearer $OPERATOR_TOKEN\" \\ --data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"org\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}}\") DMS_ID=$(echo $DMS_REG_RESPONSE | jq -r .dms.id) echo $DMS_REG_RESPONSE | jq -r .priv_key | base64 -d > dms.key Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Authorize the enrollment with all the provisioned CAs AUTHORIZED_CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .[].name | jq -s) curl -k --location --request PUT \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" \\ --header \"Authorization: Bearer $ENROLLER_TOKEN\" \\ --data-raw \"{\\\"authorized_cas\\\":$AUTHORIZED_CAS, \\\"status\\\":\\\"APPROVED\\\"}\" Operator - Get the DMS certificate: curl -k \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .crt | base64 -d > dms.crt","title":"Register a new Device Manufacturing System"},{"location":"usage/#provision-your-devices-with-x509-certificates","text":"The enrollment process is the way to go to obtain a certificate issued by one of the provisioned CAs. As described in the RFC document, Lamassu requires the authentication of the client requesting the enrollment using a certificate as well as the private key of an issued DMS to perform a mutual TLS connection. By using this type of TLS connection, the client is able to authenticate the server, and also, the server is able to authenticate the client. Although the /api/devmanager/.well-known/cacerts endpoint returns the list containing all the manged CAs by the PKI, each DMS is entitled to request the issuance of a certificate with an authorized CA. For instance, the PKI may have the following CAs: CA1 , CA2 , CA3 and CA4 . The /api/devmanager/.well-known/cacerts would return all four CAs. Then, a new DMS is registered. the PKI administrator approves the DMS registration by authorizing such DMS to issue certificates with CA1 and CA4 . This process is known as the DMS registration process . Once the DMS is completely registered, it can now start performing the EST enrollment process. Check out the previous section to understand what a DMS does. Let's first obtain the CA list for a particular DMS: First, authenticate and obtain a valid JWT OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Obtain the CA list: ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .authorized_cas) Select one of the entitled the CAs from the previous list: Note You can manually spefify the SELECTED_CA . Otherwise you can enroll the device with the first entitled CA using the following command. SELECTED_CA=$(echo $ENTITLED_CAS | jq .[0] -r) Generate the device CSR: DEVICE_ID=mytestdevice-123 openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" Enroll the device: DMS_CRT_PATH=path/to/dms_crt DMS_KEY_PATH=path/to/dms_key openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem curl https://$DOMAIN/api/devmanager/.well-known/est/$SELECTED_CA/simpleenroll --cert $DMS_CRT_PATH --key $DMS_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem --data-binary @device.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem openssl x509 -text -in device-cert.pem","title":"Provision your devices with x509 Certificates"},{"location":"usage/#using-the-apis","text":"The main 3 Open API documentation can be found on the following urls: https://dev.lamassu.io/api/dmsenroller/v1/docs/ https://dev.lamassu.io/api/ca/v1/docs/ https://dev.lamassu.io/api/devmanager/v1/docs/ Note The following endpoints defined in the Lamassu Device Manager Api specification are not correctly defined due to the limitations imposed by the Open API 3.0 schema. The current specification defines an OIDC security schema (meaning that a valid JWT token must be provided while requesting the API) while the implemented security schema uses the mTLS approach. This issue will be resolved once the specification is migrated to Open API 3.1 compliant. The affected endpoints are: Lamassu provides easy to use GO clients for most of its APIs to help speeding up the development of third-party applications. Before using thees clients, it is important to identify the path taken by the request. Unless the application using the GO clients (or any other http client such as curl ) is deployed within the same docker network, the request will be handled by the API Gateway component . Otherwise check the internal usage section.","title":"Using the APIs"},{"location":"usage/#through-the-api-gateway","text":"Go Curl package main import ( \"net/url\" lamassuCAClient \"github.com/lamassuiot/lamassuiot/pkg/ca/client\" caDTO \"github.com/lamassuiot/lamassuiot/pkg/ca/common/dto\" \"github.com/lamassuiot/lamassuiot/pkg/utils/client\" ) function main (){ lamassuGatewayURL := \"dev.lamassu.io\" apiCAFile := \"path/to/apigw.crt\" caClient := lamassuCAClient . NewLamassuCAClient ( client . ClientConfiguration { URL : & url . URL { Scheme : \"https\" , Host : lamassuGatewayURL , Path : \"/api/ca/\" , }, AuthMethod : client . JWT , AuthMethodConfig : & client . JWTConfig { Username : \"enroller\" , Password : \"enroller\" , URL : & url . URL { Scheme : \"https\" , Host : \"auth.\" + lamassuGatewayURL , }, CACertificate : apiCAFile , }, CACertificate : apiCAFile , }) ca , err = caClient . CreateCA ( context . Background (), caDTO . Pki , caName , caDTO . PrivateKeyMetadata { KeyType : \"rsa\" , KeyBits : 2048 }, caDTO . Subject { CN : caName }, 365 * time . Hour , 30 * time . Hour ) }","title":"Through the API Gateway"},{"location":"usage/#internal-usage","text":"","title":"Internal usage"},{"location":"virtualDMS/","text":"Lamassu Virtual DMS To launch Lamassu-Virtual-DMS follow the next steps: Clone the repository and get into the directory: https://github.com/lamassuiot/lamassu-virtual-dms.git && cd lamassu-virtual-dms . Change the configuration variables of the config.json file. { \"dms\": { \"device_store\": \"<DEVICES_STORE>\", // Folder where device certificates are stored \"dms_store\": \"<DMS_STORE>\", // Folder where DMS certificates are stored \"endpoint\":\"<DMS_SERVER>\", // DMS server endpoint \"dms_name\":\"<DEFAULT_DMS>\", // DMS Name \"common_name\":\"<DEFAULT_DMS>\", // Common_name to create the CSR \"country\":\"<COUNTRY>\", // Country to create the CSR \"locality\":\"<LOCALITY>\", // Locality to create the CSR \"organization\":\"<ORGANIZATION>\", // Organization to create the CSR \"organization_unit\":\"<ORGANIZATION_UNIT>\", // Organization_unit to create the CSR \"state\":\"<STATE>\" // State to create the CSR }, \"devmanager\":{ \"devcrt\": \"<DEV_CERTIFICATE>\", // Public certificate to connect to the device-manager \"addr\": \"<DEVMANAGER_SERVER>\" //Device Manager Server Endpoint }, \"auth\":{ \"endpoint\":\"<AUTH_SERVER>\", // Authentication Server endpoint \"username\":\"<PASSWORD>\", // User name to connect to the authentication server \"password\":\"<PASSWORD>\" // Password to connect to the authentication server } } 3. Create directories to store DMS and device certificates mkdir -p /home/$USER/virtual-dms-data/devices_certificates mkdir -p /home/$USER/virtual-dms-data/dms_certificates 4. config.json file with default values { \"dms\": { \"device_store\": \"/home/$USER/virtual-dms-data/devices_certificates\", \"dms_store\": \"/home/$USER/virtual-dms-data/dms_certificates\", \"endpoint\":\"dev.lamassu.io/api/dmsenroller\", \"dms_name\":\"Virtual DMS\", \"common_name\":\"Virtual DMS\", \"country\":\"ES\", \"locality\":\"Mondragon\", \"organization\":\"LKS\", \"organization_unit\":\"LKS PKI\", \"state\":\"Guipuzcoa\" }, \"devmanager\":{ \"devcrt\": \"<DEV_CERTIFICATE>\", \"addr\": \"dev.lamassu.io/api/devmanager\" }, \"auth\":{ \"endpoint\":\"auth.dev.lamassu.io\", \"username\":\"enroller\", \"password\":\"enroller\" } } 5. Run the Lamassu-Default-DMS UI: go run cmd/main.go Lamassu Virtual DMS operating modes The virtual DMS has two modes of operation, on the one hand, there is the mode of creating a DMS and once the DMS is created and approved, the devices are automatically enrolled using the DMS. On the other hand, if a DMS has already been created and approved, devices can be directly enrolled without having to create a DMS. In the second case it is necessary to make sure that the certificate and the DMS key are in the directory where the DMS certificates are stored. If the Virtual-DMS is not used to create the DMS, in the directory where the certificates are stored, the certificates and keys must be created with the following format: \u251c\u2500\u2500 devices_certificates \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 dms_certificates \u251c\u2500\u2500 dms-<DMS_ID>.crt <----- Provide your certificate \u2514\u2500\u2500 dms-<DMS_ID>.key <----- Provide your private key Create the DMS, once the DMS is created, the Auto_Enroll of the devices is done. 2. Make the Auto_Enroll of the devices indicating the ID of a DMS.","title":"Lamassu Virtual DMS"},{"location":"virtualDMS/#lamassu-virtual-dms","text":"To launch Lamassu-Virtual-DMS follow the next steps: Clone the repository and get into the directory: https://github.com/lamassuiot/lamassu-virtual-dms.git && cd lamassu-virtual-dms . Change the configuration variables of the config.json file. { \"dms\": { \"device_store\": \"<DEVICES_STORE>\", // Folder where device certificates are stored \"dms_store\": \"<DMS_STORE>\", // Folder where DMS certificates are stored \"endpoint\":\"<DMS_SERVER>\", // DMS server endpoint \"dms_name\":\"<DEFAULT_DMS>\", // DMS Name \"common_name\":\"<DEFAULT_DMS>\", // Common_name to create the CSR \"country\":\"<COUNTRY>\", // Country to create the CSR \"locality\":\"<LOCALITY>\", // Locality to create the CSR \"organization\":\"<ORGANIZATION>\", // Organization to create the CSR \"organization_unit\":\"<ORGANIZATION_UNIT>\", // Organization_unit to create the CSR \"state\":\"<STATE>\" // State to create the CSR }, \"devmanager\":{ \"devcrt\": \"<DEV_CERTIFICATE>\", // Public certificate to connect to the device-manager \"addr\": \"<DEVMANAGER_SERVER>\" //Device Manager Server Endpoint }, \"auth\":{ \"endpoint\":\"<AUTH_SERVER>\", // Authentication Server endpoint \"username\":\"<PASSWORD>\", // User name to connect to the authentication server \"password\":\"<PASSWORD>\" // Password to connect to the authentication server } } 3. Create directories to store DMS and device certificates mkdir -p /home/$USER/virtual-dms-data/devices_certificates mkdir -p /home/$USER/virtual-dms-data/dms_certificates 4. config.json file with default values { \"dms\": { \"device_store\": \"/home/$USER/virtual-dms-data/devices_certificates\", \"dms_store\": \"/home/$USER/virtual-dms-data/dms_certificates\", \"endpoint\":\"dev.lamassu.io/api/dmsenroller\", \"dms_name\":\"Virtual DMS\", \"common_name\":\"Virtual DMS\", \"country\":\"ES\", \"locality\":\"Mondragon\", \"organization\":\"LKS\", \"organization_unit\":\"LKS PKI\", \"state\":\"Guipuzcoa\" }, \"devmanager\":{ \"devcrt\": \"<DEV_CERTIFICATE>\", \"addr\": \"dev.lamassu.io/api/devmanager\" }, \"auth\":{ \"endpoint\":\"auth.dev.lamassu.io\", \"username\":\"enroller\", \"password\":\"enroller\" } } 5. Run the Lamassu-Default-DMS UI: go run cmd/main.go","title":"Lamassu Virtual DMS"},{"location":"virtualDMS/#lamassu-virtual-dms-operating-modes","text":"The virtual DMS has two modes of operation, on the one hand, there is the mode of creating a DMS and once the DMS is created and approved, the devices are automatically enrolled using the DMS. On the other hand, if a DMS has already been created and approved, devices can be directly enrolled without having to create a DMS. In the second case it is necessary to make sure that the certificate and the DMS key are in the directory where the DMS certificates are stored. If the Virtual-DMS is not used to create the DMS, in the directory where the certificates are stored, the certificates and keys must be created with the following format: \u251c\u2500\u2500 devices_certificates \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 dms_certificates \u251c\u2500\u2500 dms-<DMS_ID>.crt <----- Provide your certificate \u2514\u2500\u2500 dms-<DMS_ID>.key <----- Provide your private key Create the DMS, once the DMS is created, the Auto_Enroll of the devices is done. 2. Make the Auto_Enroll of the devices indicating the ID of a DMS.","title":"Lamassu Virtual DMS operating modes"},{"location":"virtualDevice/","text":"Lamassu Virtual Device To launch Lamassu-Virtual-Device follow the next steps: Clone the repository and get into the directory: https://github.com/lamassuiot/lamassu-virtual-device.git && cd lamassu-virtual-device . Change the configuration variables of the config.json file. { \"certificates_dir\": \"<DEVICES_CERTIFICATES>\", // Folder where device certificates are stored \"devmanager\": { \"est_server\": \"<DEVICE_MANAGER_SERVER>\", // Device Manager Server Endpoint \"cert\":\"<DEVMANAGER_CERT>\" // Public certificate to connect to the device-manager }, \"aws\":{ \"iot_core_ca_file\": \"<AWS_CA_CERT>\", // AWS IoT Core CA Certificate \"iot_core_endpoint\": \"<AWS_ENDPOINT>\", // AWS IoT Core endpoint \"test_lambda\": \"<LAMBDA>\" // Lambda name } } 3. config.json file with default values { \"certificates_dir\": \"/home/$USER/virtual-dms-data/devices_certificates\", \"devmanager\": { \"est_server\": \"dev.lamassu.io/api/devmanager\", \"cert\":\"<DEVMANAGER_CERT>\" }, \"aws\":{ \"iot_core_ca_file\": \"<AWS_CA_CERT>\", \"iot_core_endpoint\": \"<AWS_ENDPOINT>\", \"test_lambda\": \"<LAMBDA>\" } } In case of not using the Virtual-DMS to register the devices, in the directory where the certificates are stored the certificates and keys must be created with the following format: \u251c\u2500\u2500 devices_certificates \u2502 \u251c\u2500\u2500 device-<DMS_NAME>-<DEVICE_ID> \u2502 \u2502 \u251c\u2500\u2500 certificates \u2502 \u2502 \u2502 \u251c\u2500\u2500 <CERT_SN>.crt <----- Provide your certificate \u2502 \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2502 \u251c\u2500\u2500 <DEVICE_ID>.csr <----- Provide your certificate request \u2502 \u2502 \u2514\u2500\u2500 <DEVICE_ID>.key <----- Provide your private key \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 dms_certificates \u251c\u2500\u2500 dms-<DMS_ID>.crt <----- Provide your certificate \u2514\u2500\u2500 dms-<DMS_ID>.key <----- Provide your private key 4. Run the Lamassu-Virtua-Device UI: go run cmd/main.go Lamassu Virtual device pages Lamassu Virtual Device has the following pages: Device Information View: a page showing each device's information. Choose from the dropdown the DeviceId and the Serial Number of the Certificateof to visualize the details. AWS Integration: a page to check AWS connectivity Reenroll: each device has the option to reenroll","title":"Lamassu Virtual Device"},{"location":"virtualDevice/#lamassu-virtual-device","text":"To launch Lamassu-Virtual-Device follow the next steps: Clone the repository and get into the directory: https://github.com/lamassuiot/lamassu-virtual-device.git && cd lamassu-virtual-device . Change the configuration variables of the config.json file. { \"certificates_dir\": \"<DEVICES_CERTIFICATES>\", // Folder where device certificates are stored \"devmanager\": { \"est_server\": \"<DEVICE_MANAGER_SERVER>\", // Device Manager Server Endpoint \"cert\":\"<DEVMANAGER_CERT>\" // Public certificate to connect to the device-manager }, \"aws\":{ \"iot_core_ca_file\": \"<AWS_CA_CERT>\", // AWS IoT Core CA Certificate \"iot_core_endpoint\": \"<AWS_ENDPOINT>\", // AWS IoT Core endpoint \"test_lambda\": \"<LAMBDA>\" // Lambda name } } 3. config.json file with default values { \"certificates_dir\": \"/home/$USER/virtual-dms-data/devices_certificates\", \"devmanager\": { \"est_server\": \"dev.lamassu.io/api/devmanager\", \"cert\":\"<DEVMANAGER_CERT>\" }, \"aws\":{ \"iot_core_ca_file\": \"<AWS_CA_CERT>\", \"iot_core_endpoint\": \"<AWS_ENDPOINT>\", \"test_lambda\": \"<LAMBDA>\" } } In case of not using the Virtual-DMS to register the devices, in the directory where the certificates are stored the certificates and keys must be created with the following format: \u251c\u2500\u2500 devices_certificates \u2502 \u251c\u2500\u2500 device-<DMS_NAME>-<DEVICE_ID> \u2502 \u2502 \u251c\u2500\u2500 certificates \u2502 \u2502 \u2502 \u251c\u2500\u2500 <CERT_SN>.crt <----- Provide your certificate \u2502 \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2502 \u251c\u2500\u2500 <DEVICE_ID>.csr <----- Provide your certificate request \u2502 \u2502 \u2514\u2500\u2500 <DEVICE_ID>.key <----- Provide your private key \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 dms_certificates \u251c\u2500\u2500 dms-<DMS_ID>.crt <----- Provide your certificate \u2514\u2500\u2500 dms-<DMS_ID>.key <----- Provide your private key 4. Run the Lamassu-Virtua-Device UI: go run cmd/main.go","title":"Lamassu Virtual Device"},{"location":"virtualDevice/#lamassu-virtual-device-pages","text":"Lamassu Virtual Device has the following pages: Device Information View: a page showing each device's information. Choose from the dropdown the DeviceId and the Serial Number of the Certificateof to visualize the details. AWS Integration: a page to check AWS connectivity Reenroll: each device has the option to reenroll","title":"Lamassu Virtual device pages"}]}