{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Lamassu Iot Docs Lamassu is an IoT first PKI designed for industrial scenarios. Public key infrastructure are systems in charge of creating, storing and distributing digital certificates which are used to verify that a particular public key belongs to a certain entity. PKIs creates digital certificates which map to public keys to entities, securely stores these certificates in a central repository and revokes them if needed.","title":"Welcome to Lamassu Iot Docs"},{"location":"#welcome-to-lamassu-iot-docs","text":"Lamassu is an IoT first PKI designed for industrial scenarios. Public key infrastructure are systems in charge of creating, storing and distributing digital certificates which are used to verify that a particular public key belongs to a certain entity. PKIs creates digital certificates which map to public keys to entities, securely stores these certificates in a central repository and revokes them if needed.","title":"Welcome to Lamassu Iot Docs"},{"location":"aws/","text":"AWS Services used by Lamassu The AMQP Queue To get developers up to speed with new updates releated with Lamassu, a AMQP-based Queue service is deployed to provide real-time events. The core components ( Lamassu CA , Lamassu DeviceManager and Lamassu DMS Enroller ) publish new event messages if an update opperation is triggered. Update opperations are any tpye of function that end up modifying data in any way. Once a core component registers an update opperation, it then published a special crafted event message to the lamassu_events queue. Each publish event follows the https://cloudevents.io/ syntaxis. The asynchronous messages then synchronize with the especified cloud-provider. AWS Lambda AWS Lambda is a serverless, event-driven compute service that lets you run code for virtually any type of application or backend service without provisioning or managing servers. AWS IoT Core AWS IoT provides the cloud services that connect IoT devices to other devices and services in the AWS Cloud. AWS IoT provides device software that can help integrate IoT devices into solutions based on AWS IoT. If devices can connect to AWS IoT, AWS IoT can connect them to cloud services provided by AWS. AWS Cloud Formation AWS CloudFormation is a service that helps you model and set up your AWS resources so that you can spend less time managing those resources and more time focusing on your applications that run in AWS. You create a template that describes all the AWS resources that you want, and CloudFormation takes care of provisioning and configuring those resources for you. You don't need to individually create and configure AWS resources and figure out what's dependent on what; CloudFormation handles that. The following scenarios demonstrate how CloudFormation can help. References AWS Lambda web page: AWS Lambda AWS IoT Core web page: AWS IoT Core AWS Cloud Formation web page: AWS Cloud Formation","title":"AWS Services used by Lamassu"},{"location":"aws/#aws-services-used-by-lamassu","text":"","title":"AWS Services used by Lamassu"},{"location":"aws/#the-amqp-queue","text":"To get developers up to speed with new updates releated with Lamassu, a AMQP-based Queue service is deployed to provide real-time events. The core components ( Lamassu CA , Lamassu DeviceManager and Lamassu DMS Enroller ) publish new event messages if an update opperation is triggered. Update opperations are any tpye of function that end up modifying data in any way. Once a core component registers an update opperation, it then published a special crafted event message to the lamassu_events queue. Each publish event follows the https://cloudevents.io/ syntaxis. The asynchronous messages then synchronize with the especified cloud-provider.","title":"The AMQP Queue"},{"location":"aws/#aws-lambda","text":"AWS Lambda is a serverless, event-driven compute service that lets you run code for virtually any type of application or backend service without provisioning or managing servers.","title":"AWS Lambda"},{"location":"aws/#aws-iot-core","text":"AWS IoT provides the cloud services that connect IoT devices to other devices and services in the AWS Cloud. AWS IoT provides device software that can help integrate IoT devices into solutions based on AWS IoT. If devices can connect to AWS IoT, AWS IoT can connect them to cloud services provided by AWS.","title":"AWS IoT Core"},{"location":"aws/#aws-cloud-formation","text":"AWS CloudFormation is a service that helps you model and set up your AWS resources so that you can spend less time managing those resources and more time focusing on your applications that run in AWS. You create a template that describes all the AWS resources that you want, and CloudFormation takes care of provisioning and configuring those resources for you. You don't need to individually create and configure AWS resources and figure out what's dependent on what; CloudFormation handles that. The following scenarios demonstrate how CloudFormation can help.","title":"AWS Cloud Formation"},{"location":"aws/#references","text":"AWS Lambda web page: AWS Lambda AWS IoT Core web page: AWS IoT Core AWS Cloud Formation web page: AWS Cloud Formation","title":"References"},{"location":"azure/","text":"Azure Services used by Lamassu Azure functions Azure Functions is an on-demand cloud service that provides all the continually updated infrastructure and resources needed to run your applications. Azure Queue Storage Azure Queue Storage is a service for storing large amounts of messages, which can be accessed from anywhere in the world through authenticated calls using HTTP or HTTPS. Azure IoT Hub DPS IoT Hub Device Provisioning Service (DPS) is an IoT Hub helper that provides Just-In-Time, zero-touch provisioning of the correct IoT Hub instance, enabling customers to securely provision millions of devices and scalable. References Azure functions web page: Azure functions Azure Queue Storage web page: Azure Queue Storage Azure IoT Hub DPS web page: Azure DPS","title":"Azure Services used by Lamassu"},{"location":"azure/#azure-services-used-by-lamassu","text":"","title":"Azure Services used by Lamassu"},{"location":"azure/#azure-functions","text":"Azure Functions is an on-demand cloud service that provides all the continually updated infrastructure and resources needed to run your applications.","title":"Azure functions"},{"location":"azure/#azure-queue-storage","text":"Azure Queue Storage is a service for storing large amounts of messages, which can be accessed from anywhere in the world through authenticated calls using HTTP or HTTPS.","title":"Azure Queue Storage"},{"location":"azure/#azure-iot-hub-dps","text":"IoT Hub Device Provisioning Service (DPS) is an IoT Hub helper that provides Just-In-Time, zero-touch provisioning of the correct IoT Hub instance, enabling customers to securely provision millions of devices and scalable.","title":"Azure IoT Hub DPS"},{"location":"azure/#references","text":"Azure functions web page: Azure functions Azure Queue Storage web page: Azure Queue Storage Azure IoT Hub DPS web page: Azure DPS","title":"References"},{"location":"extension/","text":"Extending Lamassu A PKI has three types of core compoents: CAs , RAs and VAs . Each PKI implementation must have an instance of those compoennts (at least) to be considered a mature digital identity provider. Certificate authority (CA) - Issues an entity's certificate and acts as a trusted component within a private PKI. Any certificate issued by the CA is trusted by all entities that trust the CA. The exact role of a CA will depend on its position within a CA hierarchy. Registration authority (RA) - Receives certificate signing requests and verifies the identity of an end entity. The RA will approve a request before the certificate can be issued by the CA. This is a very important stage of the process and it often involves a procedure to enrol end entities into the PKI. Validation authority (VA) - A VA allows an entity to check that a certificate has not been revoked. The VA role is often carried out by an online facility hosted by an organisation who operates the PKI. A validation authority will often use OCSP or CRL to advertise revoked certificates. Lamassu is no stranger to those concepts. In fact, Lamassu goes one step further by implementing LRAs or Local Registration Authorities also named DMSs. Local registration authority (LRA) - is an optional part of a public key infrastructure that maintains users' identities from which certification authorities can issue Digital Certificates. Extending the PKI is a core principal for Lamassu. There are multiple ways to customize Lamassu to the required needs by just modifying one of the core components or by developing and adding new ones. This section will describe some decissions that have been addopted to provide an extensible PKI that is able to integrate with some cloud providers such as AWS IoT Core or Azure IoT Hub . Rabbit MQ RabbitMQ serves as an intermediary for efficient communication between Lamassu UI and Cloud-Proxy. The messages are published to broker's queue via amqp (Advanced Message Queuing Protocol). Cloud Proxy A proxy server acts as a gateway between you and the internet, and verifies and forwards incoming client requests to other servers for further communication. AWS Services used by Lamassu For further detail, see AWS Services used by Lamassu AWS SQS AWS Lambda AWS IoT Core AWS Cloud Formation Infraestructure Deployment To deploy the structure in AWS to proper function with Lamassu, AWS CDK is used. The AWS Cloud Development Kit (AWS CDK) is an open-source software development framework to define your cloud application resources using familiar programming languages. Directory layout /bin/lamassu-cdk.ts app entry point. It creates objects of classes defined in /lib. /lib it contains all the stacks for our project, were AWS resources are defined. cdk.json file tells the CDK Toolkit how to execute your app. Prerequisites Install nodejs 14.X, npm and jq. sudo apt install jq nodejs npm Install aws-cdk with npm: npm install -g aws-cdk@1.x Verify cdk is installed: cdk --version Install AWS cli and configure credentials: Install AWS CLI: https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html Configure AWS CLI: aws configure Provide your AWS access key ID, secret access key, and default region when prompted. You can also configure .aws/credentials file in your home directory instead. Usage NOTE : As some AWS features used in this project are still not implemented in AWS CDK, some of the steps are done via CLI. Go to cdk project home directory: cd lamassu-cdk Option 1 : Execute deploy script: bash deploy-lamassu.sh Option 2 : Execute it step by step: npm i npm i --prefix resources/sqsFilterLambda cdk deploy --outputs-file outputs.json aws lambda update-event-source-mapping --uuid $(cat outputs.json | jq -r .LamassuCdkStack.EventSourceMappingUUID) --filter-criteria file://filter-criteria.json Remove Lamassu resources: cdk destroy LamassuCdkStack Useful commands npm run build compile typescript to js npm run watch watch for changes and compile npm run test perform the jest unit tests cdk deploy deploy this stack to your default AWS account/region cdk diff compare deployed stack with current state cdk synth emits the synthesized CloudFormation template Configuring AWS connector Prerequisites Option 1 : Install go. (Go installation guide) Option 2 : run the AWS connector in Docker. (Docker installation guide) Usage Needed environment variables: # AWS credentials AWS_ACCESS_KEY_ID= AWS_SECRET_ACCESS_KEY= AWS_DEFAULT_REGION= # AWS ATS root certificate AWS_CA_BUNDLE=awsRootCA.pem # RabbitMQ configuration: port, host and certificates AMQP_PORT=5671 AMQP_HOST=dev-lamassu.zpd.ikerlan.es AMQP_SERVER_CA_CERT=/ca.crt AMQP_CLIENT_CERT=/tls.crt AMQP_CLIENT_KEY=/tls.key # Lamassu CA configuration LAMASSU_CA_ADDRESS=https://lamassu-ca:8087 LAMASSU_CA_CERT_FILE=//ca.crt LAMASSU_CA_CLIENT_CERT_FILE=tls.crt LAMASSU_CA_CLIENT_KEY_FILE=tls.key # Consul configuration CONSUL_PROTOCOL=https CONSUL_HOST=consul-server CONSUL_PORT=8501 CONSUL_CA=/ca.crt # AWS Connector configuration CONNECTOR_PORT=8989 CONNECTOR_TYPE=aws CONNECTOR_PROTOCOL=http CONNECTOR_NAME=aws-connector-ikerlan # Configuration for jaeger tracing JAEGER_SERVICE_NAME=aws-connector JAEGER_AGENT_HOST=jaeger JAEGER_AGENT_PORT=\"6831\" JAEGER_SAMPLER_TYPE=const JAEGER_SAMPLER_PARAM=\"1\" JAEGER_REPORTER_LOG_SPANS=\"false\" Remember to change env variables depending where you run AWS connector Option 1 : Running AWS Connector cd aws-connector go run cmd/main.go Option 2 : Running the connector on Docker: cd aws-connector docker-compose up -d *NOTE *: It is better to run it on Docker. Cloud-Events To extend Lamassu to AWS cloud, whenever a opperation is triggered, an asynchronous messages are send via Amazon Simple Queue Service. Amazon SQS offers the possibility of establishing a message queue to store messages while they wait to be processed by different computers that are connected to the Internet. These messages can contain notifications for applications or lists of commands to be executed by applications, either in the cloud or on the Internet, allowing you to create automated workflows. The messages arrive at AWS cloud via lamassu-aws-connector . The connector uses two queues, one for request lamassu-command and another for responses, lamassu-response . Whenever the connector receives a message, an event-driven compute service, AWS Lambda, mappes the operation to the corresponding lambda . AWS is a serverless, event-driven compute service that lets you run code for virtually any type of application or backend service without provisioning or managing servers. The Lambda will communicate with AWS IoT Core . Event Type Source Description io.lamassu.ca.create lamassu/ca io.lamassu.ca.import lamassu/ca io.lamassu.ca.update lamassu/ca io.lamassu.cert.update lamassu/ca io.lamassu.iotcore.config.request lamassu/aws-connector/${connector-id} io.lamassu.iotcore.config.response aws/lambda io.lamassu.iotcore.ca.registration.request-code lamassu/aws-connector/${connector-id} io.lamassu.iotcore.ca.registration.response-code aws/lambda io.lamassu.iotcore.ca.registration.signed-code lamassu/aws-connector/${connector-id} io.lamassu.iotcore.ca.policy.attach lamassu/aws-connector/${connector-id} io.lamassu.iotcore.cert.update-status aws/cloud-trail io.lamassu.iotcore.thing.config.request aws/lambda io.lamassu.ca.create { \"specversion\" : \"1.0\" , \"id\" : \"40492df26ca4d1e6:40492df26ca4d1e6:0000000000000000:1\" , \"source\" : \"lamassu/ca\" , \"type\" : \"io.lamassu.ca.create\" , \"datacontenttype\" : \"application/json\" , \"time\" : \"2022-03-31T06:52:13.207672275Z\" , \"data\" :{ \"name\" : \"CA1\" , \"serial_number\" : \"23-f9-3e-b0-9c-0e-f7-6b-1d-d9-0f-a2-22-47-93-45-23-53-f1-03\" , \"cert\" : \"LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUQyVENDQXNHZ0F3SUJBZ0lVSS9rK3NKd085MnNkMlEraUlrZVRSU05UOFFNd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1R6RUxNQWtHQTFVRUJoTUNSVk14RVRBUEJnTlZCQWdUQ0VkSlVGVmFTMDlCTVJFd0R3WURWUVFIRXdoQgpVbEpCVTBGVVJURU1NQW9HQTFVRUNoTURTVXRNTVF3d0NnWURWUVFERXdORFFURXdIaGNOTWpJd016TXhNRFkxCk1UUXpXaGNOTWpJd05qSXlNVFExTWpFeVdqQlBNUXN3Q1FZRFZRUUdFd0pGVXpFUk1BOEdBMVVFQ0JNSVIwbFEKVlZwTFQwRXhFVEFQQmdOVkJBY1RDRUZTVWtGVFFWUkZNUXd3Q2dZRFZRUUtFd05KUzB3eEREQUtCZ05WQkFNVApBME5CTVRDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTGkvRGthM3FaMTkwS1BoClp0YUV3cXkySFRaK1VUVkxYaWt6N0Vwcit0VHc2OHBDQUJTUEZXQW43Rm1STDU0Mjg0dHl1QjdxZlFKdjRFamIKb041U3FJbGpRS2NSMU1pY3czUlBKWWlhSDdkRDJNZXk5NEQ3SlhCYkNvQXBUaUxIcUMvbEFHT2g2dFZqNTFwaApXYlhWMVBsTzUxT3l4S2FIM1dtWmFSL0FubTdXMnNCbFVvdGRrZ1dVVmZCRG0vSEtOUHZQeDU1MkJpOHl1TjloCnk2Vzg3Y252OUNWYm9YcmJFSFBmUENBb09Fa01TUjFJU0NrRFVncXcwN1BqRUEzSTYxWmN2SWFDYkY3d2p1RkEKMUtueVRBWUR5UHlMbHJrOEJzcElCamF6Mm1BbTNTeld2N1FWRU1hWlVaUVZOU3NScEVoSGpQY0JRWko5Snp6bwppcS85aUwwQ0F3RUFBYU9CckRDQnFUQU9CZ05WSFE4QkFmOEVCQU1DQVFZd0R3WURWUjBUQVFIL0JBVXdBd0VCCi96QWRCZ05WSFE0RUZnUVV1Y01KUVROSG5Od2IvZEdPZ2hUTFVscEMzZFF3SHdZRFZSMGpCQmd3Rm9BVXVjTUoKUVROSG5Od2IvZEdPZ2hUTFVscEMzZFF3TmdZSUt3WUJCUVVIQVFFRUtqQW9NQ1lHQ0NzR0FRVUZCekFCaGhwbwpkSFJ3T2k4dlpHVjJMbXhoYldGemMzVXVhVzg2T1RBNU9EQU9CZ05WSFJFRUJ6QUZnZ05EUVRFd0RRWUpLb1pJCmh2Y05BUUVMQlFBRGdnRUJBSmszQUE3M3h0aU5QTzl1dTIvTDhGQUxNQXpaTzFKSmd0Tkxja2RBYzhXQnRLd0MKZHZtT1V1Q251R2tnQkhOZkJxMWRsTlNqaGVSL2g2a1dLYmdiK1hBczZRbTJGMUJURVA5Sitpc1dyaGgyQU5GYworVWxtT0FST2dSTkdGMEkyeFpaOUpEZFA0MUY4RXc0ODJyT3dpZFl2Q2tWa1p4RUFjRVA3Y2QyWmZpWnhhL0d6CjhPQ3psSUhVZTBTKzZJalVleC9rc2pzcDRrclFpMVZRYnFTT040ZTFLTVZyWUtLTzZHR3orNW0zUWtSZGVXUDQKM28rN2J5UDdtNEkvdm9wTUhzaWl0OWtwOFBMWWg4Q0RoelV2MzkyR2EzdXl6SDV4ZWUvdFhRT3ppdTlWRTV0agpPZHgyTHVtTUJoMzFuT09GUHorL3dCM3VIdEdvRHlKWXJDVGNYREE9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0=\" } } io.lamassu.ca.import { \"specversion\" : \"1.0\" , \"id\" : \"57cc9014a8021b01:57cc9014a8021b01:0000000000000000:1\" , \"source\" : \"lamassu/ca\" , \"type\" : \"io.lamassu.ca.import\" , \"datacontenttype\" : \"application/json\" , \"time\" : \"2022-03-31T07:06:34.265731829Z\" , \"data\" :{ \"name\" : \"CA2\" , \"serial_number\" : \"04-22-b1-ac-5a-3c-5d-f7-f8-8c-a5-cf-cb-e5-4a-d2-f5-df-f3-35\" , \"cert\" : \"LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURtekNDQW9PZ0F3SUJBZ0lVQkNLeHJGbzhYZmY0aktYUHkrVkswdlhmOHpVd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1hURUxNQWtHQTFVRUJoTUNSVk14RVRBUEJnTlZCQWdNQ0VkSlVGVmFTMDlCTVJFd0R3WURWUVFIREFoQgpVbEpCVTBGVVJURU1NQW9HQTFVRUNnd0RTVXRNTVF3d0NnWURWUVFMREFOYVVFUXhEREFLQmdOVkJBTU1BME5CCk1qQWVGdzB5TWpBek16RXdOalU1TlRWYUZ3MHlNekF6TXpFd05qVTVOVFZhTUYweEN6QUpCZ05WQkFZVEFrVlQKTVJFd0R3WURWUVFJREFoSFNWQlZXa3RQUVRFUk1BOEdBMVVFQnd3SVFWSlNRVk5CVkVVeEREQUtCZ05WQkFvTQpBMGxMVERFTU1Bb0dBMVVFQ3d3RFdsQkVNUXd3Q2dZRFZRUUREQU5EUVRJd2dnRWlNQTBHQ1NxR1NJYjNEUUVCCkFRVUFBNElCRHdBd2dnRUtBb0lCQVFETWFUOWo0bHB4RzdHVjRKdkRyMnFGWXNPUkpVN083cWUxd2k2SzNCZmIKZk4ySWw1dDdGK2tSc25BWnFnM3R3T25Hb1Q2czZVZUhZc1hxTDJzMURlbUZzM3dtRGFhZUJJVldzRlZUKzV1WQpYWWZaZVVBdC9FRStWMWRXaFdwcUtHYk9LeWhFcVQ1Rm1jU2psTitQeUpkV1RVSEFZcUtNcTZPSnJmdFFIMUtJCnFoazZseVFRTzNla3RwZXBCWUxjSU8yazg3Rm5WZ0o5RWFlektmUG1EVDRXaitMOUNmb1pZTnFSOTNjcFM1ZzEKMWRYenl5ZUEvV3Zmbk5vdm5rbDdFQk9oNHI0NFhVOFVWbWkrUWtqQWdyTklpRlRIUHp4OGtpS0dvVkZDQ1A3OQo4Y0NzM1JxTVJhYk9BdENOemFWRzdnNXNlRVJLOXVOMk1vY1FuWkdKQzF4REFnTUJBQUdqVXpCUk1CMEdBMVVkCkRnUVdCQlJacFhvRThBSE9HL0tMVkhDU3hmZ2xsOEl3TVRBZkJnTlZIU01FR0RBV2dCUlpwWG9FOEFIT0cvS0wKVkhDU3hmZ2xsOEl3TVRBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFCVAp4akQzcjd6L3dQVHBFbUdnN25xd3hoRXB3cHJjMDR1VWxFUjRFdUl4UlVWSjh0TDNnRzdrbVBhK0RsbHpVdkl1ClhNWlpFMUJwck9QbTYzb3V4cThJb0dXZW5DYWIzUU95V1o2YTBPcllXNmJYcnROdzJuTFdKd2UvbGM1a0ViTnYKNjdNVmM4emovcFY5TXFuTmxsMWc2THN3V0kreFBqaXNqSFl5MnlMVGlRcHk2WC8yK3B1VDZHRHBIK3pCenRUagpqVTh3Um1WZWloeHFZNTBrVGcreGRmaUE0OWhMM3VkcHRmU0VXd1BSQW9zUHVTT1NTTndHM1ZGQjAvcjRTWWROCjE1TWM3SEpuMlR3OEttbkRYMTVzL3hYMWROaW51RmVZMklCUzQzZkZmT1Viczd5SXc1eFF3a0JjMm5PQVlJdDgKSUhtQm1MRVArWktmNms5Q1JIc2kKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQ==\" } } io.lamassu.ca.update { \"specversion\" : \"1.0\" , \"id\" : \"208e73dd2a283350:208e73dd2a283350:0000000000000000:1\" , \"source\" : \"lamassu/ca\" , \"type\" : \"io.lamassu.ca.update\" , \"datacontenttype\" : \"application/json\" , \"time\" : \"2022-03-31T07:10:55.371676082Z\" , \"data\" :{ \"name\" : \"CA2\" , \"status\" : \"REVOKED\" } } io.lamassu.cert.update { \"specversion\" : \"1.0\" , \"id\" : \"0814bee304159b19:0814bee304159b19:0000000000000000:1\" , \"source\" : \"lamassu/ca\" , \"type\" : \"io.lamassu.cert.update\" , \"datacontenttype\" : \"application/json\" , \"time\" : \"2022-03-31T07:17:36.907957488Z\" , \"data\" :{ \"name\" : \"CA2\" , \"status\" : \"REVOKED\" , \"serial_number\" : \"23-f9-3e-b0-9c-0e-f7-6b-1d-d9-0f-a2-22-47-93-45-23-53-f1-03\" } } io.lamassu.iotcore.thing.config.response { \"specversion\" : \"1.0\" , \"id\" : \"8308f9c3-4f08-44a3-9b1d-49818447b6b1\" , \"source\" : \"aws/lambda\" , \"type\" : \"io.lamassu.iotcore.thing.config.response\" , \"time\" : \"2022-04-04T11:33:36Z\" , \"data\" :[ { \"aws_id\" : \"b92c131c-7017-4f54-971c-2b12138a46bf\" , \"device_id\" : \"796786f3-eea5-4cd8-bf9e-9aae738b4176\" , \"last_connection\" : null , \"certificates\" :[ { \"status\" : \"ACTIVE\" , \"arn\" : \"arn:aws:iot:eu-west-1:345876576284:cert/3d5621f7822da199cfa20dfb89f36e7d4d7cba915a61952202fb57428dd0a48c\" , \"id\" : \"3d5621f7822da199cfa20dfb89f36e7d4d7cba915a61952202fb57428dd0a48c\" , \"update_date\" : \"2022-03-31T11:58:28.405Z\" } ] }, { \"aws_id\" : \"e324c233-54de-4783-9bff-528b02eae499\" , \"device_id\" : \"51809c2a-0429-4719-9ede-8a0336c07532\" , \"last_connection\" : null , \"certificates\" :[ { \"status\" : \"REVOKED\" , \"arn\" : \"arn:aws:iot:eu-west-1:345876576284:cert/b749a584b26e74662ea529bb58caadec96e822e6d436a7237a0ff5805e971563\" , \"id\" : \"b749a584b26e74662ea529bb58caadec96e822e6d436a7237a0ff5805e971563\" , \"update_date\" : \"2022-03-29T16:37:18.527Z\" } ] } ] } Azure Services used by Lamassu For further detail, see Azure Services used by Lamassu Azure functions Azure storage queue Azure DPS Azure Iot Hub References Cloud Events web page: Cloud events Cloud Events github: Cloud events GITHUB Clud Events SDK for Go: Cloud Events SDK for GO Gokit, building microservices in go: (Gokit)","title":"Extending Lamassu"},{"location":"extension/#extending-lamassu","text":"A PKI has three types of core compoents: CAs , RAs and VAs . Each PKI implementation must have an instance of those compoennts (at least) to be considered a mature digital identity provider. Certificate authority (CA) - Issues an entity's certificate and acts as a trusted component within a private PKI. Any certificate issued by the CA is trusted by all entities that trust the CA. The exact role of a CA will depend on its position within a CA hierarchy. Registration authority (RA) - Receives certificate signing requests and verifies the identity of an end entity. The RA will approve a request before the certificate can be issued by the CA. This is a very important stage of the process and it often involves a procedure to enrol end entities into the PKI. Validation authority (VA) - A VA allows an entity to check that a certificate has not been revoked. The VA role is often carried out by an online facility hosted by an organisation who operates the PKI. A validation authority will often use OCSP or CRL to advertise revoked certificates. Lamassu is no stranger to those concepts. In fact, Lamassu goes one step further by implementing LRAs or Local Registration Authorities also named DMSs. Local registration authority (LRA) - is an optional part of a public key infrastructure that maintains users' identities from which certification authorities can issue Digital Certificates. Extending the PKI is a core principal for Lamassu. There are multiple ways to customize Lamassu to the required needs by just modifying one of the core components or by developing and adding new ones. This section will describe some decissions that have been addopted to provide an extensible PKI that is able to integrate with some cloud providers such as AWS IoT Core or Azure IoT Hub .","title":"Extending Lamassu"},{"location":"extension/#rabbit-mq","text":"RabbitMQ serves as an intermediary for efficient communication between Lamassu UI and Cloud-Proxy. The messages are published to broker's queue via amqp (Advanced Message Queuing Protocol).","title":"Rabbit MQ"},{"location":"extension/#cloud-proxy","text":"A proxy server acts as a gateway between you and the internet, and verifies and forwards incoming client requests to other servers for further communication.","title":"Cloud Proxy"},{"location":"extension/#aws-services-used-by-lamassu","text":"For further detail, see AWS Services used by Lamassu AWS SQS AWS Lambda AWS IoT Core AWS Cloud Formation","title":"AWS Services used by Lamassu"},{"location":"extension/#infraestructure-deployment","text":"To deploy the structure in AWS to proper function with Lamassu, AWS CDK is used. The AWS Cloud Development Kit (AWS CDK) is an open-source software development framework to define your cloud application resources using familiar programming languages.","title":"Infraestructure Deployment"},{"location":"extension/#directory-layout","text":"/bin/lamassu-cdk.ts app entry point. It creates objects of classes defined in /lib. /lib it contains all the stacks for our project, were AWS resources are defined. cdk.json file tells the CDK Toolkit how to execute your app.","title":"Directory layout"},{"location":"extension/#prerequisites","text":"Install nodejs 14.X, npm and jq. sudo apt install jq nodejs npm Install aws-cdk with npm: npm install -g aws-cdk@1.x Verify cdk is installed: cdk --version Install AWS cli and configure credentials: Install AWS CLI: https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html Configure AWS CLI: aws configure Provide your AWS access key ID, secret access key, and default region when prompted. You can also configure .aws/credentials file in your home directory instead.","title":"Prerequisites"},{"location":"extension/#usage","text":"NOTE : As some AWS features used in this project are still not implemented in AWS CDK, some of the steps are done via CLI. Go to cdk project home directory: cd lamassu-cdk Option 1 : Execute deploy script: bash deploy-lamassu.sh Option 2 : Execute it step by step: npm i npm i --prefix resources/sqsFilterLambda cdk deploy --outputs-file outputs.json aws lambda update-event-source-mapping --uuid $(cat outputs.json | jq -r .LamassuCdkStack.EventSourceMappingUUID) --filter-criteria file://filter-criteria.json Remove Lamassu resources: cdk destroy LamassuCdkStack","title":"Usage"},{"location":"extension/#useful-commands","text":"npm run build compile typescript to js npm run watch watch for changes and compile npm run test perform the jest unit tests cdk deploy deploy this stack to your default AWS account/region cdk diff compare deployed stack with current state cdk synth emits the synthesized CloudFormation template","title":"Useful commands"},{"location":"extension/#configuring-aws-connector","text":"","title":"Configuring AWS connector"},{"location":"extension/#prerequisites_1","text":"Option 1 : Install go. (Go installation guide) Option 2 : run the AWS connector in Docker. (Docker installation guide)","title":"Prerequisites"},{"location":"extension/#usage_1","text":"Needed environment variables: # AWS credentials AWS_ACCESS_KEY_ID= AWS_SECRET_ACCESS_KEY= AWS_DEFAULT_REGION= # AWS ATS root certificate AWS_CA_BUNDLE=awsRootCA.pem # RabbitMQ configuration: port, host and certificates AMQP_PORT=5671 AMQP_HOST=dev-lamassu.zpd.ikerlan.es AMQP_SERVER_CA_CERT=/ca.crt AMQP_CLIENT_CERT=/tls.crt AMQP_CLIENT_KEY=/tls.key # Lamassu CA configuration LAMASSU_CA_ADDRESS=https://lamassu-ca:8087 LAMASSU_CA_CERT_FILE=//ca.crt LAMASSU_CA_CLIENT_CERT_FILE=tls.crt LAMASSU_CA_CLIENT_KEY_FILE=tls.key # Consul configuration CONSUL_PROTOCOL=https CONSUL_HOST=consul-server CONSUL_PORT=8501 CONSUL_CA=/ca.crt # AWS Connector configuration CONNECTOR_PORT=8989 CONNECTOR_TYPE=aws CONNECTOR_PROTOCOL=http CONNECTOR_NAME=aws-connector-ikerlan # Configuration for jaeger tracing JAEGER_SERVICE_NAME=aws-connector JAEGER_AGENT_HOST=jaeger JAEGER_AGENT_PORT=\"6831\" JAEGER_SAMPLER_TYPE=const JAEGER_SAMPLER_PARAM=\"1\" JAEGER_REPORTER_LOG_SPANS=\"false\" Remember to change env variables depending where you run AWS connector Option 1 : Running AWS Connector cd aws-connector go run cmd/main.go Option 2 : Running the connector on Docker: cd aws-connector docker-compose up -d *NOTE *: It is better to run it on Docker.","title":"Usage"},{"location":"extension/#cloud-events","text":"To extend Lamassu to AWS cloud, whenever a opperation is triggered, an asynchronous messages are send via Amazon Simple Queue Service. Amazon SQS offers the possibility of establishing a message queue to store messages while they wait to be processed by different computers that are connected to the Internet. These messages can contain notifications for applications or lists of commands to be executed by applications, either in the cloud or on the Internet, allowing you to create automated workflows. The messages arrive at AWS cloud via lamassu-aws-connector . The connector uses two queues, one for request lamassu-command and another for responses, lamassu-response . Whenever the connector receives a message, an event-driven compute service, AWS Lambda, mappes the operation to the corresponding lambda . AWS is a serverless, event-driven compute service that lets you run code for virtually any type of application or backend service without provisioning or managing servers. The Lambda will communicate with AWS IoT Core . Event Type Source Description io.lamassu.ca.create lamassu/ca io.lamassu.ca.import lamassu/ca io.lamassu.ca.update lamassu/ca io.lamassu.cert.update lamassu/ca io.lamassu.iotcore.config.request lamassu/aws-connector/${connector-id} io.lamassu.iotcore.config.response aws/lambda io.lamassu.iotcore.ca.registration.request-code lamassu/aws-connector/${connector-id} io.lamassu.iotcore.ca.registration.response-code aws/lambda io.lamassu.iotcore.ca.registration.signed-code lamassu/aws-connector/${connector-id} io.lamassu.iotcore.ca.policy.attach lamassu/aws-connector/${connector-id} io.lamassu.iotcore.cert.update-status aws/cloud-trail io.lamassu.iotcore.thing.config.request aws/lambda","title":"Cloud-Events"},{"location":"extension/#iolamassucacreate","text":"{ \"specversion\" : \"1.0\" , \"id\" : \"40492df26ca4d1e6:40492df26ca4d1e6:0000000000000000:1\" , \"source\" : \"lamassu/ca\" , \"type\" : \"io.lamassu.ca.create\" , \"datacontenttype\" : \"application/json\" , \"time\" : \"2022-03-31T06:52:13.207672275Z\" , \"data\" :{ \"name\" : \"CA1\" , \"serial_number\" : \"23-f9-3e-b0-9c-0e-f7-6b-1d-d9-0f-a2-22-47-93-45-23-53-f1-03\" , \"cert\" : \"LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUQyVENDQXNHZ0F3SUJBZ0lVSS9rK3NKd085MnNkMlEraUlrZVRSU05UOFFNd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1R6RUxNQWtHQTFVRUJoTUNSVk14RVRBUEJnTlZCQWdUQ0VkSlVGVmFTMDlCTVJFd0R3WURWUVFIRXdoQgpVbEpCVTBGVVJURU1NQW9HQTFVRUNoTURTVXRNTVF3d0NnWURWUVFERXdORFFURXdIaGNOTWpJd016TXhNRFkxCk1UUXpXaGNOTWpJd05qSXlNVFExTWpFeVdqQlBNUXN3Q1FZRFZRUUdFd0pGVXpFUk1BOEdBMVVFQ0JNSVIwbFEKVlZwTFQwRXhFVEFQQmdOVkJBY1RDRUZTVWtGVFFWUkZNUXd3Q2dZRFZRUUtFd05KUzB3eEREQUtCZ05WQkFNVApBME5CTVRDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTGkvRGthM3FaMTkwS1BoClp0YUV3cXkySFRaK1VUVkxYaWt6N0Vwcit0VHc2OHBDQUJTUEZXQW43Rm1STDU0Mjg0dHl1QjdxZlFKdjRFamIKb041U3FJbGpRS2NSMU1pY3czUlBKWWlhSDdkRDJNZXk5NEQ3SlhCYkNvQXBUaUxIcUMvbEFHT2g2dFZqNTFwaApXYlhWMVBsTzUxT3l4S2FIM1dtWmFSL0FubTdXMnNCbFVvdGRrZ1dVVmZCRG0vSEtOUHZQeDU1MkJpOHl1TjloCnk2Vzg3Y252OUNWYm9YcmJFSFBmUENBb09Fa01TUjFJU0NrRFVncXcwN1BqRUEzSTYxWmN2SWFDYkY3d2p1RkEKMUtueVRBWUR5UHlMbHJrOEJzcElCamF6Mm1BbTNTeld2N1FWRU1hWlVaUVZOU3NScEVoSGpQY0JRWko5Snp6bwppcS85aUwwQ0F3RUFBYU9CckRDQnFUQU9CZ05WSFE4QkFmOEVCQU1DQVFZd0R3WURWUjBUQVFIL0JBVXdBd0VCCi96QWRCZ05WSFE0RUZnUVV1Y01KUVROSG5Od2IvZEdPZ2hUTFVscEMzZFF3SHdZRFZSMGpCQmd3Rm9BVXVjTUoKUVROSG5Od2IvZEdPZ2hUTFVscEMzZFF3TmdZSUt3WUJCUVVIQVFFRUtqQW9NQ1lHQ0NzR0FRVUZCekFCaGhwbwpkSFJ3T2k4dlpHVjJMbXhoYldGemMzVXVhVzg2T1RBNU9EQU9CZ05WSFJFRUJ6QUZnZ05EUVRFd0RRWUpLb1pJCmh2Y05BUUVMQlFBRGdnRUJBSmszQUE3M3h0aU5QTzl1dTIvTDhGQUxNQXpaTzFKSmd0Tkxja2RBYzhXQnRLd0MKZHZtT1V1Q251R2tnQkhOZkJxMWRsTlNqaGVSL2g2a1dLYmdiK1hBczZRbTJGMUJURVA5Sitpc1dyaGgyQU5GYworVWxtT0FST2dSTkdGMEkyeFpaOUpEZFA0MUY4RXc0ODJyT3dpZFl2Q2tWa1p4RUFjRVA3Y2QyWmZpWnhhL0d6CjhPQ3psSUhVZTBTKzZJalVleC9rc2pzcDRrclFpMVZRYnFTT040ZTFLTVZyWUtLTzZHR3orNW0zUWtSZGVXUDQKM28rN2J5UDdtNEkvdm9wTUhzaWl0OWtwOFBMWWg4Q0RoelV2MzkyR2EzdXl6SDV4ZWUvdFhRT3ppdTlWRTV0agpPZHgyTHVtTUJoMzFuT09GUHorL3dCM3VIdEdvRHlKWXJDVGNYREE9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0=\" } }","title":"io.lamassu.ca.create"},{"location":"extension/#iolamassucaimport","text":"{ \"specversion\" : \"1.0\" , \"id\" : \"57cc9014a8021b01:57cc9014a8021b01:0000000000000000:1\" , \"source\" : \"lamassu/ca\" , \"type\" : \"io.lamassu.ca.import\" , \"datacontenttype\" : \"application/json\" , \"time\" : \"2022-03-31T07:06:34.265731829Z\" , \"data\" :{ \"name\" : \"CA2\" , \"serial_number\" : \"04-22-b1-ac-5a-3c-5d-f7-f8-8c-a5-cf-cb-e5-4a-d2-f5-df-f3-35\" , \"cert\" : \"LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURtekNDQW9PZ0F3SUJBZ0lVQkNLeHJGbzhYZmY0aktYUHkrVkswdlhmOHpVd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1hURUxNQWtHQTFVRUJoTUNSVk14RVRBUEJnTlZCQWdNQ0VkSlVGVmFTMDlCTVJFd0R3WURWUVFIREFoQgpVbEpCVTBGVVJURU1NQW9HQTFVRUNnd0RTVXRNTVF3d0NnWURWUVFMREFOYVVFUXhEREFLQmdOVkJBTU1BME5CCk1qQWVGdzB5TWpBek16RXdOalU1TlRWYUZ3MHlNekF6TXpFd05qVTVOVFZhTUYweEN6QUpCZ05WQkFZVEFrVlQKTVJFd0R3WURWUVFJREFoSFNWQlZXa3RQUVRFUk1BOEdBMVVFQnd3SVFWSlNRVk5CVkVVeEREQUtCZ05WQkFvTQpBMGxMVERFTU1Bb0dBMVVFQ3d3RFdsQkVNUXd3Q2dZRFZRUUREQU5EUVRJd2dnRWlNQTBHQ1NxR1NJYjNEUUVCCkFRVUFBNElCRHdBd2dnRUtBb0lCQVFETWFUOWo0bHB4RzdHVjRKdkRyMnFGWXNPUkpVN083cWUxd2k2SzNCZmIKZk4ySWw1dDdGK2tSc25BWnFnM3R3T25Hb1Q2czZVZUhZc1hxTDJzMURlbUZzM3dtRGFhZUJJVldzRlZUKzV1WQpYWWZaZVVBdC9FRStWMWRXaFdwcUtHYk9LeWhFcVQ1Rm1jU2psTitQeUpkV1RVSEFZcUtNcTZPSnJmdFFIMUtJCnFoazZseVFRTzNla3RwZXBCWUxjSU8yazg3Rm5WZ0o5RWFlektmUG1EVDRXaitMOUNmb1pZTnFSOTNjcFM1ZzEKMWRYenl5ZUEvV3Zmbk5vdm5rbDdFQk9oNHI0NFhVOFVWbWkrUWtqQWdyTklpRlRIUHp4OGtpS0dvVkZDQ1A3OQo4Y0NzM1JxTVJhYk9BdENOemFWRzdnNXNlRVJLOXVOMk1vY1FuWkdKQzF4REFnTUJBQUdqVXpCUk1CMEdBMVVkCkRnUVdCQlJacFhvRThBSE9HL0tMVkhDU3hmZ2xsOEl3TVRBZkJnTlZIU01FR0RBV2dCUlpwWG9FOEFIT0cvS0wKVkhDU3hmZ2xsOEl3TVRBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFCVAp4akQzcjd6L3dQVHBFbUdnN25xd3hoRXB3cHJjMDR1VWxFUjRFdUl4UlVWSjh0TDNnRzdrbVBhK0RsbHpVdkl1ClhNWlpFMUJwck9QbTYzb3V4cThJb0dXZW5DYWIzUU95V1o2YTBPcllXNmJYcnROdzJuTFdKd2UvbGM1a0ViTnYKNjdNVmM4emovcFY5TXFuTmxsMWc2THN3V0kreFBqaXNqSFl5MnlMVGlRcHk2WC8yK3B1VDZHRHBIK3pCenRUagpqVTh3Um1WZWloeHFZNTBrVGcreGRmaUE0OWhMM3VkcHRmU0VXd1BSQW9zUHVTT1NTTndHM1ZGQjAvcjRTWWROCjE1TWM3SEpuMlR3OEttbkRYMTVzL3hYMWROaW51RmVZMklCUzQzZkZmT1Viczd5SXc1eFF3a0JjMm5PQVlJdDgKSUhtQm1MRVArWktmNms5Q1JIc2kKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQ==\" } }","title":"io.lamassu.ca.import"},{"location":"extension/#iolamassucaupdate","text":"{ \"specversion\" : \"1.0\" , \"id\" : \"208e73dd2a283350:208e73dd2a283350:0000000000000000:1\" , \"source\" : \"lamassu/ca\" , \"type\" : \"io.lamassu.ca.update\" , \"datacontenttype\" : \"application/json\" , \"time\" : \"2022-03-31T07:10:55.371676082Z\" , \"data\" :{ \"name\" : \"CA2\" , \"status\" : \"REVOKED\" } }","title":"io.lamassu.ca.update"},{"location":"extension/#iolamassucertupdate","text":"{ \"specversion\" : \"1.0\" , \"id\" : \"0814bee304159b19:0814bee304159b19:0000000000000000:1\" , \"source\" : \"lamassu/ca\" , \"type\" : \"io.lamassu.cert.update\" , \"datacontenttype\" : \"application/json\" , \"time\" : \"2022-03-31T07:17:36.907957488Z\" , \"data\" :{ \"name\" : \"CA2\" , \"status\" : \"REVOKED\" , \"serial_number\" : \"23-f9-3e-b0-9c-0e-f7-6b-1d-d9-0f-a2-22-47-93-45-23-53-f1-03\" } }","title":"io.lamassu.cert.update"},{"location":"extension/#iolamassuiotcorethingconfigresponse","text":"{ \"specversion\" : \"1.0\" , \"id\" : \"8308f9c3-4f08-44a3-9b1d-49818447b6b1\" , \"source\" : \"aws/lambda\" , \"type\" : \"io.lamassu.iotcore.thing.config.response\" , \"time\" : \"2022-04-04T11:33:36Z\" , \"data\" :[ { \"aws_id\" : \"b92c131c-7017-4f54-971c-2b12138a46bf\" , \"device_id\" : \"796786f3-eea5-4cd8-bf9e-9aae738b4176\" , \"last_connection\" : null , \"certificates\" :[ { \"status\" : \"ACTIVE\" , \"arn\" : \"arn:aws:iot:eu-west-1:345876576284:cert/3d5621f7822da199cfa20dfb89f36e7d4d7cba915a61952202fb57428dd0a48c\" , \"id\" : \"3d5621f7822da199cfa20dfb89f36e7d4d7cba915a61952202fb57428dd0a48c\" , \"update_date\" : \"2022-03-31T11:58:28.405Z\" } ] }, { \"aws_id\" : \"e324c233-54de-4783-9bff-528b02eae499\" , \"device_id\" : \"51809c2a-0429-4719-9ede-8a0336c07532\" , \"last_connection\" : null , \"certificates\" :[ { \"status\" : \"REVOKED\" , \"arn\" : \"arn:aws:iot:eu-west-1:345876576284:cert/b749a584b26e74662ea529bb58caadec96e822e6d436a7237a0ff5805e971563\" , \"id\" : \"b749a584b26e74662ea529bb58caadec96e822e6d436a7237a0ff5805e971563\" , \"update_date\" : \"2022-03-29T16:37:18.527Z\" } ] } ] }","title":"io.lamassu.iotcore.thing.config.response"},{"location":"extension/#azure-services-used-by-lamassu","text":"For further detail, see Azure Services used by Lamassu Azure functions Azure storage queue Azure DPS Azure Iot Hub","title":"Azure Services used by Lamassu"},{"location":"extension/#references","text":"Cloud Events web page: Cloud events Cloud Events github: Cloud events GITHUB Clud Events SDK for Go: Cloud Events SDK for GO Gokit, building microservices in go: (Gokit)","title":"References"},{"location":"manage/","text":"Managing Lamassu Certificate rotation By default, all self-signed certificates (both upstream and downstream) have a lifespan of 365 days. At that point it will be necessary to regenerate the expired certificates: Regenerate the certificates: cd tls-certificates ./gen-upstream-certs.sh ./gen-downstream-certs.sh cd .. Reboot all services: docker-compose down docker-compose up -d Backup strategy Restoring backups","title":"Managing Lamassu"},{"location":"manage/#managing-lamassu","text":"","title":"Managing Lamassu"},{"location":"manage/#certificate-rotation","text":"By default, all self-signed certificates (both upstream and downstream) have a lifespan of 365 days. At that point it will be necessary to regenerate the expired certificates: Regenerate the certificates: cd tls-certificates ./gen-upstream-certs.sh ./gen-downstream-certs.sh cd .. Reboot all services: docker-compose down docker-compose up -d","title":"Certificate rotation"},{"location":"manage/#backup-strategy","text":"","title":"Backup strategy"},{"location":"manage/#restoring-backups","text":"","title":"Restoring backups"},{"location":"protocols/","text":"Protocols Lamassu supports a set of standards to perform some of its key functionalities such as enrolling devices as well as validating the status of a given certificate. This section aims to describe those protocols as well as explaining how them with practical examples. OCSP The Online Certificate Status Protocol or OCSP for short, is a protocol used to determine the current status of a digital certificate without requiring the use of Certificate Revocation Lists (CRLs). As defined by the standard, there are two possible methods that can be used to perform the http request: Method Path Headers Body payload Used when GET {url}/{url-encoding of base-64 encoding of the DER encoding of the OCSPRequest} Recommended when the encoded request is less than 255 bytes PUT {url} Content-Type: application/ocsp-request Binary value of the DER encoding of the OCSPRequest Can always be used GET Request OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request OCSP_REQUEST=$(openssl ocsp -CAfile $CA_CERTIFICATE -issuer $CA_CERTIFICATE -cert $DEVICE_CERTIFICATE -reqout - | base64 -w 0) Check the status of the certificate curl --location --request GET \"https://$OCSP_SERVER/api/ocsp/$OCSP_REQUEST\" > ocspresponse.der openssl ocsp -respin ocspresponse.der -VAfile root-ca.pem -resp_text package main import ( \"crypto/x509\" \"encoding/base64\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } encodedRequest := base64 . StdEncoding . EncodeToString ( ocspRequestBytes ) fmt . Println ( encodedRequest ) reqURL := ocspServer + \"/\" + encodedRequest resp , err := http . Get ( reqURL ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) } POST Request OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request openssl ocsp -issuer ca.crt -cert dev.crt -reqout - > ocsp-request-post.der Check the status of the certificate curl --location --request POST \"https://$DOMAIN/api/ocsp/\" --header 'Content-Type: application/ocsp-request' --data-binary '@ocsp-request-post.der' > ocsp-response-post.der -k openssl ocsp -respin ocsp-response-post.der -VAfile root-ca.pem -resp_text package main import ( \"bytes\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } resp , err := http . Post ( ocspServer , \"application/ocsp-request\" , bytes . NewReader ( ocspRequestBytes )) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) } EST The core mechanism to obtain valid certificates for your devices is using the enrollment process described by the EST protocol. EST or Enrollment over Secure Transport establishes a set of standardized endpoints. The following table sums up all endpoints defined by the EST protocol and wether or not are supported by the current implementation. Operation Operation Path Required by RFC7030 Supported Distribution of CA Certificates /api/devmanager/.well-known/cacerts Enrollment of Clients /api/devmanager/.well-known/simpleenroll Re-enrollment of Clients /api/devmanager/.well-known/simplereenroll Full CMC /api/devmanager/.well-known/fullcmc Server-Side Key Generation /api/devmanager/.well-known/serverkeygen CSR Attributes /api/devmanager/.well-known/csrattrs Distribution of CA Certificates GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates estclient cacerts -server $DOMAIN/api/devmanager -explicit root-ca.pem -out cacerts.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" clientcrt := \"dms.crt\" clientkey := \"dms.key\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( clientcrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( clientkey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cas , err := estClient . CACerts ( context . Background ()) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } } Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates curl https://$DOMAIN/api/devmanager/.well-known/est/cacerts -o cacerts.p7 --cacert root-ca.pem openssl base64 -d -in cacerts.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cacerts.pem Enrollment of Devices GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with an existing private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient enroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out cert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecsr := \"device.csr\" devicecrt := \"device.crt\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Enroll ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with an existing private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/simpleenroll --cert $DMS_CRT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cert.pem Re-enrollment of Devices GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Reenrolling estclient reenroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -key $DEVICE_KEY -certs $DEVICE_CRT -out newcert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( devicecrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( devicekey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Reenroll ( context . Background (), csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key exprot DEVICE_CSR=device.csr Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device enroll CSR sed '/CERTIFICATE/d' device.csr > device_enroll.csr Reenrolling curl https://$DOMAIN/api/devmanager/.well-known/est/simplereenroll --cert $DEVICE_CRT --key $DEVICE_KEY -s -o newcert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in newcert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out $DEVICE_CRT Server Key Generation of Devices GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with a server-generated private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient serverkeygen -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out device.crt -keyout device.key package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , key , err := estClient . ServerKeyGen ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) b = pem . Block { Type : \"PRIVATE KEY\" , Bytes : key } keyPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicekey , keyPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with a server-generated private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/serverkeygen --cert $DMS_CERT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" cat cert.p7 | sed -ne '/application\\/pkcs7-mime/,/-estServerKeyGenBoundary/p' | sed '/-/d' > crt.p7 openssl base64 -d -in crt.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device.pem https://datatracker.ietf.org/doc/html/rfc7030","title":"Protocols"},{"location":"protocols/#protocols","text":"Lamassu supports a set of standards to perform some of its key functionalities such as enrolling devices as well as validating the status of a given certificate. This section aims to describe those protocols as well as explaining how them with practical examples.","title":"Protocols"},{"location":"protocols/#ocsp","text":"The Online Certificate Status Protocol or OCSP for short, is a protocol used to determine the current status of a digital certificate without requiring the use of Certificate Revocation Lists (CRLs). As defined by the standard, there are two possible methods that can be used to perform the http request: Method Path Headers Body payload Used when GET {url}/{url-encoding of base-64 encoding of the DER encoding of the OCSPRequest} Recommended when the encoded request is less than 255 bytes PUT {url} Content-Type: application/ocsp-request Binary value of the DER encoding of the OCSPRequest Can always be used","title":"OCSP"},{"location":"protocols/#get-request","text":"OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request OCSP_REQUEST=$(openssl ocsp -CAfile $CA_CERTIFICATE -issuer $CA_CERTIFICATE -cert $DEVICE_CERTIFICATE -reqout - | base64 -w 0) Check the status of the certificate curl --location --request GET \"https://$OCSP_SERVER/api/ocsp/$OCSP_REQUEST\" > ocspresponse.der openssl ocsp -respin ocspresponse.der -VAfile root-ca.pem -resp_text package main import ( \"crypto/x509\" \"encoding/base64\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } encodedRequest := base64 . StdEncoding . EncodeToString ( ocspRequestBytes ) fmt . Println ( encodedRequest ) reqURL := ocspServer + \"/\" + encodedRequest resp , err := http . Get ( reqURL ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) }","title":"GET Request"},{"location":"protocols/#post-request","text":"OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request openssl ocsp -issuer ca.crt -cert dev.crt -reqout - > ocsp-request-post.der Check the status of the certificate curl --location --request POST \"https://$DOMAIN/api/ocsp/\" --header 'Content-Type: application/ocsp-request' --data-binary '@ocsp-request-post.der' > ocsp-response-post.der -k openssl ocsp -respin ocsp-response-post.der -VAfile root-ca.pem -resp_text package main import ( \"bytes\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } resp , err := http . Post ( ocspServer , \"application/ocsp-request\" , bytes . NewReader ( ocspRequestBytes )) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) }","title":"POST Request"},{"location":"protocols/#est","text":"The core mechanism to obtain valid certificates for your devices is using the enrollment process described by the EST protocol. EST or Enrollment over Secure Transport establishes a set of standardized endpoints. The following table sums up all endpoints defined by the EST protocol and wether or not are supported by the current implementation. Operation Operation Path Required by RFC7030 Supported Distribution of CA Certificates /api/devmanager/.well-known/cacerts Enrollment of Clients /api/devmanager/.well-known/simpleenroll Re-enrollment of Clients /api/devmanager/.well-known/simplereenroll Full CMC /api/devmanager/.well-known/fullcmc Server-Side Key Generation /api/devmanager/.well-known/serverkeygen CSR Attributes /api/devmanager/.well-known/csrattrs","title":"EST"},{"location":"protocols/#distribution-of-ca-certificates","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates estclient cacerts -server $DOMAIN/api/devmanager -explicit root-ca.pem -out cacerts.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" clientcrt := \"dms.crt\" clientkey := \"dms.key\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( clientcrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( clientkey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cas , err := estClient . CACerts ( context . Background ()) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } } Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates curl https://$DOMAIN/api/devmanager/.well-known/est/cacerts -o cacerts.p7 --cacert root-ca.pem openssl base64 -d -in cacerts.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cacerts.pem","title":"Distribution of CA Certificates"},{"location":"protocols/#enrollment-of-devices","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with an existing private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient enroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out cert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecsr := \"device.csr\" devicecrt := \"device.crt\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Enroll ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with an existing private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/simpleenroll --cert $DMS_CRT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cert.pem","title":"Enrollment of Devices"},{"location":"protocols/#re-enrollment-of-devices","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Reenrolling estclient reenroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -key $DEVICE_KEY -certs $DEVICE_CRT -out newcert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( devicecrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( devicekey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Reenroll ( context . Background (), csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key exprot DEVICE_CSR=device.csr Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device enroll CSR sed '/CERTIFICATE/d' device.csr > device_enroll.csr Reenrolling curl https://$DOMAIN/api/devmanager/.well-known/est/simplereenroll --cert $DEVICE_CRT --key $DEVICE_KEY -s -o newcert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in newcert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out $DEVICE_CRT","title":"Re-enrollment of Devices"},{"location":"protocols/#server-key-generation-of-devices","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with a server-generated private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient serverkeygen -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out device.crt -keyout device.key package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , key , err := estClient . ServerKeyGen ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) b = pem . Block { Type : \"PRIVATE KEY\" , Bytes : key } keyPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicekey , keyPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with a server-generated private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/serverkeygen --cert $DMS_CERT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" cat cert.p7 | sed -ne '/application\\/pkcs7-mime/,/-estServerKeyGenBoundary/p' | sed '/-/d' > crt.p7 openssl base64 -d -in crt.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device.pem https://datatracker.ietf.org/doc/html/rfc7030","title":"Server Key Generation of Devices"},{"location":"setup/","text":"Install Lamassu Compose Lamassu Compose is the official release containing the scripts and resources required to deploy all microservices such as the CA component, the VA component or the RA components to name a few. Architecture Lamassu Compose offers a SECURE deployment of the set of microservices required to manage an industrial PKI. The architecture presented on the following image reflects the interconnection of the different services mainly using the HTTP Protocol. The use of this deployment offers the following non functional requirements by leveraging the use of an API Gateway: Centralized point of access : Each microservice listens on a different port which ends up being challenging for developers and users. With the use of the API Gateway, the user will always access the same host and port address. Port 80 for HTTP connections and port 443 for HTTPS connections. Authentication : In order to invoke any endpoint, the API Gateway enforces each request to present a JWT. Upon receiving an HTTP request, the gateway validates the presented token against the authentication server. Authorization : Another key aspect is enforcing an authorization schema. Lamassu has been configured in such way that only specific endpoints are accessible by non admin users. Tracing : Logging the life of an HTTP request can be helpful during the debugging process of such complex application. The tracing aspect eases this process by injecting a unique identifier to each request that is then printed out by each microservice logs. Mutual TLS authentication : As mentioned earlier the gateway acts as the traffic orchestrator knowing where each service is and redirecting the traffic accordingly. To prevent any unauthorized request as well as protecting the communications channel between the Gateway itself and the upstream service, the API Gateway initiates a mutual TLS connection to ensure such thing. Requirements jq . Get the latest version: https://stedolan.github.io/jq/download/ docker and docker-compose : Get the latest version: https://docs.docker.com/engine/install/ubuntu/ and https://docs.docker.com/compose/install/ Have a working DNS server able to resolve the domain used during the installation process or add the following content to the /etc/hosts file, replacing the dev.lamassu.io domain with your own: 127.0.0.1 dev.lamassu.io 127.0.0.1 vault.dev.lamassu.io 127.0.0.1 auth.dev.lamassu.io 127.0.0.1 tracing.dev.lamassu.io 127.0.0.1 consul.dev.lamassu.io Setup Automatic deployment Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the next secret environment variables by exporting the following variables. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by exporting the DOMAIN variable. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env Run the installer: bash install.sh OPTIONAL : Import your certificates: The install.sh script also generates self-signed for the downstream certificates. It is possible to provide other valid certificates by replacing the following files: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt <----- Provide your certificate \u2514\u2500\u2500 tls.key <----- Provide your private key Once you replace this certificates, restart the api-gateway to obtain the imported certificates: docker-compose rm -s -f api-gateway dms-default docker-compose up -d api-gateway dms-default Final notes: \ud83d\ude80 You are ready to go \ud83d\ude80 Note Keycloak is your auth provider. During the install.sh the service is provisioned with 2 users with different roles: Username: enroller Password: enroller Role: admin Username: operator Password: operator Role: operator You can change those credentials (or create new users) using keycloak's UI available at: https://auth.<DOMAIN> Manual deployment To launch Lamassu follow the next steps: Set up your environment: Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the DB credentials variables used by the .env file. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by the .env file. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env The Gateway and TLS Certificates Lamassu uses a Gateway to expose all the deployed services. Moreover, the gateway is in charge of performing the following tasks: - Routing traffic to services - Enforcing authentication policies - Enforcing authorization policies - Logging & tracing - Healthchecking - Securely expose services using TLS The different APIs exposed through the gateway have been configured to ONLY accept request originates inside the platform via a mTLS authentication: Generate the upstream certificates. cd tls-certificates ./gen-upstream-certs.sh There are 2 options for the downstream certificate: Import an existing certificate : If you have valid certificates for your domain, you can use them by placing them under the downstream folder. The end result should be: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt \u2514\u2500\u2500 tls.key Generate a Self Signed certificate : If you need to create a new self-signed certificate, run the following command: ./gen-downstream-certs.sh Authentication service configuration: Run Keycloak: docker-compose up -d auth Keycloak image is configured with a Realm, a client and two different roles: admin and operator . Create a user with admin role to perform Enroller administrator tasks. (The command below creates a user named enroller with enroller as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u enroller -p enroller --roles admin Create a user with operator role to perform Device Manufacturing System tasks. This Device Manufacturing System must associate its CSR with this user matching the CN attribute and the username.(The command below creates a user named operator with operator as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u operator -p operator --roles operator Reload keyclok server docker-compose exec auth /opt/jboss/keycloak/bin/jboss-cli.sh --connect command=:reload If Keycloak display the following output, keycloak has successfully reloaded. Otherwise, run the command again until you see the expected output: { \"outcome\" => \"success\", \"result\" => undefined } Provision and configure Vault and Lamassu CA: Run Vault: docker-compose up -d vault consul-server api-gateway Initialize vault: This process generates vault's unseal keys as well as the root token: docker-compose exec vault vault operator init -key-shares=5 -key-threshold=3 -tls-skip-verify -format=json > vault-credentials.json Verify the vault-credentials.json file has the expected content. It should be similar to this: { \"unseal_keys_b64\": [ \"Hfx46iMq/PXoBPhDZ0EAMM9MDWS8GTCANFbAkzVEzFOD\", \"lfo48PHGFGHmpaFn6Z6rWTXTXVS53m9duxsvwVjRDc2L\", \"dcVw6N81i+/pY34WTHQYkV848to7jNeVkgdJOtgxnRkS\", \"Aut6oL7+GomXCrrTH0FCKhJwAs2PrWFYSnWpgjLfwsH0\", \"pprFM0HJEUR4m3kaIT5sga87aJ4AjXi32KVn6dgfivii\" ], \"unseal_keys_hex\": [ \"1dfc78ea232afcf5e804f84367410030cf4c0d64bc1930803456c0933544cc5383\", \"95fa38f0f1c61461e6a5a167e99eab5935d35d54b9de6f5dbb1b2fc158d10dcd8b\", \"75c570e8df358befe9637e164c7418915f38f2da3b8cd7959207493ad8319d1912\", \"02eb7aa0befe1a89970abad31f41422a127002cd8fad61584a75a98232dfc2c1f4\", \"a69ac53341c91144789b791a213e6c81af3b689e008d78b7d8a567e9d81f8af8a2\" ], \"unseal_shares\": 5, \"unseal_threshold\": 3, \"recovery_keys_b64\": [], \"recovery_keys_hex\": [], \"recovery_keys_shares\": 5, \"recovery_keys_threshold\": 3, \"root_token\": \"s.80Mpm0OmxlXzoSxZB2MMPcNu\" } Export the following variables: export VAULT_TOKEN=$(cat vault-credentials.json | jq .root_token -r) export VAULT_ADDR=https://vault.$DOMAIN Unseal Vault using the keys obtained with the previous command: curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[0])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[1])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[2])\\\" }\" Vault must be provisioned with some resources (authentication methods, policies and secret engines). That can be achieved by running the ca-provision.sh script. Vault will be provisioned with 4 Root CAs, 1 Special CA (Lamassu-DMS-Enroller) AppRole authentication method and one role and policy for each service or container that needs to exchange data with it. cd config/vault/provision/ ./provisioner.sh cd ../../../ Get RoleID and SecretID for each service and set those values in the empty fields of the .docker-compose.yml file. export CA_VAULT_ROLEID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/role-id | jq -r .data.role_id ) export CA_VAULT_SECRETID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" --request POST ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/secret-id | jq -r .data.secret_id) # Set RoleID and SecretID in docker-compose.yml file sed -i 's/<LAMASSU_CA_VAULT_ROLE_ID>/'$CA_VAULT_ROLEID'/g' docker-compose.yml sed -i 's/<LAMASSU_CA_VAULT_SECRET_ID>/'$CA_VAULT_SECRETID'/g' docker-compose.yml Configure the Device Manager: The Device Manage has a configurable variable that determines when a device can renew (also known as reenroll) its certificate. By default the reenrollment process can only be done 30 days prior to the cert's expiration time. This value can be changed by modifying the DEVICE_MANAGER_MINIMUM_REENROLL_DAYS variable located in the .env file. Start the remaining services: docker-compose up -d Configure the Default DMS First, authenticate against Keycloak: export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' |jq -r .access_token) Then, register a new DMS named Lamassu-Default-DMS: Note while registering new DMS instances with non admin users, it is necessary to register the DMS using the user's username as the common name, otherwise, the user won't see its DMSs export ENROLL_ADDR=$DOMAIN/api/dmsenroller export DMS_REGISTER_RESPONSE=$(curl -k --location --request POST \"https://$ENROLL_ADDR/v1/Lamassu-Default-DMS/form\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"url\\\":\\\"https://${DOMAIN}:5000\\\", \\\" subject\\\":{ \\\"common_name\\\": \\\"Lamassu-Default-DMS\\\",\\\"country\\\": \\\"\\\",\\\"locality\\\": \\\"\\\",\\\"organization\\\": \\\"\\\",\\\"organization_unit\\\": \\\"\\\",\\\"state\\\": \\\"\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 3072,\\\"type\\\": \\\"rsa\\\"}}\") echo $DMS_REGISTER_RESPONSE | jq -r .priv_key | sed 's/\\\\n/\\n/g' | sed -Ez '$ s/\\n+$//' | base64 -d > lamassu-default-dms/config/dms.key export DMS_ID=$(echo $DMS_REGISTER_RESPONSE | jq -r .dms.id) 3. Enroll the new DMS curl -k --location --request PUT \"https://$ENROLL_ADDR/v1/$DMS_ID\" --header \"Authorization: Bearer $TOKEN\" --header 'Content-Type: application/json' --data-raw '{\"status\": \"APPROVED\"}' 4. Get issued DMS Cert curl -k --location --request GET \"https://$ENROLL_ADDR/v1/$DMS _ID/crt\" --header \"Authorization: Bearer $TOKEN\" | base64 -d > lamassu-default-dms/config/dms.crt And finally, start the DMS \"server\": docker-compose rm -s -f dms-default docker-compose up -d dms-default Deploy AWS and Azure PKI connectors","title":"Install Lamassu Compose"},{"location":"setup/#install-lamassu-compose","text":"Lamassu Compose is the official release containing the scripts and resources required to deploy all microservices such as the CA component, the VA component or the RA components to name a few.","title":"Install Lamassu Compose"},{"location":"setup/#architecture","text":"Lamassu Compose offers a SECURE deployment of the set of microservices required to manage an industrial PKI. The architecture presented on the following image reflects the interconnection of the different services mainly using the HTTP Protocol. The use of this deployment offers the following non functional requirements by leveraging the use of an API Gateway: Centralized point of access : Each microservice listens on a different port which ends up being challenging for developers and users. With the use of the API Gateway, the user will always access the same host and port address. Port 80 for HTTP connections and port 443 for HTTPS connections. Authentication : In order to invoke any endpoint, the API Gateway enforces each request to present a JWT. Upon receiving an HTTP request, the gateway validates the presented token against the authentication server. Authorization : Another key aspect is enforcing an authorization schema. Lamassu has been configured in such way that only specific endpoints are accessible by non admin users. Tracing : Logging the life of an HTTP request can be helpful during the debugging process of such complex application. The tracing aspect eases this process by injecting a unique identifier to each request that is then printed out by each microservice logs. Mutual TLS authentication : As mentioned earlier the gateway acts as the traffic orchestrator knowing where each service is and redirecting the traffic accordingly. To prevent any unauthorized request as well as protecting the communications channel between the Gateway itself and the upstream service, the API Gateway initiates a mutual TLS connection to ensure such thing.","title":"Architecture"},{"location":"setup/#requirements","text":"jq . Get the latest version: https://stedolan.github.io/jq/download/ docker and docker-compose : Get the latest version: https://docs.docker.com/engine/install/ubuntu/ and https://docs.docker.com/compose/install/ Have a working DNS server able to resolve the domain used during the installation process or add the following content to the /etc/hosts file, replacing the dev.lamassu.io domain with your own: 127.0.0.1 dev.lamassu.io 127.0.0.1 vault.dev.lamassu.io 127.0.0.1 auth.dev.lamassu.io 127.0.0.1 tracing.dev.lamassu.io 127.0.0.1 consul.dev.lamassu.io","title":"Requirements"},{"location":"setup/#setup","text":"","title":"Setup"},{"location":"setup/#automatic-deployment","text":"Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the next secret environment variables by exporting the following variables. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by exporting the DOMAIN variable. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env Run the installer: bash install.sh OPTIONAL : Import your certificates: The install.sh script also generates self-signed for the downstream certificates. It is possible to provide other valid certificates by replacing the following files: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt <----- Provide your certificate \u2514\u2500\u2500 tls.key <----- Provide your private key Once you replace this certificates, restart the api-gateway to obtain the imported certificates: docker-compose rm -s -f api-gateway dms-default docker-compose up -d api-gateway dms-default Final notes: \ud83d\ude80 You are ready to go \ud83d\ude80 Note Keycloak is your auth provider. During the install.sh the service is provisioned with 2 users with different roles: Username: enroller Password: enroller Role: admin Username: operator Password: operator Role: operator You can change those credentials (or create new users) using keycloak's UI available at: https://auth.<DOMAIN>","title":"Automatic deployment"},{"location":"setup/#manual-deployment","text":"To launch Lamassu follow the next steps: Set up your environment: Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-compose && cd lamassu-compose Define the DB credentials variables used by the .env file. export DB_USER=<DB_USER> //Database user. export DB_PASSWORD=<DB_PASSWORD> //Database user password. Define the domain to be used by the .env file. export DOMAIN=dev.lamassu.io Define the docker images tags to be used by exporting the following variables export LAMASSU_GATEWAY_DOCKER_IMAGE=lamassuiot/lamassu-gateway:latest export LAMASSU_UI_DOCKER_IMAGE=lamassuiot/lamassu-ui:latest export LAMASSU_DB_DOCKER_IMAGE=lamassuiot/lamassu-db:latest export LAMASSU_AUTH_DOCKER_IMAGE=lamassuiot/lamassu-auth:latest export LAMASSU_CA_DOCKER_IMAGE=lamassuiot/lamassu-ca:latest export LAMASSU_DMS_ENROLLER_DOCKER_IMAGE=lamassuiot/lamassu-dms-enroller:latest export LAMASSU_DEVICE_MANAGER_DOCKER_IMAGE=lamassuiot/lamassu-device-manager:latest export LAMASSU_RABBITMQ_DOCKER_IMAGE=lamassuiot/lamassu-rabbitmq:latest export LAMASSU_CLOUD_PROXY_DOCKER_IMAGE=lamassuiot/lamassu-cloud-proxy:latest export LAMASSU_OCSP_DOCKER_IMAGE=lamassuiot/lamassu-ocsp:latest Run the following command to replace .env file with the values defined variables previously: envsubst < .env | tee .env The Gateway and TLS Certificates Lamassu uses a Gateway to expose all the deployed services. Moreover, the gateway is in charge of performing the following tasks: - Routing traffic to services - Enforcing authentication policies - Enforcing authorization policies - Logging & tracing - Healthchecking - Securely expose services using TLS The different APIs exposed through the gateway have been configured to ONLY accept request originates inside the platform via a mTLS authentication: Generate the upstream certificates. cd tls-certificates ./gen-upstream-certs.sh There are 2 options for the downstream certificate: Import an existing certificate : If you have valid certificates for your domain, you can use them by placing them under the downstream folder. The end result should be: \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt \u2514\u2500\u2500 tls.key Generate a Self Signed certificate : If you need to create a new self-signed certificate, run the following command: ./gen-downstream-certs.sh Authentication service configuration: Run Keycloak: docker-compose up -d auth Keycloak image is configured with a Realm, a client and two different roles: admin and operator . Create a user with admin role to perform Enroller administrator tasks. (The command below creates a user named enroller with enroller as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u enroller -p enroller --roles admin Create a user with operator role to perform Device Manufacturing System tasks. This Device Manufacturing System must associate its CSR with this user matching the CN attribute and the username.(The command below creates a user named operator with operator as its password): docker-compose exec auth /opt/jboss/keycloak/bin/add-user-keycloak.sh -r lamassu -u operator -p operator --roles operator Reload keyclok server docker-compose exec auth /opt/jboss/keycloak/bin/jboss-cli.sh --connect command=:reload If Keycloak display the following output, keycloak has successfully reloaded. Otherwise, run the command again until you see the expected output: { \"outcome\" => \"success\", \"result\" => undefined } Provision and configure Vault and Lamassu CA: Run Vault: docker-compose up -d vault consul-server api-gateway Initialize vault: This process generates vault's unseal keys as well as the root token: docker-compose exec vault vault operator init -key-shares=5 -key-threshold=3 -tls-skip-verify -format=json > vault-credentials.json Verify the vault-credentials.json file has the expected content. It should be similar to this: { \"unseal_keys_b64\": [ \"Hfx46iMq/PXoBPhDZ0EAMM9MDWS8GTCANFbAkzVEzFOD\", \"lfo48PHGFGHmpaFn6Z6rWTXTXVS53m9duxsvwVjRDc2L\", \"dcVw6N81i+/pY34WTHQYkV848to7jNeVkgdJOtgxnRkS\", \"Aut6oL7+GomXCrrTH0FCKhJwAs2PrWFYSnWpgjLfwsH0\", \"pprFM0HJEUR4m3kaIT5sga87aJ4AjXi32KVn6dgfivii\" ], \"unseal_keys_hex\": [ \"1dfc78ea232afcf5e804f84367410030cf4c0d64bc1930803456c0933544cc5383\", \"95fa38f0f1c61461e6a5a167e99eab5935d35d54b9de6f5dbb1b2fc158d10dcd8b\", \"75c570e8df358befe9637e164c7418915f38f2da3b8cd7959207493ad8319d1912\", \"02eb7aa0befe1a89970abad31f41422a127002cd8fad61584a75a98232dfc2c1f4\", \"a69ac53341c91144789b791a213e6c81af3b689e008d78b7d8a567e9d81f8af8a2\" ], \"unseal_shares\": 5, \"unseal_threshold\": 3, \"recovery_keys_b64\": [], \"recovery_keys_hex\": [], \"recovery_keys_shares\": 5, \"recovery_keys_threshold\": 3, \"root_token\": \"s.80Mpm0OmxlXzoSxZB2MMPcNu\" } Export the following variables: export VAULT_TOKEN=$(cat vault-credentials.json | jq .root_token -r) export VAULT_ADDR=https://vault.$DOMAIN Unseal Vault using the keys obtained with the previous command: curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[0])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[1])\\\" }\" curl --request PUT \"$VAULT_ADDR/v1/sys/unseal\" -k --header 'Content-Type: application/json' --data-raw \"{\\\"key\\\": \\\"$(cat vault-credentials.json | jq -r .unseal_keys_hex[2])\\\" }\" Vault must be provisioned with some resources (authentication methods, policies and secret engines). That can be achieved by running the ca-provision.sh script. Vault will be provisioned with 4 Root CAs, 1 Special CA (Lamassu-DMS-Enroller) AppRole authentication method and one role and policy for each service or container that needs to exchange data with it. cd config/vault/provision/ ./provisioner.sh cd ../../../ Get RoleID and SecretID for each service and set those values in the empty fields of the .docker-compose.yml file. export CA_VAULT_ROLEID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/role-id | jq -r .data.role_id ) export CA_VAULT_SECRETID=$(curl -k --header \"X-Vault-Token: ${VAULT_TOKEN}\" --request POST ${VAULT_ADDR}/v1/auth/approle/role/lamassu-ca-role/secret-id | jq -r .data.secret_id) # Set RoleID and SecretID in docker-compose.yml file sed -i 's/<LAMASSU_CA_VAULT_ROLE_ID>/'$CA_VAULT_ROLEID'/g' docker-compose.yml sed -i 's/<LAMASSU_CA_VAULT_SECRET_ID>/'$CA_VAULT_SECRETID'/g' docker-compose.yml Configure the Device Manager: The Device Manage has a configurable variable that determines when a device can renew (also known as reenroll) its certificate. By default the reenrollment process can only be done 30 days prior to the cert's expiration time. This value can be changed by modifying the DEVICE_MANAGER_MINIMUM_REENROLL_DAYS variable located in the .env file. Start the remaining services: docker-compose up -d Configure the Default DMS First, authenticate against Keycloak: export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' |jq -r .access_token) Then, register a new DMS named Lamassu-Default-DMS: Note while registering new DMS instances with non admin users, it is necessary to register the DMS using the user's username as the common name, otherwise, the user won't see its DMSs export ENROLL_ADDR=$DOMAIN/api/dmsenroller export DMS_REGISTER_RESPONSE=$(curl -k --location --request POST \"https://$ENROLL_ADDR/v1/Lamassu-Default-DMS/form\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"url\\\":\\\"https://${DOMAIN}:5000\\\", \\\" subject\\\":{ \\\"common_name\\\": \\\"Lamassu-Default-DMS\\\",\\\"country\\\": \\\"\\\",\\\"locality\\\": \\\"\\\",\\\"organization\\\": \\\"\\\",\\\"organization_unit\\\": \\\"\\\",\\\"state\\\": \\\"\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 3072,\\\"type\\\": \\\"rsa\\\"}}\") echo $DMS_REGISTER_RESPONSE | jq -r .priv_key | sed 's/\\\\n/\\n/g' | sed -Ez '$ s/\\n+$//' | base64 -d > lamassu-default-dms/config/dms.key export DMS_ID=$(echo $DMS_REGISTER_RESPONSE | jq -r .dms.id) 3. Enroll the new DMS curl -k --location --request PUT \"https://$ENROLL_ADDR/v1/$DMS_ID\" --header \"Authorization: Bearer $TOKEN\" --header 'Content-Type: application/json' --data-raw '{\"status\": \"APPROVED\"}' 4. Get issued DMS Cert curl -k --location --request GET \"https://$ENROLL_ADDR/v1/$DMS _ID/crt\" --header \"Authorization: Bearer $TOKEN\" | base64 -d > lamassu-default-dms/config/dms.crt And finally, start the DMS \"server\": docker-compose rm -s -f dms-default docker-compose up -d dms-default","title":"Manual deployment"},{"location":"setup/#deploy-aws-and-azure-pki-connectors","text":"","title":"Deploy AWS and Azure PKI connectors"},{"location":"usage/","text":"Getting Started Before jumping any further, please check out the installation process to deploy all Lamassu services. This section will guide you through the basic functionalities provided by our PKI to start provisioning your devices. Overview Create a new Certification Authority The first step to provision your devices with digital certificates is to create the Certification Authority. The role of a CA is to issue and manage all the certificates. To create a new CA, fill the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs. Register a new Device Manufacturing System Lamassu is a PKI designed for the industrial and iot sector. To better integrate this PKI in real life manufacturing system, Lamassu delegates the issuance of device certificate to the factory itself. First lets dive into the Device Manufacturing System (DMS for short) registration step by step. After that, a couple of examples will demonstrate how to start enrolling your devices using the Lamassu's Virtual DMS software as well as using the UI. Device manufacturing process tend to be highly automated. Provisioning the devices with digital identities should not slow down the fabrication process. Lamassu addresses this challenge introducing the DMS concept as core. One of the factories operators stars the process by generating a DMS registration request contained in a Certificate Signing Request also referred as CSR. This CSR is then sent to the DMS Enroller service to be approved by one of the PKI Administrators: The Administrator then decides if the request is approved or denied. If it decision is to approve the DMS registration request, the Administrator must specify which CAs will that particular DSM be entitled to issue certificates with: Once, and only if, the DMS registration request is approved, then the Operator must retrieve the signed CSR and pass it to the DMS software that will be in charge off requesting the issuance of new digital certificates for the manufactured devices: Finally, the DMS is able to request new x509 certificates for its manufactured devices. The DMS may be assisted by additional tools to obtain the manufactured device unique identifier. Note Envoy is used as an API gateway in this project. Currently Envoy is written to use Boring SSl as the TLS provider. It does not support secp224r1 signing method, which is used to create ECDSA224 keys. Therefore, enroll and reenroll methods will return a error when using this key. Let's register a new DMS instance: Operator - Authenticate the user: OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Operator - Request the registration for a new DMS instance: DMS_NAME=MyDMS DMS_SUBJECT_COUNTRY=ES DMS_SUBJECT_STATE=Gipuzkoa DMS_SUBJECT_LOCALITY=Donostia DMS_SUBJECT_ORGANIZATION=Lamassu DMS_SUBJECT_ORGANIZATION_UNIT=IoT DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsenroller/v1/$DMS_NAME/form\" \\ --header \"Authorization: Bearer $OPERATOR_TOKEN\" \\ --data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"org\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}}\") DMS_ID=$(echo $DMS_REG_RESPONSE | jq -r .dms.id) echo $DMS_REG_RESPONSE | jq -r .priv_key | base64 -d > dms.key Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Authorize the enrollment with all the provisioned CAs AUTHORIZED_CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .[].name | jq -s) curl -k --location --request PUT \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" \\ --header \"Authorization: Bearer $ENROLLER_TOKEN\" \\ --data-raw \"{\\\"authorized_cas\\\":$AUTHORIZED_CAS, \\\"status\\\":\\\"APPROVED\\\"}\" Operator - Get the DMS certificate: curl -k \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .crt | base64 -d > dms.crt Provision your devices with x509 Certificates The enrollment process is the way to go to obtain a certificate issued by one of the provisioned CAs. As described in the RFC document, Lamassu requires the authentication of the client requesting the enrollment using a certificate as well as the private key of an issued DMS to perform a mutual TLS connection. By using this type of TLS connection, the client is able to authenticate the server, and also, the server is able to authenticate the client. Although the /api/devmanager/.well-known/cacerts endpoint returns the list containing all the manged CAs by the PKI, each DMS is entitled to request the issuance of a certificate with an authorized CA. For instance, the PKI may have the following CAs: CA1 , CA2 , CA3 and CA4 . The /api/devmanager/.well-known/cacerts would return all four CAs. Then, a new DMS is registered. the PKI administrator approves the DMS registration by authorizing such DMS to issue certificates with CA1 and CA4 . This process is known as the DMS registration process . Once the DMS is completely registered, it can now start performing the EST enrollment process. Check out the previous section to understand what a DMS does. Let's first obtain the CA list for a particular DMS: First, authenticate and obtain a valid JWT OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Obtain the CA list: ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .authorized_cas) Select one of the entitled the CAs from the previous list: Note You can manually spefify the SELECTED_CA . Otherwise you can enroll the device with the first entitled CA using the following command. SELECTED_CA=$(echo $ENTITLED_CAS | jq .[0] -r) Generate the device CSR: DEVICE_ID=mytestdevice-123 openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" Enroll the device: DMS_CRT_PATH=path/to/dms_crt DMS_KEY_PATH=path/to/dms_key openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem curl https://$DOMAIN/api/devmanager/.well-known/est/$SELECTED_CA/simpleenroll --cert $DMS_CRT_PATH --key $DMS_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem --data-binary @device.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem openssl x509 -text -in device-cert.pem Using the UI The UI is an easy manageable tool designed to ease the burdens to non-technical users in using Lamassu PKI. Create a new Certification Authority There are two methos of creating a new CA from the UI. The first one, filling the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs. The other one, will be importing it. A Certificate and a Private Key will be required. Registration of a DMS using the UI Using the UI, creating a new DMS is as simple as filling the following form. Once the DMS has been created successfully, a prompt showing the generated private key will be shown. It is encouraged to download it just after the creation as this prompt will be shown only once. The status of the new created DMS will be Pending Approval , to approve it, we must select at least one CA from the list of registered CAs. The selected CAs will be the authorised ones to sign certificates from now on. Registration of a device using the UI To create a device, we will need to fill the following form taking into account: A device identification must be provided. A DMS must be assigned. Each device can have certificates signed by different authorised CAs. The certificates of each device as well as the cloud-connectors will be showned. Using the APIs The main 3 Open API documentation can be found on the following urls: https://dev.lamassu.io/api/dmsenroller/v1/docs/ https://dev.lamassu.io/api/ca/v1/docs/ https://dev.lamassu.io/api/devmanager/v1/docs/ Note The following endpoints defined in the Lamassu Device Manager Api specification are not correctly defined due to the limitations imposed by the Open API 3.0 schema. The current specification defines an OIDC security schema (meaning that a valid JWT token must be provided while requesting the API) while the implemented security schema uses the mTLS approach. This issue will be resolved once the specification is migrated to Open API 3.1 compliant. The affected endpoints are: Lamassu provides easy to use GO clients for most of its APIs to help speeding up the development of third-party applications. Before using thees clients, it is important to identify the path taken by the request. Unless the application using the GO clients (or any other http client such as curl ) is deployed within the same docker network, the request will be handled by the API Gateway component . Otherwise check the internal usage section. Through the API Gateway Go Curl package main import ( \"net/url\" lamassuCAClient \"github.com/lamassuiot/lamassuiot/pkg/ca/client\" caDTO \"github.com/lamassuiot/lamassuiot/pkg/ca/common/dto\" \"github.com/lamassuiot/lamassuiot/pkg/utils/client\" ) function main (){ lamassuGatewayURL := \"dev.lamassu.io\" apiCAFile := \"path/to/apigw.crt\" caClient := lamassuCAClient . NewLamassuCAClient ( client . ClientConfiguration { URL : & url . URL { Scheme : \"https\" , Host : lamassuGatewayURL , Path : \"/api/ca/\" , }, AuthMethod : client . JWT , AuthMethodConfig : & client . JWTConfig { Username : \"enroller\" , Password : \"enroller\" , URL : & url . URL { Scheme : \"https\" , Host : \"auth.\" + lamassuGatewayURL , }, CACertificate : apiCAFile , }, CACertificate : apiCAFile , }) ca , err = caClient . CreateCA ( context . Background (), caDTO . Pki , caName , caDTO . PrivateKeyMetadata { KeyType : \"rsa\" , KeyBits : 2048 }, caDTO . Subject { CN : caName }, 365 * time . Hour , 30 * time . Hour ) } Define the DOMAIN, TOKEN and CA_NAME export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' | jq -r .access_token) export CA_ADDR=$DOMAIN/api/ca export CA_NAME=$(uuidgen) Creting CA export CREATE_CA_RESP=$(curl -k -s --location --request POST \"https://$CA_ADDR/v1/pki/$CA_NAME\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"ca_ttl\\\": 262800, \\\"enroller_ttl\\\": 175200, \\\"subject\\\":{ \\\"common_name\\\": \\\"$CA_NAME\\\",\\\"country\\\": \\\"ES\\\",\\\"locality\\\": \\\"Arrasate\\\",\\\"organization\\\": \\\"LKS Next, S. Coop\\\",\\\"state\\\": \\\"Gipuzkoa\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 4096,\\\"type\\\": \\\"RSA\\\"}}\") Internal usage Filtering, Sorting and Pagination Lamassu API supports filtering, sorting and pagination. The filter can be form by the following parameters, being each of them optional: filter= attribute[operator]=value sort_by=attribute.[asc|desc] limit=value . Limits the maximun number of results of the query offset=value . In addition to limit , implements pagination. It defines the index of the first value from the resulting query. Example /v1/devices?filter=id[contains]=device_id&sort_by=id.asc&limit=100&offset=15 /v1?filter=id[contains]=dms_id&sort_by=id.desc Operators Depending of the data type of the parameters, the supported operators will vary. Strings : equals , notequals , contains , notcontains Dates: before , after , is , isnot Enums: is , isnot Numbers: lessthan , greaterthan , lessorequal , gretaerorequal , equal , notequal","title":"Getting Started"},{"location":"usage/#getting-started","text":"Before jumping any further, please check out the installation process to deploy all Lamassu services. This section will guide you through the basic functionalities provided by our PKI to start provisioning your devices.","title":"Getting Started"},{"location":"usage/#overview","text":"","title":"Overview"},{"location":"usage/#create-a-new-certification-authority","text":"The first step to provision your devices with digital certificates is to create the Certification Authority. The role of a CA is to issue and manage all the certificates. To create a new CA, fill the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs.","title":"Create a new Certification Authority"},{"location":"usage/#register-a-new-device-manufacturing-system","text":"Lamassu is a PKI designed for the industrial and iot sector. To better integrate this PKI in real life manufacturing system, Lamassu delegates the issuance of device certificate to the factory itself. First lets dive into the Device Manufacturing System (DMS for short) registration step by step. After that, a couple of examples will demonstrate how to start enrolling your devices using the Lamassu's Virtual DMS software as well as using the UI. Device manufacturing process tend to be highly automated. Provisioning the devices with digital identities should not slow down the fabrication process. Lamassu addresses this challenge introducing the DMS concept as core. One of the factories operators stars the process by generating a DMS registration request contained in a Certificate Signing Request also referred as CSR. This CSR is then sent to the DMS Enroller service to be approved by one of the PKI Administrators: The Administrator then decides if the request is approved or denied. If it decision is to approve the DMS registration request, the Administrator must specify which CAs will that particular DSM be entitled to issue certificates with: Once, and only if, the DMS registration request is approved, then the Operator must retrieve the signed CSR and pass it to the DMS software that will be in charge off requesting the issuance of new digital certificates for the manufactured devices: Finally, the DMS is able to request new x509 certificates for its manufactured devices. The DMS may be assisted by additional tools to obtain the manufactured device unique identifier. Note Envoy is used as an API gateway in this project. Currently Envoy is written to use Boring SSl as the TLS provider. It does not support secp224r1 signing method, which is used to create ECDSA224 keys. Therefore, enroll and reenroll methods will return a error when using this key. Let's register a new DMS instance: Operator - Authenticate the user: OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Operator - Request the registration for a new DMS instance: DMS_NAME=MyDMS DMS_SUBJECT_COUNTRY=ES DMS_SUBJECT_STATE=Gipuzkoa DMS_SUBJECT_LOCALITY=Donostia DMS_SUBJECT_ORGANIZATION=Lamassu DMS_SUBJECT_ORGANIZATION_UNIT=IoT DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsenroller/v1/$DMS_NAME/form\" \\ --header \"Authorization: Bearer $OPERATOR_TOKEN\" \\ --data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"org\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}}\") DMS_ID=$(echo $DMS_REG_RESPONSE | jq -r .dms.id) echo $DMS_REG_RESPONSE | jq -r .priv_key | base64 -d > dms.key Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Authorize the enrollment with all the provisioned CAs AUTHORIZED_CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .[].name | jq -s) curl -k --location --request PUT \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" \\ --header \"Authorization: Bearer $ENROLLER_TOKEN\" \\ --data-raw \"{\\\"authorized_cas\\\":$AUTHORIZED_CAS, \\\"status\\\":\\\"APPROVED\\\"}\" Operator - Get the DMS certificate: curl -k \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .crt | base64 -d > dms.crt","title":"Register a new Device Manufacturing System"},{"location":"usage/#provision-your-devices-with-x509-certificates","text":"The enrollment process is the way to go to obtain a certificate issued by one of the provisioned CAs. As described in the RFC document, Lamassu requires the authentication of the client requesting the enrollment using a certificate as well as the private key of an issued DMS to perform a mutual TLS connection. By using this type of TLS connection, the client is able to authenticate the server, and also, the server is able to authenticate the client. Although the /api/devmanager/.well-known/cacerts endpoint returns the list containing all the manged CAs by the PKI, each DMS is entitled to request the issuance of a certificate with an authorized CA. For instance, the PKI may have the following CAs: CA1 , CA2 , CA3 and CA4 . The /api/devmanager/.well-known/cacerts would return all four CAs. Then, a new DMS is registered. the PKI administrator approves the DMS registration by authorizing such DMS to issue certificates with CA1 and CA4 . This process is known as the DMS registration process . Once the DMS is completely registered, it can now start performing the EST enrollment process. Check out the previous section to understand what a DMS does. Let's first obtain the CA list for a particular DMS: First, authenticate and obtain a valid JWT OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Obtain the CA list: ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsenroller/v1/$DMS_ID\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .authorized_cas) Select one of the entitled the CAs from the previous list: Note You can manually spefify the SELECTED_CA . Otherwise you can enroll the device with the first entitled CA using the following command. SELECTED_CA=$(echo $ENTITLED_CAS | jq .[0] -r) Generate the device CSR: DEVICE_ID=mytestdevice-123 openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" Enroll the device: DMS_CRT_PATH=path/to/dms_crt DMS_KEY_PATH=path/to/dms_key openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem curl https://$DOMAIN/api/devmanager/.well-known/est/$SELECTED_CA/simpleenroll --cert $DMS_CRT_PATH --key $DMS_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem --data-binary @device.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem openssl x509 -text -in device-cert.pem","title":"Provision your devices with x509 Certificates"},{"location":"usage/#using-the-ui","text":"The UI is an easy manageable tool designed to ease the burdens to non-technical users in using Lamassu PKI.","title":"Using the UI"},{"location":"usage/#create-a-new-certification-authority_1","text":"There are two methos of creating a new CA from the UI. The first one, filling the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs. The other one, will be importing it. A Certificate and a Private Key will be required.","title":"Create a new Certification Authority"},{"location":"usage/#registration-of-a-dms-using-the-ui","text":"Using the UI, creating a new DMS is as simple as filling the following form. Once the DMS has been created successfully, a prompt showing the generated private key will be shown. It is encouraged to download it just after the creation as this prompt will be shown only once. The status of the new created DMS will be Pending Approval , to approve it, we must select at least one CA from the list of registered CAs. The selected CAs will be the authorised ones to sign certificates from now on.","title":"Registration of a DMS using the UI"},{"location":"usage/#registration-of-a-device-using-the-ui","text":"To create a device, we will need to fill the following form taking into account: A device identification must be provided. A DMS must be assigned. Each device can have certificates signed by different authorised CAs. The certificates of each device as well as the cloud-connectors will be showned.","title":"Registration of a device using the UI"},{"location":"usage/#using-the-apis","text":"The main 3 Open API documentation can be found on the following urls: https://dev.lamassu.io/api/dmsenroller/v1/docs/ https://dev.lamassu.io/api/ca/v1/docs/ https://dev.lamassu.io/api/devmanager/v1/docs/ Note The following endpoints defined in the Lamassu Device Manager Api specification are not correctly defined due to the limitations imposed by the Open API 3.0 schema. The current specification defines an OIDC security schema (meaning that a valid JWT token must be provided while requesting the API) while the implemented security schema uses the mTLS approach. This issue will be resolved once the specification is migrated to Open API 3.1 compliant. The affected endpoints are: Lamassu provides easy to use GO clients for most of its APIs to help speeding up the development of third-party applications. Before using thees clients, it is important to identify the path taken by the request. Unless the application using the GO clients (or any other http client such as curl ) is deployed within the same docker network, the request will be handled by the API Gateway component . Otherwise check the internal usage section.","title":"Using the APIs"},{"location":"usage/#through-the-api-gateway","text":"Go Curl package main import ( \"net/url\" lamassuCAClient \"github.com/lamassuiot/lamassuiot/pkg/ca/client\" caDTO \"github.com/lamassuiot/lamassuiot/pkg/ca/common/dto\" \"github.com/lamassuiot/lamassuiot/pkg/utils/client\" ) function main (){ lamassuGatewayURL := \"dev.lamassu.io\" apiCAFile := \"path/to/apigw.crt\" caClient := lamassuCAClient . NewLamassuCAClient ( client . ClientConfiguration { URL : & url . URL { Scheme : \"https\" , Host : lamassuGatewayURL , Path : \"/api/ca/\" , }, AuthMethod : client . JWT , AuthMethodConfig : & client . JWTConfig { Username : \"enroller\" , Password : \"enroller\" , URL : & url . URL { Scheme : \"https\" , Host : \"auth.\" + lamassuGatewayURL , }, CACertificate : apiCAFile , }, CACertificate : apiCAFile , }) ca , err = caClient . CreateCA ( context . Background (), caDTO . Pki , caName , caDTO . PrivateKeyMetadata { KeyType : \"rsa\" , KeyBits : 2048 }, caDTO . Subject { CN : caName }, 365 * time . Hour , 30 * time . Hour ) } Define the DOMAIN, TOKEN and CA_NAME export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' | jq -r .access_token) export CA_ADDR=$DOMAIN/api/ca export CA_NAME=$(uuidgen) Creting CA export CREATE_CA_RESP=$(curl -k -s --location --request POST \"https://$CA_ADDR/v1/pki/$CA_NAME\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"ca_ttl\\\": 262800, \\\"enroller_ttl\\\": 175200, \\\"subject\\\":{ \\\"common_name\\\": \\\"$CA_NAME\\\",\\\"country\\\": \\\"ES\\\",\\\"locality\\\": \\\"Arrasate\\\",\\\"organization\\\": \\\"LKS Next, S. Coop\\\",\\\"state\\\": \\\"Gipuzkoa\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 4096,\\\"type\\\": \\\"RSA\\\"}}\")","title":"Through the API Gateway"},{"location":"usage/#internal-usage","text":"","title":"Internal usage"},{"location":"usage/#filtering-sorting-and-pagination","text":"Lamassu API supports filtering, sorting and pagination. The filter can be form by the following parameters, being each of them optional: filter= attribute[operator]=value sort_by=attribute.[asc|desc] limit=value . Limits the maximun number of results of the query offset=value . In addition to limit , implements pagination. It defines the index of the first value from the resulting query. Example /v1/devices?filter=id[contains]=device_id&sort_by=id.asc&limit=100&offset=15 /v1?filter=id[contains]=dms_id&sort_by=id.desc","title":"Filtering, Sorting and Pagination"},{"location":"usage/#operators","text":"Depending of the data type of the parameters, the supported operators will vary. Strings : equals , notequals , contains , notcontains Dates: before , after , is , isnot Enums: is , isnot Numbers: lessthan , greaterthan , lessorequal , gretaerorequal , equal , notequal","title":"Operators"},{"location":"virtualDMS/","text":"Lamassu Virtual DMS To launch Lamassu-Virtual-DMS follow the next steps: Clone the repository and get into the directory: https://github.com/lamassuiot/lamassu-virtual-dms.git && cd lamassu-virtual-dms . Change the configuration variables of the config.json file. { \"dms\": { \"device_store\": \"<DEVICES_STORE>\", // Folder where device certificates are stored \"dms_store\": \"<DMS_STORE>\", // Folder where DMS certificates are stored \"endpoint\":\"<DMS_SERVER>\", // DMS server endpoint \"dms_name\":\"<DEFAULT_DMS>\", // DMS Name \"common_name\":\"<DEFAULT_DMS>\", // Common_name to create the CSR \"country\":\"<COUNTRY>\", // Country to create the CSR \"locality\":\"<LOCALITY>\", // Locality to create the CSR \"organization\":\"<ORGANIZATION>\", // Organization to create the CSR \"organization_unit\":\"<ORGANIZATION_UNIT>\", // Organization_unit to create the CSR \"state\":\"<STATE>\" // State to create the CSR }, \"devmanager\":{ \"devcrt\": \"<DEV_CERTIFICATE>\", // Public certificate to connect to the device-manager \"addr\": \"<DEVMANAGER_SERVER>\" //Device Manager Server Endpoint }, \"auth\":{ \"endpoint\":\"<AUTH_SERVER>\", // Authentication Server endpoint \"username\":\"<PASSWORD>\", // User name to connect to the authentication server \"password\":\"<PASSWORD>\" // Password to connect to the authentication server } } 3. Create directories to store DMS and device certificates mkdir -p /home/$USER/virtual-dms-data/devices_certificates mkdir -p /home/$USER/virtual-dms-data/dms_certificates 4. config.json file with default values { \"dms\": { \"device_store\": \"/home/$USER/virtual-dms-data/devices_certificates\", \"dms_store\": \"/home/$USER/virtual-dms-data/dms_certificates\", \"endpoint\":\"dev.lamassu.io/api/dmsenroller\", \"dms_name\":\"Virtual DMS\", \"common_name\":\"Virtual DMS\", \"country\":\"ES\", \"locality\":\"Mondragon\", \"organization\":\"LKS\", \"organization_unit\":\"LKS PKI\", \"state\":\"Guipuzcoa\" }, \"devmanager\":{ \"devcrt\": \"<DEV_CERTIFICATE>\", \"addr\": \"dev.lamassu.io/api/devmanager\" }, \"auth\":{ \"endpoint\":\"auth.dev.lamassu.io\", \"username\":\"enroller\", \"password\":\"enroller\" } } 5. Run the Lamassu-Default-DMS UI: go run cmd/main.go Lamassu Virtual DMS operating modes The virtual DMS has two modes of operation, on the one hand, there is the mode of creating a DMS and once the DMS is created and approved, the devices are automatically enrolled using the DMS. On the other hand, if a DMS has already been created and approved, devices can be directly enrolled without having to create a DMS. In the second case it is necessary to make sure that the certificate and the DMS key are in the directory where the DMS certificates are stored. If the Virtual-DMS is not used to create the DMS, in the directory where the certificates are stored, the certificates and keys must be created with the following format: \u251c\u2500\u2500 devices_certificates \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 dms_certificates \u251c\u2500\u2500 dms-<DMS_ID>.crt <----- Provide your certificate \u2514\u2500\u2500 dms-<DMS_ID>.key <----- Provide your private key Create the DMS, once the DMS is created, the Auto_Enroll of the devices is done. Make the Auto_Enroll of the devices indicating the ID of a DMS.","title":"Lamassu Virtual DMS"},{"location":"virtualDMS/#lamassu-virtual-dms","text":"To launch Lamassu-Virtual-DMS follow the next steps: Clone the repository and get into the directory: https://github.com/lamassuiot/lamassu-virtual-dms.git && cd lamassu-virtual-dms . Change the configuration variables of the config.json file. { \"dms\": { \"device_store\": \"<DEVICES_STORE>\", // Folder where device certificates are stored \"dms_store\": \"<DMS_STORE>\", // Folder where DMS certificates are stored \"endpoint\":\"<DMS_SERVER>\", // DMS server endpoint \"dms_name\":\"<DEFAULT_DMS>\", // DMS Name \"common_name\":\"<DEFAULT_DMS>\", // Common_name to create the CSR \"country\":\"<COUNTRY>\", // Country to create the CSR \"locality\":\"<LOCALITY>\", // Locality to create the CSR \"organization\":\"<ORGANIZATION>\", // Organization to create the CSR \"organization_unit\":\"<ORGANIZATION_UNIT>\", // Organization_unit to create the CSR \"state\":\"<STATE>\" // State to create the CSR }, \"devmanager\":{ \"devcrt\": \"<DEV_CERTIFICATE>\", // Public certificate to connect to the device-manager \"addr\": \"<DEVMANAGER_SERVER>\" //Device Manager Server Endpoint }, \"auth\":{ \"endpoint\":\"<AUTH_SERVER>\", // Authentication Server endpoint \"username\":\"<PASSWORD>\", // User name to connect to the authentication server \"password\":\"<PASSWORD>\" // Password to connect to the authentication server } } 3. Create directories to store DMS and device certificates mkdir -p /home/$USER/virtual-dms-data/devices_certificates mkdir -p /home/$USER/virtual-dms-data/dms_certificates 4. config.json file with default values { \"dms\": { \"device_store\": \"/home/$USER/virtual-dms-data/devices_certificates\", \"dms_store\": \"/home/$USER/virtual-dms-data/dms_certificates\", \"endpoint\":\"dev.lamassu.io/api/dmsenroller\", \"dms_name\":\"Virtual DMS\", \"common_name\":\"Virtual DMS\", \"country\":\"ES\", \"locality\":\"Mondragon\", \"organization\":\"LKS\", \"organization_unit\":\"LKS PKI\", \"state\":\"Guipuzcoa\" }, \"devmanager\":{ \"devcrt\": \"<DEV_CERTIFICATE>\", \"addr\": \"dev.lamassu.io/api/devmanager\" }, \"auth\":{ \"endpoint\":\"auth.dev.lamassu.io\", \"username\":\"enroller\", \"password\":\"enroller\" } } 5. Run the Lamassu-Default-DMS UI: go run cmd/main.go","title":"Lamassu Virtual DMS"},{"location":"virtualDMS/#lamassu-virtual-dms-operating-modes","text":"The virtual DMS has two modes of operation, on the one hand, there is the mode of creating a DMS and once the DMS is created and approved, the devices are automatically enrolled using the DMS. On the other hand, if a DMS has already been created and approved, devices can be directly enrolled without having to create a DMS. In the second case it is necessary to make sure that the certificate and the DMS key are in the directory where the DMS certificates are stored. If the Virtual-DMS is not used to create the DMS, in the directory where the certificates are stored, the certificates and keys must be created with the following format: \u251c\u2500\u2500 devices_certificates \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 dms_certificates \u251c\u2500\u2500 dms-<DMS_ID>.crt <----- Provide your certificate \u2514\u2500\u2500 dms-<DMS_ID>.key <----- Provide your private key Create the DMS, once the DMS is created, the Auto_Enroll of the devices is done. Make the Auto_Enroll of the devices indicating the ID of a DMS.","title":"Lamassu Virtual DMS operating modes"},{"location":"virtualDevice/","text":"Lamassu Virtual Device To launch Lamassu-Virtual-Device follow the next steps: Clone the repository and get into the directory: https://github.com/lamassuiot/lamassu-virtual-device.git && cd lamassu-virtual-device . Change the configuration variables of the config.json file. { \"certificates_dir\": \"<DEVICES_CERTIFICATES>\", // Folder where device certificates are stored \"devmanager\": { \"est_server\": \"<DEVICE_MANAGER_SERVER>\", // Device Manager Server Endpoint \"cert\":\"<DEVMANAGER_CERT>\" // Public certificate to connect to the device-manager }, \"aws\":{ \"iot_core_ca_file\": \"<AWS_CA_CERT>\", // AWS IoT Core CA Certificate \"iot_core_endpoint\": \"<AWS_ENDPOINT>\", // AWS IoT Core endpoint \"test_lambda\": \"<LAMBDA>\" // Lambda name } } 3. config.json file with default values { \"certificates_dir\": \"/home/$USER/virtual-dms-data/devices_certificates\", \"devmanager\": { \"est_server\": \"dev.lamassu.io/api/devmanager\", \"cert\":\"<DEVMANAGER_CERT>\" }, \"aws\":{ \"iot_core_ca_file\": \"<AWS_CA_CERT>\", \"iot_core_endpoint\": \"<AWS_ENDPOINT>\", \"test_lambda\": \"<LAMBDA>\" } } In case of not using the Virtual-DMS to register the devices, in the directory where the certificates are stored the certificates and keys must be created with the following format: \u251c\u2500\u2500 devices_certificates \u2502 \u251c\u2500\u2500 device-<DMS_NAME>-<DEVICE_ID> \u2502 \u2502 \u251c\u2500\u2500 certificates \u2502 \u2502 \u2502 \u251c\u2500\u2500 <CERT_SN>.crt <----- Provide your Device certificate \u2502 \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2502 \u251c\u2500\u2500 <DEVICE_ID>.csr <----- Provide your Device certificate request \u2502 \u2502 \u2514\u2500\u2500 <DEVICE_ID>.key <----- Provide your Device private key \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 dms_certificates \u251c\u2500\u2500 dms-<DMS_ID>.crt <----- Provide your DMS certificate \u2514\u2500\u2500 dms-<DMS_ID>.key <----- Provide your DMS private key 4. Run the Lamassu-Virtua-Device UI: go run cmd/main.go Lamassu Virtual device pages Lamassu Virtual Device has the following pages: Device Information View: a page showing each device's information. Choose from the dropdown the DeviceId and the Serial Number of the Certificateof to visualize the details. AWS Integration: a page to check AWS connectivity Reenroll: each device has the option to reenroll","title":"Lamassu Virtual Device"},{"location":"virtualDevice/#lamassu-virtual-device","text":"To launch Lamassu-Virtual-Device follow the next steps: Clone the repository and get into the directory: https://github.com/lamassuiot/lamassu-virtual-device.git && cd lamassu-virtual-device . Change the configuration variables of the config.json file. { \"certificates_dir\": \"<DEVICES_CERTIFICATES>\", // Folder where device certificates are stored \"devmanager\": { \"est_server\": \"<DEVICE_MANAGER_SERVER>\", // Device Manager Server Endpoint \"cert\":\"<DEVMANAGER_CERT>\" // Public certificate to connect to the device-manager }, \"aws\":{ \"iot_core_ca_file\": \"<AWS_CA_CERT>\", // AWS IoT Core CA Certificate \"iot_core_endpoint\": \"<AWS_ENDPOINT>\", // AWS IoT Core endpoint \"test_lambda\": \"<LAMBDA>\" // Lambda name } } 3. config.json file with default values { \"certificates_dir\": \"/home/$USER/virtual-dms-data/devices_certificates\", \"devmanager\": { \"est_server\": \"dev.lamassu.io/api/devmanager\", \"cert\":\"<DEVMANAGER_CERT>\" }, \"aws\":{ \"iot_core_ca_file\": \"<AWS_CA_CERT>\", \"iot_core_endpoint\": \"<AWS_ENDPOINT>\", \"test_lambda\": \"<LAMBDA>\" } } In case of not using the Virtual-DMS to register the devices, in the directory where the certificates are stored the certificates and keys must be created with the following format: \u251c\u2500\u2500 devices_certificates \u2502 \u251c\u2500\u2500 device-<DMS_NAME>-<DEVICE_ID> \u2502 \u2502 \u251c\u2500\u2500 certificates \u2502 \u2502 \u2502 \u251c\u2500\u2500 <CERT_SN>.crt <----- Provide your Device certificate \u2502 \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2502 \u251c\u2500\u2500 <DEVICE_ID>.csr <----- Provide your Device certificate request \u2502 \u2502 \u2514\u2500\u2500 <DEVICE_ID>.key <----- Provide your Device private key \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 dms_certificates \u251c\u2500\u2500 dms-<DMS_ID>.crt <----- Provide your DMS certificate \u2514\u2500\u2500 dms-<DMS_ID>.key <----- Provide your DMS private key 4. Run the Lamassu-Virtua-Device UI: go run cmd/main.go","title":"Lamassu Virtual Device"},{"location":"virtualDevice/#lamassu-virtual-device-pages","text":"Lamassu Virtual Device has the following pages: Device Information View: a page showing each device's information. Choose from the dropdown the DeviceId and the Serial Number of the Certificateof to visualize the details. AWS Integration: a page to check AWS connectivity Reenroll: each device has the option to reenroll","title":"Lamassu Virtual device pages"}]}