{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Lamassu Iot Docs Lamassu is an IoT first PKI designed for industrial scenarios. Public key infrastructure are systems in charge of creating, storing and distributing digital certificates which are used to verify that a particular public key belongs to a certain entity. PKIs creates digital certificates which map to public keys to entities, securely stores these certificates in a central repository and revokes them if needed.","title":"Welcome to Lamassu Iot Docs"},{"location":"#welcome-to-lamassu-iot-docs","text":"Lamassu is an IoT first PKI designed for industrial scenarios. Public key infrastructure are systems in charge of creating, storing and distributing digital certificates which are used to verify that a particular public key belongs to a certain entity. PKIs creates digital certificates which map to public keys to entities, securely stores these certificates in a central repository and revokes them if needed.","title":"Welcome to Lamassu Iot Docs"},{"location":"architecture/","text":"Architecture Core Services Lamassu has been designed to be modular and keep the core services as simple as possible encapsulating on each service a set of well defined responsibilities. The core services are those that bring the main functionalities of a modern PKI for industrial IoT use cases. The core services are: CA The Certificate Authority is the service in charge of issuing and managing the life cycle of the certificate. This service manages two different types of certificates: PKI Certificates : This kind of certificates are used by regular end entities such as the devices that connect to the PKI. Internal Certificates : In contrast with the previous type of certificates, these certificate authorities have a more restricted use. Their creation should be limited to the most trusted entities of the PKI. For instance, DMS certificates are issued by an internal CA named LAMASSU-DMS-MANAGER that is created on boot up. For the moment this is the only internal CA that is supported by Lamassu, but we are exploring the possibility of managing the certificates used by the services themselves. On top of the regular functionalities that can be performed on this service such as creating new CAs, issuing or revoking certificates, this service is in charge of maintaining an accurate state of the managed entities (both CA certificates and regular certificates). In order to do so, a periodic task is scheduled once a day to check the status of validity of all certificates. Warning This feature does not perform well on deployments that have issued many certificates as it is performed on a sequential single threaded process. We are working on a solution to improve this. There are 4 different status that a certificate can have: The Active state indicates that a certificate is valid and can be trusted by end entities. The Expired state indicates that a certificate has reached its expiration date and is no longer valid and cannot be trusted anymore. The Revoked state is used by PKI admins when a security incident or unexpected situations arise and the certificate or CA certificate is no longer trusted. Recently a new state has been added to the CA service, the About to expire state. This state indicates, as the name suggests, that the certificate will expire shortly. The current threshold is set to 30 days and cannot be configured. This state doesn't affect the validity of the certificate, but it is used to notify the PKI admins that the certificate is about to expire and they should take action. The CA service uses a relational database to store the issued certificates and basic information regarding the provisioned CAs. To configure the database connection, set the following environment variables: Environment Variable Description POSTGRES_HOSTNAME Hostname or address to connect to a running postgres database POSTGRES_PORT Port for the postgres instance POSTGRES_DATABASE Database to use POSTGRES_USERNAME Username credentials POSTGRES_PASSWORD Password credentials This service has been redesigned to support multiple crypto engines backends. Originally the only supported engine was the one provided by Hashicorp Vault, but the new redesign implementation allows for a more flexible golang like approach, that is by using the crypto.Signer interface. Any new crypto engine can be added by implementing this interface. To provision the CA service with a crypto engine set the following environment variable: Environment Variable Description ENGINE pkcs11 | gopem | vault The current supported crypto engines are: pkcs11 : To Use the HSM crypto engine, define the following environment variables before launching the CA service: Environment Variable Description PKCS11_DRIVER Path to the PKCS11 driver file PKCS11_LABEL Label used by the token to be used PKCS11_PIN PIN code to login and operate the token gopem - Files Environment Variable Description GOPEM_DATA Directory where the generated private keys belonging to each CA are stored Although this new design is easier to maintain and operate, we are also keeping the previous implementation of the Hashicorp Vault that does not follow the new interface. The reason being that in order to provide a Vault implementation that follows the new interface, the Enterprise Vault license is required. This is a limitation that we are working on to overcome with the new crypto engine design. The new standard deployment deprecates the use of Vault as the main backend and instead a Software HSM known as SoftHSM v2 . vault - Hashicorp Vault Environment Variable Description VAULT_ADDRESS Protocol, hostname and port to a vault instance: https://vault:8200 VAULT_ROLE_ID Role ID used by the CA service to login to vault VAULT_SECRET_ID Secret ID used by the CA service to login to vault VAULT_CA Path to the CA certificate file for https connections VAULT_UNSEAL_KEY_FILE Path to the unseal vault keys VAULT_PKI_CA_PATH Prefix to use while creating new PKI vault secrets DMS Manager The DMS Manager is the service in charge of managing the Registration Authority of the PKI. Instead of having a centralized Registration Authority, Lamassu uses a decentralized approach to be easily integrated by Device Manufacturing Systems. This way, each DMS has the authority to request the issuance of a certificate for a device being manufactured. Instead of relying on just one registration authority, Lamassu delegates the authorization of the issuance to the Local Registration Authority or LRA . Each DMS is entitled to authorize the issuance of a certificate to a subset of CAs of the entire PKI defined by the administrator. Each DMS has a list of authorized CAs that may be used during the enrollment process. Once an enrollment process is initiated, the PKI will check that the provided DMS certificate is authorized to issue certificates for the requested CA. The authorization list can be updated to add newly created CAs or remove CAs that are no longer needed. The DMS certificates that are used to authenticate the DMS are issued by an internal CA named LAMASSU-DMS-MANAGER . This CA is created by default when the PKI is deployed as stated earlier. In Lamassu there are two different types of DMS Manual DMS and Cloud Hosted DMS . In the Manual DMS the communications between the Device and the DMS does not follow a standard and is done according to the needs/requirements of the device, instead, in the Cloud Hosted DMS the communication between the device and the DMS is done using the EST protocol. On the other hand, in Cloud Hosted DMS mode the device to communicate with the DMS and to be able to request a Certificate must have a Bootstrap certificate. By means of this certificate the DMS authorizes or rejects the device's request. In Manual DMS mode the authorization is done manually by the operator. The DMS Manager service uses a relational database to store the list of authorised CAs and basic information regarding the provisioned DMS certificates. To configure the database connection, set the following environment variables: Environment Variable Description POSTGRES_HOSTNAME Hostname or address to connect to a running postgres database POSTGRES_PORT Port for the postgres instance POSTGRES_DATABASE Database to use POSTGRES_USERNAME Username credentials POSTGRES_PASSWORD Password credentials CA - The DMS service uses a Lamassu CA Client to update the status of the internal CA LAMASSU-DMS-MANAGER Environment Variable Description LAMASSU_CA_ADDRESS Lamassu CA service name and port : ca:8087 LAMASSU_CA_CERT_FILE Path to the internal CA Device manager At its core, the device manager is the main entry point for the enrollment process. It implements the EST protocol that must be used to obtain new certificates. On top of that, this service manages the registration of new devices and to keep a track of the device status. Similar to the CA service, the device manager also schedules a periodic task to check the status of the devices. This task is launched once a day to check the status of validity of all certificates associated by each device. Warning This feature does not perform well on deployments that have issued many certificates as it is performed on a sequential single threaded process. We are working on a solution to improve this. There are 5 different status a device can have: The Pending Provisioning state reflects that a device entity has been created but no certificate has been issued yet. The Fully Provisioned state indicates that a device has all the device slots with active certificates. The With warnings state indicates that a device has one or more slots with certificates that are either expired or have been revoked. The Requires Action state indicates that a device has one or more slots with certificates that are about to expire. The Decommissioned state indicates that a device has been decommissioned and no longer needs to be tracked by the PKI. Each device can have certificates signed by different authorised CAs. Slots are used to link a particular device with a CA. Each Slot can store multiple certificates, but only one of them can be in an ACTIVE status. The Device Manager service uses a relational database to store the information of the devices, certificates and slots, also, logs of devices and slots are created when an specific action is carried out, for example, in the creation. To configure the database connection, set the following environment variables: Environment Variable Description POSTGRES_HOSTNAME Hostname or address to connect to a running postgres database POSTGRES_PORT Port for the postgres instance POSTGRES_DATABASE Database to use POSTGRES_USERNAME Username credentials POSTGRES_PASSWORD Password credentials CA - The Device Manager service uses a Lamassu CA Client to update the status of the certificates associated to the devices Environment Variable Description LAMASSU_CA_ADDRESS Lamassu CA service name and port: ca:8087 LAMASSU_CA_CERT_FILE Path to the internal CA DMS - The Device Manager service uses a DMS Client to update the status of the certificates associated to the devices Environment Variable Description LAMASSU_DMS_MANAGER_ADDRESS Lamassu DMS service name and port: dms-manager:8085 LAMASSU_DMS_MANAGER_CERT_FILE Path to the internal DMS Other - Other configuration variables Environment Variable Description MINIMUM_REENROLL_DAYS The minimum days that a certificate must be valid in order to reenroll Cloud Proxy The Cloud Proxy allows integrating CAs created in cloud providers, it is in charge of syncronizing the data between cloud providers and the data of Lamassu. In particular, Lamassu incorporates AWS and Azure Cloud integration. The Cloud Proxy service uses a relational database, to store the information of the Lamassu CAs and to assign a connector Id. The connector will be used to bind each Lamassu CA to their equivalent in the external cloud providers. To configure the database connection, set the following environment variables: Environment Variable Description POSTGRES_HOSTNAME Hostname or address to connect to a running postgres database POSTGRES_PORT Port for the postgres instance POSTGRES_DATABASE Database to use POSTGRES_USERNAME Username credentials POSTGRES_PASSWORD Password credentials Consul - Cloud connectors are dynamically registered, to have a record of what services exist, they self-register in consul. Cloud Proxy consumes consul to ask which service are registered. Environment Variable Description CONSUL_PROTOCOL Protocol used to connect to consul instance : https CONSUL_HOST Hostname to a running consul instance CONSUL_PORT Port for the consul instance CONSUL_CA Path to the internal CA CA - The Device Manager service uses a Lamassu CA Client to update the status of the certificates associated to the devices Environment Variable Description LAMASSU_CA_ADDRESS Lamassu CA service name and port: lamassu-ca:8087 LAMASSU_CA_CERT_FILE Path to the internal CA Alerts Alerts is the service in charge of sending mails. Users can be subscribed to particular events, such as, when a certificate is about to expire, and they will be notified via mail. Events from all services above (Lamassu CA, DMS Manager and Device Manager) that create, revoke or modify the status of any certificate publish a message to RabbitMQ broker. The message sent to the \"alerts\" queue will be consumed by the Alerts service and will send a mail to all the users subscribed to that event. Alerts service uses a relational database, to store the information of subscriptions and last executed events information. To configure the database connection, set the following environment variables: Environment Variable Description POSTGRES_HOSTNAME Hostname or address to connect to a running postgres database POSTGRES_PORT Port for the postgres instance POSTGRES_DATABASE Database to use POSTGRES_USERNAME Username credentials POSTGRES_PASSWORD Password credentials Configuration - Alerts service allows custom configuration to send SMTP mails, such as: Environment Variable Description SMTP_FROM Email address of the sender of alerts generated by the service SMTP_INSECURE Boolean value to enable or disable secure SMTP session SMTP_ENABLE_SSL Boolean value to enable or disable SSL connection SMTP_USERNAME Username credentials SMTP_PASSWORD Password credentials SMTP_HOST Hostname or address to SMTP server: 25 SMTP_PORT Port for the SMTP instance Templates - Alerts service allows custom configuration to send SMTP mails, such as: Environment Variable Description TEMPLATE_HTML Template in HTML format to create mail format TEMPLATE_JSON Template in JSON format to rename queue names by readable text OCSP OCSP (Online Certificate Status Protocol) service, allows to determine the validity status of an X.509 digital certificate. OCSP service's response must be signed with a public private key, so the following variables must be specified. Environment Variable Description SIGNER_CERT Lamassu CA service name and port: ca:8087 SIGNER_KEY Path to the internal CA CA - OCSP service uses a Lamassu CA Client to update the status of the certificates associated to the devices Environment Variable Description LAMASSU_CA_ADDRESS Lamassu CA service name and port: ca:8087 LAMASSU_CA_CERT_FILE Path to the internal CA Lamassu Compose Lamassu Compose offers a SECURE deployment of the set of microservices required to manage an industrial PKI. The architecture presented on the following image reflects the interconnection of the different services mainly using the HTTP Protocol. The use of this deployment offers the following non functional requirements by leveraging the use of an API Gateway: Centralized point of access : Each microservice listens on a different port which ends up being challenging for developers and users. With the use of the API Gateway, the user will always access the same host and port address. Port 80 for HTTP connections and port 443 for HTTPS connections. Authentication : In order to invoke any endpoint, the API Gateway enforces each request to present a JWT. Upon receiving an HTTP request, the gateway validates the presented token against the authentication server. Authorization : Another key aspect is enforcing an authorization schema. Lamassu has been configured in such way that only specific endpoints are accessible by non admin users. Tracing : Logging the life of an HTTP request can be helpful during the debugging process of such complex application. The tracing aspect eases this process by injecting a unique identifier to each request that is then printed out by each microservice logs. Mutual TLS authentication : As mentioned earlier the gateway acts as the traffic orchestrator knowing where each service is and redirecting the traffic accordingly. To prevent any unauthorized request as well as protecting the communications channel between the Gateway itself and the upstream service, the API Gateway initiates a mutual TLS connection to ensure such thing. Cloud Providers Add-ons","title":"Architecture"},{"location":"architecture/#architecture","text":"","title":"Architecture"},{"location":"architecture/#core-services","text":"Lamassu has been designed to be modular and keep the core services as simple as possible encapsulating on each service a set of well defined responsibilities. The core services are those that bring the main functionalities of a modern PKI for industrial IoT use cases. The core services are:","title":"Core Services"},{"location":"architecture/#ca","text":"The Certificate Authority is the service in charge of issuing and managing the life cycle of the certificate. This service manages two different types of certificates: PKI Certificates : This kind of certificates are used by regular end entities such as the devices that connect to the PKI. Internal Certificates : In contrast with the previous type of certificates, these certificate authorities have a more restricted use. Their creation should be limited to the most trusted entities of the PKI. For instance, DMS certificates are issued by an internal CA named LAMASSU-DMS-MANAGER that is created on boot up. For the moment this is the only internal CA that is supported by Lamassu, but we are exploring the possibility of managing the certificates used by the services themselves. On top of the regular functionalities that can be performed on this service such as creating new CAs, issuing or revoking certificates, this service is in charge of maintaining an accurate state of the managed entities (both CA certificates and regular certificates). In order to do so, a periodic task is scheduled once a day to check the status of validity of all certificates. Warning This feature does not perform well on deployments that have issued many certificates as it is performed on a sequential single threaded process. We are working on a solution to improve this. There are 4 different status that a certificate can have: The Active state indicates that a certificate is valid and can be trusted by end entities. The Expired state indicates that a certificate has reached its expiration date and is no longer valid and cannot be trusted anymore. The Revoked state is used by PKI admins when a security incident or unexpected situations arise and the certificate or CA certificate is no longer trusted. Recently a new state has been added to the CA service, the About to expire state. This state indicates, as the name suggests, that the certificate will expire shortly. The current threshold is set to 30 days and cannot be configured. This state doesn't affect the validity of the certificate, but it is used to notify the PKI admins that the certificate is about to expire and they should take action. The CA service uses a relational database to store the issued certificates and basic information regarding the provisioned CAs. To configure the database connection, set the following environment variables: Environment Variable Description POSTGRES_HOSTNAME Hostname or address to connect to a running postgres database POSTGRES_PORT Port for the postgres instance POSTGRES_DATABASE Database to use POSTGRES_USERNAME Username credentials POSTGRES_PASSWORD Password credentials This service has been redesigned to support multiple crypto engines backends. Originally the only supported engine was the one provided by Hashicorp Vault, but the new redesign implementation allows for a more flexible golang like approach, that is by using the crypto.Signer interface. Any new crypto engine can be added by implementing this interface. To provision the CA service with a crypto engine set the following environment variable: Environment Variable Description ENGINE pkcs11 | gopem | vault The current supported crypto engines are: pkcs11 : To Use the HSM crypto engine, define the following environment variables before launching the CA service: Environment Variable Description PKCS11_DRIVER Path to the PKCS11 driver file PKCS11_LABEL Label used by the token to be used PKCS11_PIN PIN code to login and operate the token gopem - Files Environment Variable Description GOPEM_DATA Directory where the generated private keys belonging to each CA are stored Although this new design is easier to maintain and operate, we are also keeping the previous implementation of the Hashicorp Vault that does not follow the new interface. The reason being that in order to provide a Vault implementation that follows the new interface, the Enterprise Vault license is required. This is a limitation that we are working on to overcome with the new crypto engine design. The new standard deployment deprecates the use of Vault as the main backend and instead a Software HSM known as SoftHSM v2 . vault - Hashicorp Vault Environment Variable Description VAULT_ADDRESS Protocol, hostname and port to a vault instance: https://vault:8200 VAULT_ROLE_ID Role ID used by the CA service to login to vault VAULT_SECRET_ID Secret ID used by the CA service to login to vault VAULT_CA Path to the CA certificate file for https connections VAULT_UNSEAL_KEY_FILE Path to the unseal vault keys VAULT_PKI_CA_PATH Prefix to use while creating new PKI vault secrets","title":"CA"},{"location":"architecture/#dms-manager","text":"The DMS Manager is the service in charge of managing the Registration Authority of the PKI. Instead of having a centralized Registration Authority, Lamassu uses a decentralized approach to be easily integrated by Device Manufacturing Systems. This way, each DMS has the authority to request the issuance of a certificate for a device being manufactured. Instead of relying on just one registration authority, Lamassu delegates the authorization of the issuance to the Local Registration Authority or LRA . Each DMS is entitled to authorize the issuance of a certificate to a subset of CAs of the entire PKI defined by the administrator. Each DMS has a list of authorized CAs that may be used during the enrollment process. Once an enrollment process is initiated, the PKI will check that the provided DMS certificate is authorized to issue certificates for the requested CA. The authorization list can be updated to add newly created CAs or remove CAs that are no longer needed. The DMS certificates that are used to authenticate the DMS are issued by an internal CA named LAMASSU-DMS-MANAGER . This CA is created by default when the PKI is deployed as stated earlier. In Lamassu there are two different types of DMS Manual DMS and Cloud Hosted DMS . In the Manual DMS the communications between the Device and the DMS does not follow a standard and is done according to the needs/requirements of the device, instead, in the Cloud Hosted DMS the communication between the device and the DMS is done using the EST protocol. On the other hand, in Cloud Hosted DMS mode the device to communicate with the DMS and to be able to request a Certificate must have a Bootstrap certificate. By means of this certificate the DMS authorizes or rejects the device's request. In Manual DMS mode the authorization is done manually by the operator. The DMS Manager service uses a relational database to store the list of authorised CAs and basic information regarding the provisioned DMS certificates. To configure the database connection, set the following environment variables: Environment Variable Description POSTGRES_HOSTNAME Hostname or address to connect to a running postgres database POSTGRES_PORT Port for the postgres instance POSTGRES_DATABASE Database to use POSTGRES_USERNAME Username credentials POSTGRES_PASSWORD Password credentials CA - The DMS service uses a Lamassu CA Client to update the status of the internal CA LAMASSU-DMS-MANAGER Environment Variable Description LAMASSU_CA_ADDRESS Lamassu CA service name and port : ca:8087 LAMASSU_CA_CERT_FILE Path to the internal CA","title":"DMS Manager"},{"location":"architecture/#device-manager","text":"At its core, the device manager is the main entry point for the enrollment process. It implements the EST protocol that must be used to obtain new certificates. On top of that, this service manages the registration of new devices and to keep a track of the device status. Similar to the CA service, the device manager also schedules a periodic task to check the status of the devices. This task is launched once a day to check the status of validity of all certificates associated by each device. Warning This feature does not perform well on deployments that have issued many certificates as it is performed on a sequential single threaded process. We are working on a solution to improve this. There are 5 different status a device can have: The Pending Provisioning state reflects that a device entity has been created but no certificate has been issued yet. The Fully Provisioned state indicates that a device has all the device slots with active certificates. The With warnings state indicates that a device has one or more slots with certificates that are either expired or have been revoked. The Requires Action state indicates that a device has one or more slots with certificates that are about to expire. The Decommissioned state indicates that a device has been decommissioned and no longer needs to be tracked by the PKI. Each device can have certificates signed by different authorised CAs. Slots are used to link a particular device with a CA. Each Slot can store multiple certificates, but only one of them can be in an ACTIVE status. The Device Manager service uses a relational database to store the information of the devices, certificates and slots, also, logs of devices and slots are created when an specific action is carried out, for example, in the creation. To configure the database connection, set the following environment variables: Environment Variable Description POSTGRES_HOSTNAME Hostname or address to connect to a running postgres database POSTGRES_PORT Port for the postgres instance POSTGRES_DATABASE Database to use POSTGRES_USERNAME Username credentials POSTGRES_PASSWORD Password credentials CA - The Device Manager service uses a Lamassu CA Client to update the status of the certificates associated to the devices Environment Variable Description LAMASSU_CA_ADDRESS Lamassu CA service name and port: ca:8087 LAMASSU_CA_CERT_FILE Path to the internal CA DMS - The Device Manager service uses a DMS Client to update the status of the certificates associated to the devices Environment Variable Description LAMASSU_DMS_MANAGER_ADDRESS Lamassu DMS service name and port: dms-manager:8085 LAMASSU_DMS_MANAGER_CERT_FILE Path to the internal DMS Other - Other configuration variables Environment Variable Description MINIMUM_REENROLL_DAYS The minimum days that a certificate must be valid in order to reenroll","title":"Device manager"},{"location":"architecture/#cloud-proxy","text":"The Cloud Proxy allows integrating CAs created in cloud providers, it is in charge of syncronizing the data between cloud providers and the data of Lamassu. In particular, Lamassu incorporates AWS and Azure Cloud integration. The Cloud Proxy service uses a relational database, to store the information of the Lamassu CAs and to assign a connector Id. The connector will be used to bind each Lamassu CA to their equivalent in the external cloud providers. To configure the database connection, set the following environment variables: Environment Variable Description POSTGRES_HOSTNAME Hostname or address to connect to a running postgres database POSTGRES_PORT Port for the postgres instance POSTGRES_DATABASE Database to use POSTGRES_USERNAME Username credentials POSTGRES_PASSWORD Password credentials Consul - Cloud connectors are dynamically registered, to have a record of what services exist, they self-register in consul. Cloud Proxy consumes consul to ask which service are registered. Environment Variable Description CONSUL_PROTOCOL Protocol used to connect to consul instance : https CONSUL_HOST Hostname to a running consul instance CONSUL_PORT Port for the consul instance CONSUL_CA Path to the internal CA CA - The Device Manager service uses a Lamassu CA Client to update the status of the certificates associated to the devices Environment Variable Description LAMASSU_CA_ADDRESS Lamassu CA service name and port: lamassu-ca:8087 LAMASSU_CA_CERT_FILE Path to the internal CA","title":"Cloud Proxy"},{"location":"architecture/#alerts","text":"Alerts is the service in charge of sending mails. Users can be subscribed to particular events, such as, when a certificate is about to expire, and they will be notified via mail. Events from all services above (Lamassu CA, DMS Manager and Device Manager) that create, revoke or modify the status of any certificate publish a message to RabbitMQ broker. The message sent to the \"alerts\" queue will be consumed by the Alerts service and will send a mail to all the users subscribed to that event. Alerts service uses a relational database, to store the information of subscriptions and last executed events information. To configure the database connection, set the following environment variables: Environment Variable Description POSTGRES_HOSTNAME Hostname or address to connect to a running postgres database POSTGRES_PORT Port for the postgres instance POSTGRES_DATABASE Database to use POSTGRES_USERNAME Username credentials POSTGRES_PASSWORD Password credentials Configuration - Alerts service allows custom configuration to send SMTP mails, such as: Environment Variable Description SMTP_FROM Email address of the sender of alerts generated by the service SMTP_INSECURE Boolean value to enable or disable secure SMTP session SMTP_ENABLE_SSL Boolean value to enable or disable SSL connection SMTP_USERNAME Username credentials SMTP_PASSWORD Password credentials SMTP_HOST Hostname or address to SMTP server: 25 SMTP_PORT Port for the SMTP instance Templates - Alerts service allows custom configuration to send SMTP mails, such as: Environment Variable Description TEMPLATE_HTML Template in HTML format to create mail format TEMPLATE_JSON Template in JSON format to rename queue names by readable text","title":"Alerts"},{"location":"architecture/#ocsp","text":"OCSP (Online Certificate Status Protocol) service, allows to determine the validity status of an X.509 digital certificate. OCSP service's response must be signed with a public private key, so the following variables must be specified. Environment Variable Description SIGNER_CERT Lamassu CA service name and port: ca:8087 SIGNER_KEY Path to the internal CA CA - OCSP service uses a Lamassu CA Client to update the status of the certificates associated to the devices Environment Variable Description LAMASSU_CA_ADDRESS Lamassu CA service name and port: ca:8087 LAMASSU_CA_CERT_FILE Path to the internal CA","title":"OCSP"},{"location":"architecture/#lamassu-compose","text":"Lamassu Compose offers a SECURE deployment of the set of microservices required to manage an industrial PKI. The architecture presented on the following image reflects the interconnection of the different services mainly using the HTTP Protocol. The use of this deployment offers the following non functional requirements by leveraging the use of an API Gateway: Centralized point of access : Each microservice listens on a different port which ends up being challenging for developers and users. With the use of the API Gateway, the user will always access the same host and port address. Port 80 for HTTP connections and port 443 for HTTPS connections. Authentication : In order to invoke any endpoint, the API Gateway enforces each request to present a JWT. Upon receiving an HTTP request, the gateway validates the presented token against the authentication server. Authorization : Another key aspect is enforcing an authorization schema. Lamassu has been configured in such way that only specific endpoints are accessible by non admin users. Tracing : Logging the life of an HTTP request can be helpful during the debugging process of such complex application. The tracing aspect eases this process by injecting a unique identifier to each request that is then printed out by each microservice logs. Mutual TLS authentication : As mentioned earlier the gateway acts as the traffic orchestrator knowing where each service is and redirecting the traffic accordingly. To prevent any unauthorized request as well as protecting the communications channel between the Gateway itself and the upstream service, the API Gateway initiates a mutual TLS connection to ensure such thing.","title":"Lamassu Compose"},{"location":"architecture/#cloud-providers-add-ons","text":"","title":"Cloud Providers Add-ons"},{"location":"manage/","text":"Managing Lamassu Certificate rotation By default, all self-signed certificates (both upstream and downstream) have a lifespan of 365 days. At that point it will be necessary to regenerate the expired certificates: Regenerate the certificates: cd tls-certificates ./gen-upstream-certs.sh ./gen-downstream-certs.sh cd .. Reboot all services: docker-compose down docker-compose up -d Backup strategy Restoring backups","title":"Managing Lamassu"},{"location":"manage/#managing-lamassu","text":"","title":"Managing Lamassu"},{"location":"manage/#certificate-rotation","text":"By default, all self-signed certificates (both upstream and downstream) have a lifespan of 365 days. At that point it will be necessary to regenerate the expired certificates: Regenerate the certificates: cd tls-certificates ./gen-upstream-certs.sh ./gen-downstream-certs.sh cd .. Reboot all services: docker-compose down docker-compose up -d","title":"Certificate rotation"},{"location":"manage/#backup-strategy","text":"","title":"Backup strategy"},{"location":"manage/#restoring-backups","text":"","title":"Restoring backups"},{"location":"protocols/","text":"Protocols Lamassu supports a set of standards to perform some of its key functionalities such as enrolling devices as well as validating the status of a given certificate. This section aims to describe those protocols as well as explaining how them with practical examples. OCSP The Online Certificate Status Protocol or OCSP for short, is a protocol used to determine the current status of a digital certificate without requiring the use of Certificate Revocation Lists (CRLs). As defined by the standard, there are two possible methods that can be used to perform the http request: Method Path Headers Body payload Used when GET {url}/{url-encoding of base-64 encoding of the DER encoding of the OCSPRequest} Recommended when the encoded request is less than 255 bytes PUT {url} Content-Type: application/ocsp-request Binary value of the DER encoding of the OCSPRequest Can always be used GET Request OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request OCSP_REQUEST=$(openssl ocsp -CAfile $CA_CERTIFICATE -issuer $CA_CERTIFICATE -cert $DEVICE_CERTIFICATE -reqout - | base64 -w 0) Check the status of the certificate curl --location --request GET \"https://$OCSP_SERVER/api/ocsp/$OCSP_REQUEST\" > ocspresponse.der openssl ocsp -respin ocspresponse.der -VAfile root-ca.pem -resp_text package main import ( \"crypto/x509\" \"encoding/base64\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } encodedRequest := base64 . StdEncoding . EncodeToString ( ocspRequestBytes ) fmt . Println ( encodedRequest ) reqURL := ocspServer + \"/\" + encodedRequest resp , err := http . Get ( reqURL ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) } POST Request OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request openssl ocsp -issuer ca.crt -cert dev.crt -reqout - > ocsp-request-post.der Check the status of the certificate curl --location --request POST \"https://$DOMAIN/api/ocsp/\" --header 'Content-Type: application/ocsp-request' --data-binary '@ocsp-request-post.der' > ocsp-response-post.der -k openssl ocsp -respin ocsp-response-post.der -VAfile root-ca.pem -resp_text package main import ( \"bytes\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } resp , err := http . Post ( ocspServer , \"application/ocsp-request\" , bytes . NewReader ( ocspRequestBytes )) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) } EST The core mechanism to obtain valid certificates for your devices is using the enrollment process described by the EST protocol. EST or Enrollment over Secure Transport establishes a set of standardized endpoints. The following table sums up all endpoints defined by the EST protocol and wether or not are supported by the current implementation. Operation Operation Path Required by RFC7030 Supported Distribution of CA Certificates /api/devmanager/.well-known/cacerts Enrollment of Clients /api/devmanager/.well-known/simpleenroll Re-enrollment of Clients /api/devmanager/.well-known/simplereenroll Full CMC /api/devmanager/.well-known/fullcmc Server-Side Key Generation /api/devmanager/.well-known/serverkeygen CSR Attributes /api/devmanager/.well-known/csrattrs Distribution of CA Certificates GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates estclient cacerts -server $DOMAIN/api/devmanager -explicit root-ca.pem -out cacerts.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" clientcrt := \"dms.crt\" clientkey := \"dms.key\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( clientcrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( clientkey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cas , err := estClient . CACerts ( context . Background ()) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } } Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates curl https://$DOMAIN/api/devmanager/.well-known/est/cacerts -o cacerts.p7 --cacert root-ca.pem openssl base64 -d -in cacerts.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cacerts.pem Enrollment of Devices GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with an existing private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient enroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out cert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecsr := \"device.csr\" devicecrt := \"device.crt\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Enroll ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with an existing private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/simpleenroll --cert $DMS_CRT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cert.pem Re-enrollment of Devices GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Reenrolling estclient reenroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -key $DEVICE_KEY -certs $DEVICE_CRT -out newcert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( devicecrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( devicekey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Reenroll ( context . Background (), csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key exprot DEVICE_CSR=device.csr Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device enroll CSR sed '/CERTIFICATE/d' device.csr > device_enroll.csr Reenrolling curl https://$DOMAIN/api/devmanager/.well-known/est/simplereenroll --cert $DEVICE_CRT --key $DEVICE_KEY -s -o newcert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in newcert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out $DEVICE_CRT Server Key Generation of Devices GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with a server-generated private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient serverkeygen -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out device.crt -keyout device.key package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , key , err := estClient . ServerKeyGen ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) b = pem . Block { Type : \"PRIVATE KEY\" , Bytes : key } keyPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicekey , keyPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with a server-generated private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/serverkeygen --cert $DMS_CERT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" cat cert.p7 | sed -ne '/application\\/pkcs7-mime/,/-estServerKeyGenBoundary/p' | sed '/-/d' > crt.p7 openssl base64 -d -in crt.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device.pem","title":"Protocols"},{"location":"protocols/#protocols","text":"Lamassu supports a set of standards to perform some of its key functionalities such as enrolling devices as well as validating the status of a given certificate. This section aims to describe those protocols as well as explaining how them with practical examples.","title":"Protocols"},{"location":"protocols/#ocsp","text":"The Online Certificate Status Protocol or OCSP for short, is a protocol used to determine the current status of a digital certificate without requiring the use of Certificate Revocation Lists (CRLs). As defined by the standard, there are two possible methods that can be used to perform the http request: Method Path Headers Body payload Used when GET {url}/{url-encoding of base-64 encoding of the DER encoding of the OCSPRequest} Recommended when the encoded request is less than 255 bytes PUT {url} Content-Type: application/ocsp-request Binary value of the DER encoding of the OCSPRequest Can always be used","title":"OCSP"},{"location":"protocols/#get-request","text":"OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request OCSP_REQUEST=$(openssl ocsp -CAfile $CA_CERTIFICATE -issuer $CA_CERTIFICATE -cert $DEVICE_CERTIFICATE -reqout - | base64 -w 0) Check the status of the certificate curl --location --request GET \"https://$OCSP_SERVER/api/ocsp/$OCSP_REQUEST\" > ocspresponse.der openssl ocsp -respin ocspresponse.der -VAfile root-ca.pem -resp_text package main import ( \"crypto/x509\" \"encoding/base64\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } encodedRequest := base64 . StdEncoding . EncodeToString ( ocspRequestBytes ) fmt . Println ( encodedRequest ) reqURL := ocspServer + \"/\" + encodedRequest resp , err := http . Get ( reqURL ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) }","title":"GET Request"},{"location":"protocols/#post-request","text":"OpenSSL Go Define the OCSP server endpoint as well as the export OCSP_SERVER=dev.lamassu.io:443 export CA_CERTIFICATE=issuer_ca.crt export DEVICE_CERTIFICATE=device.crt Obtain the Root certificate used by the server openssl s_client -connect $OCSP_SERVER 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create the OCSP Request openssl ocsp -issuer ca.crt -cert dev.crt -reqout - > ocsp-request-post.der Check the status of the certificate curl --location --request POST \"https://$DOMAIN/api/ocsp/\" --header 'Content-Type: application/ocsp-request' --data-binary '@ocsp-request-post.der' > ocsp-response-post.der -k openssl ocsp -respin ocsp-response-post.der -VAfile root-ca.pem -resp_text package main import ( \"bytes\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\" ) func main () { ocspServer := \"http://localhost:9098\" issuerCA := \"ca.crt\" certificateToCheck := \"device.crt\" caPEM , err := ioutil . ReadFile ( issuerCA ) if err != nil { fmt . Println ( \"Could not load CA certificate\" ) os . Exit ( 1 ) } caPemBlock , _ := pem . Decode ( caPEM ) ca , err := x509 . ParseCertificate ( caPemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } devicePEM , err := ioutil . ReadFile ( certificateToCheck ) if err != nil { fmt . Println ( \"Could not load Device certificate\" ) os . Exit ( 1 ) } devicePemBlock , _ := pem . Decode ( devicePEM ) device , err := x509 . ParseCertificate ( devicePemBlock . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } ocspRequestBytes , err := ocsp . CreateRequest ( device , ca , & ocsp . RequestOptions {}) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } resp , err := http . Post ( ocspServer , \"application/ocsp-request\" , bytes . NewReader ( ocspRequestBytes )) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } if resp . StatusCode != http . StatusOK { os . Exit ( 1 ) } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { os . Exit ( 1 ) } resp . Body . Close () ocspResponse , err := ocsp . ParseResponse ( body , nil ) if err != nil { fmt . Println ( \"Could not parse OCSP response \" , err ) os . Exit ( 1 ) } fmt . Println ( ocspResponse . Status == ocsp . Good ) fmt . Println ( ocspResponse . Status == ocsp . Revoked ) fmt . Println ( ocspResponse . RevokedAt ) }","title":"POST Request"},{"location":"protocols/#est","text":"The core mechanism to obtain valid certificates for your devices is using the enrollment process described by the EST protocol. EST or Enrollment over Secure Transport establishes a set of standardized endpoints. The following table sums up all endpoints defined by the EST protocol and wether or not are supported by the current implementation. Operation Operation Path Required by RFC7030 Supported Distribution of CA Certificates /api/devmanager/.well-known/cacerts Enrollment of Clients /api/devmanager/.well-known/simpleenroll Re-enrollment of Clients /api/devmanager/.well-known/simplereenroll Full CMC /api/devmanager/.well-known/fullcmc Server-Side Key Generation /api/devmanager/.well-known/serverkeygen CSR Attributes /api/devmanager/.well-known/csrattrs","title":"EST"},{"location":"protocols/#distribution-of-ca-certificates","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates estclient cacerts -server $DOMAIN/api/devmanager -explicit root-ca.pem -out cacerts.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" clientcrt := \"dms.crt\" clientkey := \"dms.key\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( clientcrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( clientkey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cas , err := estClient . CACerts ( context . Background ()) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } } Define the DOMAIN as well as the export DOMAIN=dev.lamassu.io Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Obtaining CAs certificates curl https://$DOMAIN/api/devmanager/.well-known/est/cacerts -o cacerts.p7 --cacert root-ca.pem openssl base64 -d -in cacerts.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cacerts.pem","title":"Distribution of CA Certificates"},{"location":"protocols/#enrollment-of-devices","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with an existing private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient enroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out cert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecsr := \"device.csr\" devicecrt := \"device.crt\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Enroll ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with an existing private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/simpleenroll --cert $DMS_CRT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cert.pem","title":"Enrollment of Devices"},{"location":"protocols/#re-enrollment-of-devices","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Reenrolling estclient reenroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -key $DEVICE_KEY -certs $DEVICE_CRT -out newcert.pem package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( devicecrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( devicekey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , err := estClient . Reenroll ( context . Background (), csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export DEVICE_CRT=device.crt export DEVICE_KEY=device.key exprot DEVICE_CSR=device.csr Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device enroll CSR sed '/CERTIFICATE/d' device.csr > device_enroll.csr Reenrolling curl https://$DOMAIN/api/devmanager/.well-known/est/simplereenroll --cert $DEVICE_CRT --key $DEVICE_KEY -s -o newcert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" openssl base64 -d -in newcert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out $DEVICE_CRT","title":"Re-enrollment of Devices"},{"location":"protocols/#server-key-generation-of-devices","text":"GlobalSign Go Curl Install GlobalSign Est Client go install github.com/globalsign/est/cmd/estclient@latest Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Enrolling with a server-generated private key openssl genrsa 4096 > key.pem estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem estclient serverkeygen -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out device.crt -keyout device.key package main import ( \"context\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io/ioutil\" \"os\" \"github.com/lamassuiot/lamassuiot/pkg/est/client\" ) func main () { estServerAddr := \"dev.lamassu.io/api/devmanager\" servercrt := \"server.crt\" dmscrt := \"dms.crt\" dmskey := \"dms.key\" devicecrt := \"device.crt\" devicekey := \"device.key\" devicecsr := \"device.csr\" ca_name := \"Test-CA\" caCert , err := ioutil . ReadFile ( servercrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } caCertPool := x509 . NewCertPool () caCertPool . AppendCertsFromPEM ( caCert ) certContent , err := ioutil . ReadFile ( dmscrt ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ := pem . Decode ( certContent ) crt , err := x509 . ParseCertificate ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } certContent , err = ioutil . ReadFile ( devicecsr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cpb , _ = pem . Decode ( certContent ) csr , err := x509 . ParseCertificateRequest ( cpb . Bytes ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } key , err := ioutil . ReadFile ( dmskey ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } estClient , err := client . NewLamassuEstClient ( estServerAddr , caCertPool , crt , key , nil ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } cert , key , err := estClient . ServerKeyGen ( context . Background (), ca_name , csr ) if err != nil { fmt . Println ( err ) os . Exit ( 1 ) } b := pem . Block { Type : \"CERTIFICATE\" , Bytes : cert . Raw } certPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicecrt , certPEM , 0777 ) b = pem . Block { Type : \"PRIVATE KEY\" , Bytes : key } keyPEM := pem . EncodeToMemory ( & b ) ioutil . WriteFile ( devicekey , keyPEM , 0777 ) } Define environment variables as well as the export DOMAIN=dev.lamassu.io export CA_NAME=Test-CA export DEVICE_ID=$(uuidgen) export DMS_CERT=dms.crt export DMS_KEY=dms.key Note The name of the CA has to be that of a CA that has the DMS as Authorized_CAs. Obtain the Root certificate used by the server openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem Create device CSR and private Key openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\" sed '/CERTIFICATE/d' device.csr > device_enroll.csr Enrolling with a server-generated private key curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/serverkeygen --cert $DMS_CERT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\" cat cert.p7 | sed -ne '/application\\/pkcs7-mime/,/-estServerKeyGenBoundary/p' | sed '/-/d' > crt.p7 openssl base64 -d -in crt.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device.pem","title":"Server Key Generation of Devices"},{"location":"setup/","text":"Setup Lamassu Compose is the official release containing the scripts and resources required to deploy all microservices such as the CA component, the VA component or the RA components to name a few. Requirements jq . Get the latest version: https://stedolan.github.io/jq/download/ docker and docker-compose : Get the latest version: https://docs.docker.com/engine/install/ubuntu/ and https://docs.docker.com/compose/install/ Have a working DNS server able to resolve the domain used during the installation process or add the following content to the /etc/hosts file, replacing the dev.lamassu.io domain with your own: 127.0.0.1 dev.lamassu.io 127.0.0.1 vault.dev.lamassu.io 127.0.0.1 auth.dev.lamassu.io 127.0.0.1 tracing.dev.lamassu.io 127.0.0.1 consul.dev.lamassu.io Setup Get and run the installer script: curl -fsSL https://raw.githubusercontent.com/lamassuiot/lamassu-compose/release/lamassu-compose.sh -o lamassu-compose.sh sudo bash lamassu-compose.sh --domain dev.lamassu.io --with-simulators --compose-version develop --simulation-version main OPTIONAL : Import your certificates: The lamassu-compose.sh script also generates self-signed for the downstream certificates. It is possible to provide other valid certificates by replacing the following files: lamassu-compose/tls-certificates \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt <----- Provide your certificate \u2514\u2500\u2500 tls.key <----- Provide your private key Once you replace this certificates, restart the api-gateway to obtain the imported certificates: docker-compose rm -s -f api-gateway dms-default docker-compose up -d api-gateway dms-default Final notes: \ud83d\ude80 You are ready to go \ud83d\ude80 Note Keycloak is your auth provider. During the installation process, the service is provisioned with 2 users with different roles: Username: enroller Password: enroller Role: admin Username: operator Password: operator Role: operator You can change those credentials (or create new users) using keycloak's UI available at: https://auth.<DOMAIN> Deploy AWS IoT Core connectors Requirements In order tu run the connector, you must have: NodeJS: https://nodejs.org/en/ AWS CDK v1: https://docs.aws.amazon.com/cdk/v1/guide/cli.html Deployment Download the AWS Connector source code: git clone https://github.com/lamassuiot/lamassu-aws-connector.git Configure the AWS Credentials. Those values will be used by the Lamassu AWS Connector as well as the CDK. export AWS_ACCESS_KEY_ID=<AWS_ACCESS_KEY_ID> export AWS_SECRET_ACCESS_KEY=<AWS_SECRET_ACCESS_KEY> export AWS_ACCOUNT_ID=<AWS_ACCOUNT_ID> export AWS_DEFAULT_REGION=<AWS_DEFAULT_REGION> Provide a friendly name for the Lamassu AWS Connector. This name will be displayed in the UI export CONNECTOR_NAME=Lamassu IoT AWS Account Substitute the aws-connector .env file: envsubst < .env | tee .env Generate the TLS certificates used by the connector. You must have access to the main CA certificate and private key that where generated during Lamassu installation. export INTERNAL_CA_CERT=<CHANGE_TO_LAMASSU_INSTALLATION_PATH>/tls-certificates/upstream/ca.crt export INTERNAL_CA_KEY=<CHANGE_TO_LAMASSU_INSTALLATION_PATH>/tls-certificates/upstream/ca.key After defining those variables, run the following OpenSSL commands: openssl genrsa -out aws-connector.key 4096 openssl req -new -key aws-connector.key -out aws-connector.csr -subj \"/CN=aws-connector\" openssl x509 -req -extfile <(printf \"subjectAltName=DNS:aws-connector\") -in aws-connector.csr -days 365 -CA $INTERNAL_CA_CERT -CAkey $INTERNAL_CA_KEY -CAcreateserial -out aws.crt Deploy the required AWS services by using the CDK: cd aws-connector npm i cdk deploy Start the connector: docker-compose up -d","title":"Setup"},{"location":"setup/#setup","text":"Lamassu Compose is the official release containing the scripts and resources required to deploy all microservices such as the CA component, the VA component or the RA components to name a few.","title":"Setup"},{"location":"setup/#requirements","text":"jq . Get the latest version: https://stedolan.github.io/jq/download/ docker and docker-compose : Get the latest version: https://docs.docker.com/engine/install/ubuntu/ and https://docs.docker.com/compose/install/ Have a working DNS server able to resolve the domain used during the installation process or add the following content to the /etc/hosts file, replacing the dev.lamassu.io domain with your own: 127.0.0.1 dev.lamassu.io 127.0.0.1 vault.dev.lamassu.io 127.0.0.1 auth.dev.lamassu.io 127.0.0.1 tracing.dev.lamassu.io 127.0.0.1 consul.dev.lamassu.io","title":"Requirements"},{"location":"setup/#setup_1","text":"Get and run the installer script: curl -fsSL https://raw.githubusercontent.com/lamassuiot/lamassu-compose/release/lamassu-compose.sh -o lamassu-compose.sh sudo bash lamassu-compose.sh --domain dev.lamassu.io --with-simulators --compose-version develop --simulation-version main OPTIONAL : Import your certificates: The lamassu-compose.sh script also generates self-signed for the downstream certificates. It is possible to provide other valid certificates by replacing the following files: lamassu-compose/tls-certificates \u251c\u2500\u2500 upstream \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 downstream \u251c\u2500\u2500 tls.crt <----- Provide your certificate \u2514\u2500\u2500 tls.key <----- Provide your private key Once you replace this certificates, restart the api-gateway to obtain the imported certificates: docker-compose rm -s -f api-gateway dms-default docker-compose up -d api-gateway dms-default Final notes: \ud83d\ude80 You are ready to go \ud83d\ude80 Note Keycloak is your auth provider. During the installation process, the service is provisioned with 2 users with different roles: Username: enroller Password: enroller Role: admin Username: operator Password: operator Role: operator You can change those credentials (or create new users) using keycloak's UI available at: https://auth.<DOMAIN>","title":"Setup"},{"location":"setup/#deploy-aws-iot-core-connectors","text":"","title":"Deploy AWS IoT Core connectors"},{"location":"setup/#requirements_1","text":"In order tu run the connector, you must have: NodeJS: https://nodejs.org/en/ AWS CDK v1: https://docs.aws.amazon.com/cdk/v1/guide/cli.html","title":"Requirements"},{"location":"setup/#deployment","text":"Download the AWS Connector source code: git clone https://github.com/lamassuiot/lamassu-aws-connector.git Configure the AWS Credentials. Those values will be used by the Lamassu AWS Connector as well as the CDK. export AWS_ACCESS_KEY_ID=<AWS_ACCESS_KEY_ID> export AWS_SECRET_ACCESS_KEY=<AWS_SECRET_ACCESS_KEY> export AWS_ACCOUNT_ID=<AWS_ACCOUNT_ID> export AWS_DEFAULT_REGION=<AWS_DEFAULT_REGION> Provide a friendly name for the Lamassu AWS Connector. This name will be displayed in the UI export CONNECTOR_NAME=Lamassu IoT AWS Account Substitute the aws-connector .env file: envsubst < .env | tee .env Generate the TLS certificates used by the connector. You must have access to the main CA certificate and private key that where generated during Lamassu installation. export INTERNAL_CA_CERT=<CHANGE_TO_LAMASSU_INSTALLATION_PATH>/tls-certificates/upstream/ca.crt export INTERNAL_CA_KEY=<CHANGE_TO_LAMASSU_INSTALLATION_PATH>/tls-certificates/upstream/ca.key After defining those variables, run the following OpenSSL commands: openssl genrsa -out aws-connector.key 4096 openssl req -new -key aws-connector.key -out aws-connector.csr -subj \"/CN=aws-connector\" openssl x509 -req -extfile <(printf \"subjectAltName=DNS:aws-connector\") -in aws-connector.csr -days 365 -CA $INTERNAL_CA_CERT -CAkey $INTERNAL_CA_KEY -CAcreateserial -out aws.crt Deploy the required AWS services by using the CDK: cd aws-connector npm i cdk deploy Start the connector: docker-compose up -d","title":"Deployment"},{"location":"tests/","text":"Tests Integration test are carried out to check the proper functionabillity of the server. The tests, start up the same server used in production with an empty database and run against the server using HTTP. To create the test, httpexpect library has been used; a set of chainable builders for HTTP requests and assertions for HTTP responses and payload, on top of net/http and several utility packages. Each test-case has three arguments: the name of the test, an instance of the service and a httpexpect.Expect object, upon which the rest call will be made. Passing an instance of the service per test, allows custom inicialization of the database per test. Also, as the service used is the exact same used in production, the calls made from one service to another are mantained, allowing to check the interoperability from services. The response obtained from the httpexpect.Expect object will be evaluated; the response's keys and values will be revised to compare with the expected ones. If the expected results don\u00b4t match with the obtained ones, an error will occur, allowing the developers to notice and fix it before releasing it into production. Three different branches are differenciated: Development: this branch is used for testing purposes whenever a service is modified to check the proper functionabillity of the same service. Release: this branch is used for testing purposes whenever a service is modified to check the proper functionabillity of the all services. Main: once the test are passed successfully, changes are published in main branch. Coverage The following commands can be used to calculate the coverage of the system: go test -json -v ./pkg/... -cover -coverprofile=coverage.out -coverpkg=./... go tool cover -html=coverage.out -o coverage.html go tool cover -func coverage.out | grep total | awk '{print substr($3, 1, length($3)-1)}' | .github/coverage-badge.sh go tool cover -func coverage.out | grep total The total and relative percentages of each component can be found in the resulting cover.html file. Opening the file in the browser, will mark the tested code in green and the untested one in red. The resulting cover.out file, can be imported to go-cover-treemap.io webpage to generate a visual representation of the coverage results: Pipeline The test are run against the server using HTTP, the top layer of the system. Facilitating the task of testing the layers below.","title":"Tests"},{"location":"tests/#tests","text":"Integration test are carried out to check the proper functionabillity of the server. The tests, start up the same server used in production with an empty database and run against the server using HTTP. To create the test, httpexpect library has been used; a set of chainable builders for HTTP requests and assertions for HTTP responses and payload, on top of net/http and several utility packages. Each test-case has three arguments: the name of the test, an instance of the service and a httpexpect.Expect object, upon which the rest call will be made. Passing an instance of the service per test, allows custom inicialization of the database per test. Also, as the service used is the exact same used in production, the calls made from one service to another are mantained, allowing to check the interoperability from services. The response obtained from the httpexpect.Expect object will be evaluated; the response's keys and values will be revised to compare with the expected ones. If the expected results don\u00b4t match with the obtained ones, an error will occur, allowing the developers to notice and fix it before releasing it into production. Three different branches are differenciated: Development: this branch is used for testing purposes whenever a service is modified to check the proper functionabillity of the same service. Release: this branch is used for testing purposes whenever a service is modified to check the proper functionabillity of the all services. Main: once the test are passed successfully, changes are published in main branch.","title":"Tests"},{"location":"tests/#coverage","text":"The following commands can be used to calculate the coverage of the system: go test -json -v ./pkg/... -cover -coverprofile=coverage.out -coverpkg=./... go tool cover -html=coverage.out -o coverage.html go tool cover -func coverage.out | grep total | awk '{print substr($3, 1, length($3)-1)}' | .github/coverage-badge.sh go tool cover -func coverage.out | grep total The total and relative percentages of each component can be found in the resulting cover.html file. Opening the file in the browser, will mark the tested code in green and the untested one in red. The resulting cover.out file, can be imported to go-cover-treemap.io webpage to generate a visual representation of the coverage results:","title":"Coverage"},{"location":"tests/#pipeline","text":"The test are run against the server using HTTP, the top layer of the system. Facilitating the task of testing the layers below.","title":"Pipeline"},{"location":"usage/","text":"Getting Started Before jumping any further, please check out the installation process to deploy all Lamassu services. This section will guide you through the basic functionalities provided by our PKI to start provisioning your devices. Overview Create a new Certification Authority The first step to provision your devices with digital certificates is to create the Certification Authority. The role of a CA is to issue and manage all the certificates. To create a new CA, fill the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs. Register a new Device Manufacturing System Lamassu is a PKI designed for the industrial and IoT sector. To better integrate this PKI in real life manufacturing system, Lamassu delegates the issuance of device certificate to the factory itself. First lets dive into the Device Manufacturing System (DMS for short) registration step by step. After that, a couple of examples will demonstrate how to start enrolling your devices using the Lamassu's Virtual DMS software as well as using the UI. Device manufacturing process tend to be highly automated. Provisioning the devices with digital identities should not slow down the fabrication process. Lamassu addresses this challenge introducing the DMS concept as core. One of the factories operators stars the process by generating a DMS registration request contained in a Certificate Signing Request also referred as CSR. This CSR is then sent to the DMS Enroller service to be approved by one of the PKI Administrators: The Administrator then decides if the request is approved or denied. If it decision is to approve the DMS registration request, the Administrator must specify which CAs will that particular DSM be entitled to issue certificates with: Once, and only if, the DMS registration request is approved, then the Operator must retrieve the signed CSR and pass it to the DMS software that will be in charge off requesting the issuance of new digital certificates for the manufactured devices: Finally, the DMS is able to request new x509 certificates for its manufactured devices. The DMS may be assisted by additional tools to obtain the manufactured device unique identifier. Note Envoy is used as an API gateway in this project. Currently Envoy is written to use Boring SSl as the TLS provider. It does not support secp224r1 signing method, which is used to create ECDSA224 keys. Therefore, enroll and reenroll methods will return a error when using this key. Let's register a new DMS instance: Manual DMS Operator - Authenticate the user: OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Operator - Request the registration for a new DMS instance: DMS_NAME=MyDMS DMS_SUBJECT_COUNTRY=ES DMS_SUBJECT_STATE=Gipuzkoa DMS_SUBJECT_LOCALITY=Donostia DMS_SUBJECT_ORGANIZATION=Lamassu DMS_SUBJECT_ORGANIZATION_UNIT=IoT DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsmanager/v1/\" \\ --header \"Authorization: Bearer $OPERATOR_TOKEN\" \\ --data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"organization_unit\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}}\") DMS_NAME=$(echo $DMS_REG_RESPONSE | jq -r .dms.name) echo $DMS_REG_RESPONSE | jq -r .private_key | base64 -d > dms.key Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Authorize the enrollment with all the provisioned CAs AUTHORIZED_CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .cas[].name | jq -s) curl -k --location --request PUT \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME/status\" \\ --header \"Authorization: Bearer $ENROLLER_TOKEN\" \\ --data-raw \"{\\\"status\\\":\\\"APPROVED\\\"}\" curl -k --location --request PUT \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME/auth\" \\ --header \"Authorization: Bearer $ENROLLER_TOKEN\" \\ --data-raw \"{\\\"authorized_cas\\\":$AUTHORIZED_CAS}\" Operator - Get the DMS certificate: curl -k \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .certificate | base64 -d > dms.crt Cloud Hosted DMS When creating a Cloud Hosted DMS the Payload of the request has three more parameters: BootstrapCAs : Bootstrap CAs, i.e. the Bootstrap certificate used by the device has to be issued by one of these CAs, in case it is not issued by any of these CAs the device request will not be authorized. IsCloudDMS : It is a boolean parameter. In this case it always has the same value true . CaName : The CA through which the device certificate is to be issued. It has the same function as the Authorized CAs. In this case, by passing the CA name as a parameter, it is not necessary to approve the DMS once it has been created. Operator - Authenticate the user: OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Get all the provisioned CAs CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .cas[].name | jq -s) Operator - Request the registration for a new DMS instance: DMS_NAME=MyDMS DMS_SUBJECT_COUNTRY=ES DMS_SUBJECT_STATE=Gipuzkoa DMS_SUBJECT_LOCALITY=Donostia DMS_SUBJECT_ORGANIZATION=Lamassu DMS_SUBJECT_ORGANIZATION_UNIT=IoT CA_NAME=$(echo $CAS | jq .[0] -r) DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsmanager/v1\" \\ --header \"Authorization: Bearer $OPERATOR_TOKEN\" \\ --data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"organization_unit\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}, \\\"host_cloud_dms\\\":true, \\\"ca_name\\\": &CA_NAME,\\\"bootstrap_cas\\\":$CAS }\") DMS_NAME=$(echo $DMS_REG_RESPONSE | jq -r .dms.name) echo $DMS_REG_RESPONSE | jq -r .private_key | base64 -d > dms.key Operator - Get the DMS certificate: curl -k \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .certificate | base64 -d > dms.crt Provision your devices with x509 Certificates The enrollment process is the way to go to obtain a certificate issued by one of the provisioned CAs. As described in the RFC document, Lamassu requires the authentication of the client requesting the enrollment using a certificate as well as the private key of an issued DMS to perform a mutual TLS connection. By using this type of TLS connection, the client is able to authenticate the server, and also, the server is able to authenticate the client. Although the /api/devmanager/.well-known/cacerts endpoint returns the list containing all the manged CAs by the PKI, each DMS is entitled to request the issuance of a certificate with an authorized CA. For instance, the PKI may have the following CAs: CA1 , CA2 , CA3 and CA4 . The /api/devmanager/.well-known/cacerts would return all four CAs. Then, a new DMS is registered. the PKI administrator approves the DMS registration by authorizing such DMS to issue certificates with CA1 and CA4 . This process is known as the DMS registration process . Once the DMS is completely registered, it can now start performing the EST enrollment process. Check out the previous section to understand what a DMS does. Let's first obtain the CA list for a particular DMS: Manual DMS First, authenticate and obtain a valid JWT OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Obtain the CA list: ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .authorized_cas) Select one of the entitled the CAs from the previous list: Note You can manually spefify the SELECTED_CA . Otherwise you can enroll the device with the first entitled CA using the following command. SELECTED_CA=$(echo $ENTITLED_CAS | jq .[0] -r) Generate the device CSR: DEVICE_ID=mytestdevice-123 openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -outform DER -subj \"/CN=$DEVICE_ID\" openssl base64 -in device.csr -out device.b64 -e Enroll the device: DMS_CRT_PATH=path/to/dms_crt DMS_KEY_PATH=path/to/dms_key openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem curl https://$DOMAIN/api/devmanager/.well-known/est/$SELECTED_CA/simpleenroll --cert $DMS_CRT_PATH --key $DMS_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem --data @device.b64 -H \"Content-Type: application/pkcs10\" -H \"Content-Transfer-Encoding: base64\" openssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem openssl x509 -text -in device-cert.pem Cloud Hosted DMS First, authenticate and obtain a valid JWT ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Obtain the Bootstrap CA list: ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .bootstrap_cas) Select one of the entitled the CAs from the previous list: Note You can manually spefify the SELECTED_CA . Otherwise you can enroll the device with the first entitled CA using the following command. BOOTSTRAP_CA=$(echo $ENTITLED_CAS | jq .[0] -r) Generate the Bootstrap CSR: DEVICE_ID=bootstrap openssl req -new -newkey rsa:2048 -nodes -keyout bootstrap.key -out bootstrap.csr -subj \"/CN=$DEVICE_ID\" Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Get Bootstrap Certificate openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem CSR_B64=$(openssl base64 -in bootstrap.csr -e | tr -d [:space:]) BOOTSTRAP_CERT=$(curl -k --location --request POST \"https://$DOMAIN/api/ca/v1/pki/$BOOTSTRAP_CA/sign\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" --data-raw \"{\\\"certificate_request\\\":\\\"$CSR_B64\\\", \\\"common_name\\\":\\\"bootstrap\\\",\\\"sign_verbatim\\\":true}\") echo $BOOTSTRAP_CERT | jq -r .certificate | base64 -d > bootstrap.crt Enroll the device: DEVICE_ID=mytestdevice-123 openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -outform DER -subj \"/CN=$DEVICE_ID\" openssl base64 -in device.csr -out device.b64 -e BOOTSTRAP_CRT_PATH=path/to/dms_crt BOOTSTRAP_KEY_PATH=path/to/dms_key openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem curl https://$DOMAIN/api/dmsmanager/.well-known/est/$DMS_NAME/simpleenroll --cert $BOOTSTRAP_CRT_PATH --key $BOOTSTRAP_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem --data @device.b64 -H \"Content-Type: application/pkcs10\" -H \"Content-Transfer-Encoding: base64\" openssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem openssl x509 -text -in device-cert.pem Using the UI The UI is an easy manageable tool designed to ease the burdens to non-technical users in using Lamassu PKI. This project was bootstrapped with Create React App . You can learn more in the Create React App documentation . Deployment This section has moved here: https://facebook.github.io/create-react-app/docs/deployment Create a new Certification Authority There are two methos of creating a new CA from the UI. The first one, filling the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs. The other one, will be importing it. A Certificate and a Private Key will be required. Registration of a DMS using the UI Using the UI, creating a new DMS is as simple as filling the following form. Once the DMS has been created successfully, a prompt showing the generated private key will be shown. It is encouraged to download it just after the creation as this prompt will be shown only once. The status of the new created DMS will be Pending Approval , to approve it, we must select at least one CA from the list of registered CAs. The selected CAs will be the authorised ones to sign certificates from now on. Registration of a device using the UI To create a device, we will need to fill the following form taking into account: A device identification must be provided. A DMS must be assigned. Each device can have certificates signed by different authorised CAs. The certificates of each device as well as the cloud-connectors will be showned. Using the APIs The main 3 Open API documentation can be found on the following urls: https://dev.lamassu.io/api/dmsmanager/v1/docs/ https://dev.lamassu.io/api/ca/v1/docs/ https://dev.lamassu.io/api/devmanager/v1/docs/ Note The following endpoints defined in the Lamassu Device Manager Api specification are not correctly defined due to the limitations imposed by the Open API 3.0 schema. The current specification defines an OIDC security schema (meaning that a valid JWT token must be provided while requesting the API) while the implemented security schema uses the mTLS approach. This issue will be resolved once the specification is migrated to Open API 3.1 compliant. The affected endpoints are: Lamassu provides easy to use GO clients for most of its APIs to help speeding up the development of third-party applications. Before using thees clients, it is important to identify the path taken by the request. Unless the application using the GO clients (or any other http client such as curl ) is deployed within the same docker network, the request will be handled by the API Gateway component . Otherwise check the internal usage section. Through the API Gateway Go Curl package main import ( \"net/url\" lamassuCAClient \"github.com/lamassuiot/lamassuiot/pkg/ca/client\" caDTO \"github.com/lamassuiot/lamassuiot/pkg/ca/common/dto\" \"github.com/lamassuiot/lamassuiot/pkg/utils/client\" ) function main (){ lamassuGatewayURL := \"dev.lamassu.io\" apiCAFile := \"path/to/apigw.crt\" caClient := lamassuCAClient . NewLamassuCAClient ( client . ClientConfiguration { URL : & url . URL { Scheme : \"https\" , Host : lamassuGatewayURL , Path : \"/api/ca/\" , }, AuthMethod : client . JWT , AuthMethodConfig : & client . JWTConfig { Username : \"enroller\" , Password : \"enroller\" , URL : & url . URL { Scheme : \"https\" , Host : \"auth.\" + lamassuGatewayURL , }, CACertificate : apiCAFile , }, CACertificate : apiCAFile , }) ca , err = caClient . CreateCA ( context . Background (), caDTO . Pki , caName , caDTO . PrivateKeyMetadata { KeyType : \"rsa\" , KeyBits : 2048 }, caDTO . Subject { CN : caName }, 365 * time . Hour , 30 * time . Hour ) } Define the DOMAIN, TOKEN and CA_NAME export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' | jq -r .access_token) export CA_ADDR=$DOMAIN/api/ca export CA_NAME=$(uuidgen) Creting CA export CREATE_CA_RESP=$(curl -k -s --location --request POST \"https://$CA_ADDR/v1/pki\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"ca_duration\\\": 262800, \\\"issuance_duration\\\": 175200, \\\"subject\\\":{ \\\"common_name\\\": \\\"$CA_NAME\\\",\\\"country\\\": \\\"ES\\\",\\\"locality\\\": \\\"Arrasate\\\",\\\"organization\\\": \\\"LKS Next, S. Coop\\\",\\\"state\\\": \\\"Gipuzkoa\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 4096,\\\"type\\\": \\\"RSA\\\"}}\") Running Unit tests #For pretty printing go install github.com/haveyoudebuggedit/gotestfmt/v2/cmd/gotestfmt@v2.3.1 go test -json -v ./pkg/ca/server/api/ | gotestfmt go test -json -v ./pkg/dms-manager/server/api/ | gotestfmt go test -json -v ./pkg/device-manager/server/api/ | gotestfmt Filtering, Sorting and Pagination Lamassu API supports filtering, sorting and pagination. The filter can be form by the following parameters, being each of them optional: filter= attribute[operator]=value sort_by=attribute.[asc|desc] limit=value . Limits the maximun number of results of the query offset=value . In addition to limit , implements pagination. It defines the index of the first value from the resulting query. Example /v1/devices?filter=id[contains]=device_id&sort_by=id.asc&limit=100&offset=15 /v1?filter=id[contains]=dms_id&sort_by=id.desc Operators Depending of the data type of the parameters, the supported operators will vary. Strings : equals , notequals , contains , notcontains Dates: before , after , is , isnot Enums: is , isnot Numbers: lessthan , greaterthan , lessorequal , gretaerorequal , equal , notequal","title":"Getting Started"},{"location":"usage/#getting-started","text":"Before jumping any further, please check out the installation process to deploy all Lamassu services. This section will guide you through the basic functionalities provided by our PKI to start provisioning your devices.","title":"Getting Started"},{"location":"usage/#overview","text":"","title":"Overview"},{"location":"usage/#create-a-new-certification-authority","text":"The first step to provision your devices with digital certificates is to create the Certification Authority. The role of a CA is to issue and manage all the certificates. To create a new CA, fill the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs.","title":"Create a new Certification Authority"},{"location":"usage/#register-a-new-device-manufacturing-system","text":"Lamassu is a PKI designed for the industrial and IoT sector. To better integrate this PKI in real life manufacturing system, Lamassu delegates the issuance of device certificate to the factory itself. First lets dive into the Device Manufacturing System (DMS for short) registration step by step. After that, a couple of examples will demonstrate how to start enrolling your devices using the Lamassu's Virtual DMS software as well as using the UI. Device manufacturing process tend to be highly automated. Provisioning the devices with digital identities should not slow down the fabrication process. Lamassu addresses this challenge introducing the DMS concept as core. One of the factories operators stars the process by generating a DMS registration request contained in a Certificate Signing Request also referred as CSR. This CSR is then sent to the DMS Enroller service to be approved by one of the PKI Administrators: The Administrator then decides if the request is approved or denied. If it decision is to approve the DMS registration request, the Administrator must specify which CAs will that particular DSM be entitled to issue certificates with: Once, and only if, the DMS registration request is approved, then the Operator must retrieve the signed CSR and pass it to the DMS software that will be in charge off requesting the issuance of new digital certificates for the manufactured devices: Finally, the DMS is able to request new x509 certificates for its manufactured devices. The DMS may be assisted by additional tools to obtain the manufactured device unique identifier. Note Envoy is used as an API gateway in this project. Currently Envoy is written to use Boring SSl as the TLS provider. It does not support secp224r1 signing method, which is used to create ECDSA224 keys. Therefore, enroll and reenroll methods will return a error when using this key. Let's register a new DMS instance:","title":"Register a new Device Manufacturing System"},{"location":"usage/#manual-dms","text":"Operator - Authenticate the user: OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Operator - Request the registration for a new DMS instance: DMS_NAME=MyDMS DMS_SUBJECT_COUNTRY=ES DMS_SUBJECT_STATE=Gipuzkoa DMS_SUBJECT_LOCALITY=Donostia DMS_SUBJECT_ORGANIZATION=Lamassu DMS_SUBJECT_ORGANIZATION_UNIT=IoT DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsmanager/v1/\" \\ --header \"Authorization: Bearer $OPERATOR_TOKEN\" \\ --data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"organization_unit\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}}\") DMS_NAME=$(echo $DMS_REG_RESPONSE | jq -r .dms.name) echo $DMS_REG_RESPONSE | jq -r .private_key | base64 -d > dms.key Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Authorize the enrollment with all the provisioned CAs AUTHORIZED_CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .cas[].name | jq -s) curl -k --location --request PUT \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME/status\" \\ --header \"Authorization: Bearer $ENROLLER_TOKEN\" \\ --data-raw \"{\\\"status\\\":\\\"APPROVED\\\"}\" curl -k --location --request PUT \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME/auth\" \\ --header \"Authorization: Bearer $ENROLLER_TOKEN\" \\ --data-raw \"{\\\"authorized_cas\\\":$AUTHORIZED_CAS}\" Operator - Get the DMS certificate: curl -k \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .certificate | base64 -d > dms.crt","title":"Manual DMS"},{"location":"usage/#cloud-hosted-dms","text":"When creating a Cloud Hosted DMS the Payload of the request has three more parameters: BootstrapCAs : Bootstrap CAs, i.e. the Bootstrap certificate used by the device has to be issued by one of these CAs, in case it is not issued by any of these CAs the device request will not be authorized. IsCloudDMS : It is a boolean parameter. In this case it always has the same value true . CaName : The CA through which the device certificate is to be issued. It has the same function as the Authorized CAs. In this case, by passing the CA name as a parameter, it is not necessary to approve the DMS once it has been created. Operator - Authenticate the user: OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Get all the provisioned CAs CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .cas[].name | jq -s) Operator - Request the registration for a new DMS instance: DMS_NAME=MyDMS DMS_SUBJECT_COUNTRY=ES DMS_SUBJECT_STATE=Gipuzkoa DMS_SUBJECT_LOCALITY=Donostia DMS_SUBJECT_ORGANIZATION=Lamassu DMS_SUBJECT_ORGANIZATION_UNIT=IoT CA_NAME=$(echo $CAS | jq .[0] -r) DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsmanager/v1\" \\ --header \"Authorization: Bearer $OPERATOR_TOKEN\" \\ --data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"organization_unit\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}, \\\"host_cloud_dms\\\":true, \\\"ca_name\\\": &CA_NAME,\\\"bootstrap_cas\\\":$CAS }\") DMS_NAME=$(echo $DMS_REG_RESPONSE | jq -r .dms.name) echo $DMS_REG_RESPONSE | jq -r .private_key | base64 -d > dms.key Operator - Get the DMS certificate: curl -k \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .certificate | base64 -d > dms.crt","title":"Cloud Hosted DMS"},{"location":"usage/#provision-your-devices-with-x509-certificates","text":"The enrollment process is the way to go to obtain a certificate issued by one of the provisioned CAs. As described in the RFC document, Lamassu requires the authentication of the client requesting the enrollment using a certificate as well as the private key of an issued DMS to perform a mutual TLS connection. By using this type of TLS connection, the client is able to authenticate the server, and also, the server is able to authenticate the client. Although the /api/devmanager/.well-known/cacerts endpoint returns the list containing all the manged CAs by the PKI, each DMS is entitled to request the issuance of a certificate with an authorized CA. For instance, the PKI may have the following CAs: CA1 , CA2 , CA3 and CA4 . The /api/devmanager/.well-known/cacerts would return all four CAs. Then, a new DMS is registered. the PKI administrator approves the DMS registration by authorizing such DMS to issue certificates with CA1 and CA4 . This process is known as the DMS registration process . Once the DMS is completely registered, it can now start performing the EST enrollment process. Check out the previous section to understand what a DMS does. Let's first obtain the CA list for a particular DMS:","title":"Provision your devices with x509 Certificates"},{"location":"usage/#manual-dms_1","text":"First, authenticate and obtain a valid JWT OPERATOR_USERNAME=operator OPERATOR_PASSWORD=operator DOMAIN=dev.lamassu.io OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token) Obtain the CA list: ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .authorized_cas) Select one of the entitled the CAs from the previous list: Note You can manually spefify the SELECTED_CA . Otherwise you can enroll the device with the first entitled CA using the following command. SELECTED_CA=$(echo $ENTITLED_CAS | jq .[0] -r) Generate the device CSR: DEVICE_ID=mytestdevice-123 openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -outform DER -subj \"/CN=$DEVICE_ID\" openssl base64 -in device.csr -out device.b64 -e Enroll the device: DMS_CRT_PATH=path/to/dms_crt DMS_KEY_PATH=path/to/dms_key openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem curl https://$DOMAIN/api/devmanager/.well-known/est/$SELECTED_CA/simpleenroll --cert $DMS_CRT_PATH --key $DMS_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem --data @device.b64 -H \"Content-Type: application/pkcs10\" -H \"Content-Transfer-Encoding: base64\" openssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem openssl x509 -text -in device-cert.pem","title":"Manual DMS"},{"location":"usage/#cloud-hosted-dms_1","text":"First, authenticate and obtain a valid JWT ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Obtain the Bootstrap CA list: ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .bootstrap_cas) Select one of the entitled the CAs from the previous list: Note You can manually spefify the SELECTED_CA . Otherwise you can enroll the device with the first entitled CA using the following command. BOOTSTRAP_CA=$(echo $ENTITLED_CAS | jq .[0] -r) Generate the Bootstrap CSR: DEVICE_ID=bootstrap openssl req -new -newkey rsa:2048 -nodes -keyout bootstrap.key -out bootstrap.csr -subj \"/CN=$DEVICE_ID\" Admin - Authenticate the admin user ENROLLER_USERNAME=enroller ENROLLER_PASSWORD=enroller DOMAIN=dev.lamassu.io ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token) Admin - Get Bootstrap Certificate openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem CSR_B64=$(openssl base64 -in bootstrap.csr -e | tr -d [:space:]) BOOTSTRAP_CERT=$(curl -k --location --request POST \"https://$DOMAIN/api/ca/v1/pki/$BOOTSTRAP_CA/sign\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" --data-raw \"{\\\"certificate_request\\\":\\\"$CSR_B64\\\", \\\"common_name\\\":\\\"bootstrap\\\",\\\"sign_verbatim\\\":true}\") echo $BOOTSTRAP_CERT | jq -r .certificate | base64 -d > bootstrap.crt Enroll the device: DEVICE_ID=mytestdevice-123 openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -outform DER -subj \"/CN=$DEVICE_ID\" openssl base64 -in device.csr -out device.b64 -e BOOTSTRAP_CRT_PATH=path/to/dms_crt BOOTSTRAP_KEY_PATH=path/to/dms_key openssl s_client -connect $DOMAIN:443 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > root-ca.pem curl https://$DOMAIN/api/dmsmanager/.well-known/est/$DMS_NAME/simpleenroll --cert $BOOTSTRAP_CRT_PATH --key $BOOTSTRAP_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem --data @device.b64 -H \"Content-Type: application/pkcs10\" -H \"Content-Transfer-Encoding: base64\" openssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem openssl x509 -text -in device-cert.pem","title":"Cloud Hosted DMS"},{"location":"usage/#using-the-ui","text":"The UI is an easy manageable tool designed to ease the burdens to non-technical users in using Lamassu PKI. This project was bootstrapped with Create React App . You can learn more in the Create React App documentation .","title":"Using the UI"},{"location":"usage/#deployment","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/deployment","title":"Deployment"},{"location":"usage/#create-a-new-certification-authority_1","text":"There are two methos of creating a new CA from the UI. The first one, filling the following form taking into account the following things: Lamassu supports both RSA and EC based CAs. The CA name MUST be unique. The CA expiration time must be greater than the lifespan of the issued certs. The other one, will be importing it. A Certificate and a Private Key will be required.","title":"Create a new Certification Authority"},{"location":"usage/#registration-of-a-dms-using-the-ui","text":"Using the UI, creating a new DMS is as simple as filling the following form. Once the DMS has been created successfully, a prompt showing the generated private key will be shown. It is encouraged to download it just after the creation as this prompt will be shown only once. The status of the new created DMS will be Pending Approval , to approve it, we must select at least one CA from the list of registered CAs. The selected CAs will be the authorised ones to sign certificates from now on.","title":"Registration of a DMS using the UI"},{"location":"usage/#registration-of-a-device-using-the-ui","text":"To create a device, we will need to fill the following form taking into account: A device identification must be provided. A DMS must be assigned. Each device can have certificates signed by different authorised CAs. The certificates of each device as well as the cloud-connectors will be showned.","title":"Registration of a device using the UI"},{"location":"usage/#using-the-apis","text":"The main 3 Open API documentation can be found on the following urls: https://dev.lamassu.io/api/dmsmanager/v1/docs/ https://dev.lamassu.io/api/ca/v1/docs/ https://dev.lamassu.io/api/devmanager/v1/docs/ Note The following endpoints defined in the Lamassu Device Manager Api specification are not correctly defined due to the limitations imposed by the Open API 3.0 schema. The current specification defines an OIDC security schema (meaning that a valid JWT token must be provided while requesting the API) while the implemented security schema uses the mTLS approach. This issue will be resolved once the specification is migrated to Open API 3.1 compliant. The affected endpoints are: Lamassu provides easy to use GO clients for most of its APIs to help speeding up the development of third-party applications. Before using thees clients, it is important to identify the path taken by the request. Unless the application using the GO clients (or any other http client such as curl ) is deployed within the same docker network, the request will be handled by the API Gateway component . Otherwise check the internal usage section.","title":"Using the APIs"},{"location":"usage/#through-the-api-gateway","text":"Go Curl package main import ( \"net/url\" lamassuCAClient \"github.com/lamassuiot/lamassuiot/pkg/ca/client\" caDTO \"github.com/lamassuiot/lamassuiot/pkg/ca/common/dto\" \"github.com/lamassuiot/lamassuiot/pkg/utils/client\" ) function main (){ lamassuGatewayURL := \"dev.lamassu.io\" apiCAFile := \"path/to/apigw.crt\" caClient := lamassuCAClient . NewLamassuCAClient ( client . ClientConfiguration { URL : & url . URL { Scheme : \"https\" , Host : lamassuGatewayURL , Path : \"/api/ca/\" , }, AuthMethod : client . JWT , AuthMethodConfig : & client . JWTConfig { Username : \"enroller\" , Password : \"enroller\" , URL : & url . URL { Scheme : \"https\" , Host : \"auth.\" + lamassuGatewayURL , }, CACertificate : apiCAFile , }, CACertificate : apiCAFile , }) ca , err = caClient . CreateCA ( context . Background (), caDTO . Pki , caName , caDTO . PrivateKeyMetadata { KeyType : \"rsa\" , KeyBits : 2048 }, caDTO . Subject { CN : caName }, 365 * time . Hour , 30 * time . Hour ) } Define the DOMAIN, TOKEN and CA_NAME export AUTH_ADDR=auth.$DOMAIN export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' | jq -r .access_token) export CA_ADDR=$DOMAIN/api/ca export CA_NAME=$(uuidgen) Creting CA export CREATE_CA_RESP=$(curl -k -s --location --request POST \"https://$CA_ADDR/v1/pki\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"ca_duration\\\": 262800, \\\"issuance_duration\\\": 175200, \\\"subject\\\":{ \\\"common_name\\\": \\\"$CA_NAME\\\",\\\"country\\\": \\\"ES\\\",\\\"locality\\\": \\\"Arrasate\\\",\\\"organization\\\": \\\"LKS Next, S. Coop\\\",\\\"state\\\": \\\"Gipuzkoa\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 4096,\\\"type\\\": \\\"RSA\\\"}}\")","title":"Through the API Gateway"},{"location":"usage/#running-unit-tests","text":"#For pretty printing go install github.com/haveyoudebuggedit/gotestfmt/v2/cmd/gotestfmt@v2.3.1 go test -json -v ./pkg/ca/server/api/ | gotestfmt go test -json -v ./pkg/dms-manager/server/api/ | gotestfmt go test -json -v ./pkg/device-manager/server/api/ | gotestfmt","title":"Running Unit tests"},{"location":"usage/#filtering-sorting-and-pagination","text":"Lamassu API supports filtering, sorting and pagination. The filter can be form by the following parameters, being each of them optional: filter= attribute[operator]=value sort_by=attribute.[asc|desc] limit=value . Limits the maximun number of results of the query offset=value . In addition to limit , implements pagination. It defines the index of the first value from the resulting query. Example /v1/devices?filter=id[contains]=device_id&sort_by=id.asc&limit=100&offset=15 /v1?filter=id[contains]=dms_id&sort_by=id.desc","title":"Filtering, Sorting and Pagination"},{"location":"usage/#operators","text":"Depending of the data type of the parameters, the supported operators will vary. Strings : equals , notequals , contains , notcontains Dates: before , after , is , isnot Enums: is , isnot Numbers: lessthan , greaterthan , lessorequal , gretaerorequal , equal , notequal","title":"Operators"},{"location":"virtual-device/","text":"Lamassu Virtual Device It is recommended to follow this directory layout when deploying different Lamassu tools: $HOME/ \u251c\u2500\u2500 lamassu-compose \u251c\u2500\u2500 lamassu-virtual-device \u2514\u2500\u2500 lamassu-virtual-dms Make sure to define the following variable with the absolute path LAMASSU_COMPOSE_DIR=$HOME/lamassu-compose LAMASSU_VDMS_DIR=$HOME/lamassu-virtual-dms Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-virtual-device.git cd lamassu-virtual-device Basic Virtual Device configuration: 2.1 Specify the directory where enrolled device certificates (and keys) are stored: export VDEV_DEVICE_CERTIFICATES_DIR=$LAMASSU_VDMS_DIR/device-certificates 2.2 Specify the URL pointing to the EST server: export VDEV_EST_SERVER_URL=dev.lamassu.io/api/devmanager 2.3 Specify the public certificate used by the EST server: export VDEV_EST_SERVER_CERT=$LAMASSU_COMPOSE_DIR/tls-certificates/downstream/tls.crt Optional - Configure the device to connect to AWS IoT core: 3.1 Define the AWS IoT core endpoint to be used. Replace the xxxxxx with the appropriated value as well as the AWS Region to be used: VDEV_AWS_IOT_CORE_ENDPOINT=xxxxxx-ats.iot.eu-west-1.amazonaws.com Run the Virtual Device: ./run.sh","title":"Lamassu Virtual Device"},{"location":"virtual-device/#lamassu-virtual-device","text":"It is recommended to follow this directory layout when deploying different Lamassu tools: $HOME/ \u251c\u2500\u2500 lamassu-compose \u251c\u2500\u2500 lamassu-virtual-device \u2514\u2500\u2500 lamassu-virtual-dms Make sure to define the following variable with the absolute path LAMASSU_COMPOSE_DIR=$HOME/lamassu-compose LAMASSU_VDMS_DIR=$HOME/lamassu-virtual-dms Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-virtual-device.git cd lamassu-virtual-device Basic Virtual Device configuration: 2.1 Specify the directory where enrolled device certificates (and keys) are stored: export VDEV_DEVICE_CERTIFICATES_DIR=$LAMASSU_VDMS_DIR/device-certificates 2.2 Specify the URL pointing to the EST server: export VDEV_EST_SERVER_URL=dev.lamassu.io/api/devmanager 2.3 Specify the public certificate used by the EST server: export VDEV_EST_SERVER_CERT=$LAMASSU_COMPOSE_DIR/tls-certificates/downstream/tls.crt Optional - Configure the device to connect to AWS IoT core: 3.1 Define the AWS IoT core endpoint to be used. Replace the xxxxxx with the appropriated value as well as the AWS Region to be used: VDEV_AWS_IOT_CORE_ENDPOINT=xxxxxx-ats.iot.eu-west-1.amazonaws.com Run the Virtual Device: ./run.sh","title":"Lamassu Virtual Device"},{"location":"virtual-dms/","text":"Lamassu Virtual DMS It is recommended to follow this directory layout when deploying different Lamassu tools: $HOME/ \u251c\u2500\u2500 lamassu-compose \u251c\u2500\u2500 lamassu-virtual-device \u2514\u2500\u2500 lamassu-virtual-dms Make sure to define the following variable with the absolute path LAMASSU_COMPOSE_DIR=$HOME/lamassu-compose Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-virtual-dms.git cd lamassu-virtual-dms Basic Virtual DMS configuration: 2.1 Locate the the public certificate used by the EST server: export VDMS_EST_SERVER_CERT=$LAMASSU_COMPOSE_DIR/tls-certificates/downstream/tls.crt 2.2 Configure the domain used by lamassu: export VDMS_DOMAIN=dev.lamassu.io 2.3 Provide the operator credentials to be used while creating a new DMS instance: export VDMS_USERNAME=enroller export VDMS_PASSWORD=enroller 2.4 Specify the default values while creating a new DMS instance: export VDMS_COUNTRY=ES export VDMS_STATE=gipuzkoa export VDMS_LOCALITY=donostia export VDMS_ORGANIZATION=lamassu export VDMS_ORGANIZATION_UNIT=iot Run the DMS application: run.sh","title":"Lamassu Virtual DMS"},{"location":"virtual-dms/#lamassu-virtual-dms","text":"It is recommended to follow this directory layout when deploying different Lamassu tools: $HOME/ \u251c\u2500\u2500 lamassu-compose \u251c\u2500\u2500 lamassu-virtual-device \u2514\u2500\u2500 lamassu-virtual-dms Make sure to define the following variable with the absolute path LAMASSU_COMPOSE_DIR=$HOME/lamassu-compose Clone the repository and get into the directory: git clone https://github.com/lamassuiot/lamassu-virtual-dms.git cd lamassu-virtual-dms Basic Virtual DMS configuration: 2.1 Locate the the public certificate used by the EST server: export VDMS_EST_SERVER_CERT=$LAMASSU_COMPOSE_DIR/tls-certificates/downstream/tls.crt 2.2 Configure the domain used by lamassu: export VDMS_DOMAIN=dev.lamassu.io 2.3 Provide the operator credentials to be used while creating a new DMS instance: export VDMS_USERNAME=enroller export VDMS_PASSWORD=enroller 2.4 Specify the default values while creating a new DMS instance: export VDMS_COUNTRY=ES export VDMS_STATE=gipuzkoa export VDMS_LOCALITY=donostia export VDMS_ORGANIZATION=lamassu export VDMS_ORGANIZATION_UNIT=iot Run the DMS application: run.sh","title":"Lamassu Virtual DMS"}]}