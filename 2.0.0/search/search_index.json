{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Lamassu Iot Docs","text":"<p>Lamassu is an IoT first PKI designed for industrial scenarios. Public key infrastructure are systems in charge of creating, storing and distributing digital certificates which are used to verify that a particular public key belongs to a certain entity. PKIs creates digital certificates which map to public keys to entities, securely stores these certificates in a central repository and revokes them if needed.</p> <p> </p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#core-services","title":"Core Services","text":"<p>Lamassu has been designed to be modular and keep the core services as simple as possible encapsulating on each service a set of well defined responsibilities. The core services are those that bring the main functionalities of a modern PKI for industrial IoT use cases. The core services are:</p>"},{"location":"architecture/#ca","title":"CA","text":"<p>The Certificate Authority is the service in charge of issuing and managing the life cycle of the certificate. This service manages two different types of certificates:</p> <ul> <li>PKI Certificates: This kind of certificates are used by regular end   entities such as the devices that connect to the PKI.</li> <li>Internal Certificates: In contrast with the previous type of certificates,   these certificate authorities have a more restricted use. Their creation   should be limited to the most trusted entities of the PKI. For instance, DMS   certificates are issued by an internal CA named LAMASSU-DMS-MANAGER that is   created on boot up. For the moment this is the only internal CA that is   supported by Lamassu, but we are exploring the possibility of managing the   certificates used by the services themselves.</li> </ul> <p>On top of the regular functionalities that can be performed on this service such as creating new CAs, issuing or revoking certificates, this service is in charge of maintaining an accurate state of the managed entities (both CA certificates and regular certificates). In order to do so, a periodic task is scheduled once a day to check the status of validity of all certificates.</p> <p>Warning</p> <p>many certificates as it is performed on a sequential single threaded process. We are working on a solution to improve this.</p> <p>There are 4 different status that a certificate can have:</p> <p></p> <p>The Active state indicates that a certificate is valid and can be trusted by end entities. The Expired state indicates that a certificate has reached its expiration date and is no longer valid and cannot be trusted anymore. The Revoked state is used by PKI admins when a security incident or unexpected situations arise and the certificate or CA certificate is no longer trusted. Recently a new state has been added to the CA service, the About to expire state. This state indicates, as the name suggests, that the certificate will expire shortly. The current threshold is set to 30 days and cannot be configured. This state doesn't affect the validity of the certificate, but it is used to notify the PKI admins that the certificate is about to expire and they should take action.</p> <p>The CA service uses a relational database to store the issued certificates and basic information regarding the provisioned CAs. To configure the database connection, set the following environment variables:</p> <p>| Environment Variable | Description | | -------------------- | ------------------------------------------------------------- | | POSTGRES_HOSTNAME | Hostname or address to connect to a running postgres database | | POSTGRES_PORT | Port for the postgres instance | | POSTGRES_DATABASE | Database to use | | POSTGRES_USERNAME | Username credentials | | POSTGRES_PASSWORD | Password credentials |</p> <p>This service has been redesigned to support multiple crypto engines backends. Originally the only supported engine was the one provided by Hashicorp Vault, but the new redesign implementation allows for a more flexible golang like approach, that is by using the <code>crypto.Signer</code> interface. Any new crypto engine can be added by implementing this interface.</p> <p>To provision the CA service with a crypto engine set the following environment variable:</p> <p>| Environment Variable | Description | | -------------------- | ------------------------------ | | ENGINE | <code>pkcs11</code> | <code>gopem</code> | <code>vault</code> |</p> <p>The current supported crypto engines are:</p> <ul> <li>pkcs11: To Use the HSM crypto engine, define the following environment   variables before launching the CA service:</li> </ul> <p>| Environment Variable | Description | | -------------------- | --------------------------------------- | | PKCS11_DRIVER | Path to the PKCS11 driver file | | PKCS11_LABEL | Label used by the token to be used | | PKCS11_PIN | PIN code to login and operate the token |</p> <ul> <li>gopem - Files</li> </ul> <p>| Environment Variable | Description | | -------------------- | -------------------------------------------------------------------------- | | GOPEM_DATA | Directory where the generated private keys belonging to each CA are stored |</p> <p>Although this new design is easier to maintain and operate, we are also keeping the previous implementation of the Hashicorp Vault that does not follow the new interface. The reason being that in order to provide a Vault implementation that follows the new interface, the Enterprise Vault license is required. This is a limitation that we are working on to overcome with the new crypto engine design. The new standard deployment deprecates the use of Vault as the main backend and instead a Software HSM known as SoftHSM v2.</p> <ul> <li>vault - Hashicorp Vault</li> </ul> <p>| Environment Variable | Description | | --------------------- | --------------------------------------------------------------------- | | VAULT_ADDRESS | Protocol, hostname and port to a vault instance: <code>https://vault:8200</code> | | VAULT_ROLE_ID | Role ID used by the CA service to login to vault | | VAULT_SECRET_ID | Secret ID used by the CA service to login to vault | | VAULT_CA | Path to the CA certificate file for <code>https</code> connections | | VAULT_UNSEAL_KEY_FILE | Path to the unseal vault keys | | VAULT_PKI_CA_PATH | Prefix to use while creating new PKI vault secrets |</p>"},{"location":"architecture/#dms-manager","title":"DMS Manager","text":"<p>The DMS Manager is the service in charge of managing the Registration Authority of the PKI. Instead of having a centralized Registration Authority, Lamassu uses a decentralized approach to be easily integrated by Device Manufacturing Systems. This way, each DMS has the authority to request the issuance of a certificate for a device being manufactured. Instead of relying on just one registration authority, Lamassu delegates the authorization of the issuance to the Local Registration Authority or LRA.</p> <p>Each DMS is entitled to authorize the issuance of a certificate to a subset of CAs of the entire PKI defined by the administrator. Each DMS has a list of authorized CAs that may be used during the enrollment process. Once an enrollment process is initiated, the PKI will check that the provided DMS certificate is authorized to issue certificates for the requested CA. The authorization list can be updated to add newly created CAs or remove CAs that are no longer needed.</p> <p>The DMS certificates that are used to authenticate the DMS are issued by an internal CA named LAMASSU-DMS-MANAGER. This CA is created by default when the PKI is deployed as stated earlier.</p> <p>In Lamassu there are two different types of DMS Manual DMS and Cloud Hosted DMS. In the Manual DMS the communications between the Device and the DMS does not follow a standard and is done according to the needs/requirements of the device, instead, in the Cloud Hosted DMS the communication between the device and the DMS is done using the EST protocol. On the other hand, in Cloud Hosted DMS mode the device to communicate with the DMS and to be able to request a Certificate must have a Bootstrap certificate. By means of this certificate the DMS authorizes or rejects the device's request. In Manual DMS mode the authorization is done manually by the operator.</p> <p></p> <p>The DMS Manager service uses a relational database to store the list of authorised CAs and basic information regarding the provisioned DMS certificates. To configure the database connection, set the following environment variables:</p> <p>| Environment Variable | Description | | -------------------- | ------------------------------------------------------------- | | POSTGRES_HOSTNAME | Hostname or address to connect to a running postgres database | | POSTGRES_PORT | Port for the postgres instance | | POSTGRES_DATABASE | Database to use | | POSTGRES_USERNAME | Username credentials | | POSTGRES_PASSWORD | Password credentials |</p> <ul> <li>CA - The DMS service uses a Lamassu CA Client to update the status of the   internal CA LAMASSU-DMS-MANAGER</li> </ul> <p>| Environment Variable | Description | | -------------------- | ---------------------------------------------------- | | LAMASSU_CA_ADDRESS | Lamassu CA service name and port : <code>ca:8087</code> | | LAMASSU_CA_CERT_FILE | Path to the internal CA |</p>"},{"location":"architecture/#device-manager","title":"Device manager","text":"<p>At its core, the device manager is the main entry point for the enrollment process. It implements the EST protocol that must be used to obtain new certificates. On top of that, this service manages the registration of new devices and to keep a track of the device status. Similar to the CA service, the device manager also schedules a periodic task to check the status of the devices. This task is launched once a day to check the status of validity of all certificates associated by each device. !!! warning This feature does not perform well on deployments that have issued many certificates as it is performed on a sequential single threaded process. We are working on a solution to improve this.</p> <p>There are 5 different status a device can have:</p> <p></p> <p>The Pending Provisioning state reflects that a device entity has been created but no certificate has been issued yet. The Fully Provisioned state indicates that a device has all the device slots with active certificates. The With warnings state indicates that a device has one or more slots with certificates that are either expired or have been revoked. The Requires Action state indicates that a device has one or more slots with certificates that are about to expire. The Decommissioned state indicates that a device has been decommissioned and no longer needs to be tracked by the PKI.</p> <p>Each device can have certificates signed by different authorised CAs. Slots are used to link a particular device with a CA. Each Slot can store multiple certificates, but only one of them can be in an ACTIVE status.</p> <p>The Device Manager service uses a relational database to store the information of the devices, certificates and slots, also, logs of devices and slots are created when an specific action is carried out, for example, in the creation. To configure the database connection, set the following environment variables:</p> <p>| Environment Variable | Description | | -------------------- | ------------------------------------------------------------- | | POSTGRES_HOSTNAME | Hostname or address to connect to a running postgres database | | POSTGRES_PORT | Port for the postgres instance | | POSTGRES_DATABASE | Database to use | | POSTGRES_USERNAME | Username credentials | | POSTGRES_PASSWORD | Password credentials |</p> <ul> <li>CA - The Device Manager service uses a Lamassu CA Client to update the   status of the certificates associated to the devices</li> </ul> <p>| Environment Variable | Description | | -------------------- | ---------------------------------------------------- | | LAMASSU_CA_ADDRESS | Lamassu CA service name and port: <code>ca:8087</code> | | LAMASSU_CA_CERT_FILE | Path to the internal CA |</p> <ul> <li>DMS - The Device Manager service uses a DMS Client to update the status of   the certificates associated to the devices</li> </ul> <p>| Environment Variable | Description | | ----------------------------- | --------------------------------------------------------------- | | LAMASSU_DMS_MANAGER_ADDRESS | Lamassu DMS service name and port: <code>dms-manager:8085</code> | | LAMASSU_DMS_MANAGER_CERT_FILE | Path to the internal DMS |</p> <ul> <li>Other - Other configuration variables</li> </ul> <p>| Environment Variable | Description | | --------------------- | ---------------------------------------------------------------------- | | MINIMUM_REENROLL_DAYS | The minimum days that a certificate must be valid in order to reenroll |</p>"},{"location":"architecture/#cloud-proxy","title":"Cloud Proxy","text":"<p>The Cloud Proxy allows integrating CAs created in cloud providers, it is in charge of syncronizing the data between cloud providers and the data of Lamassu. In particular, Lamassu incorporates AWS and Azure Cloud integration.</p> <p>The Cloud Proxy service uses a relational database, to store the information of the Lamassu CAs and to assign a connector Id. The connector will be used to bind each Lamassu CA to their equivalent in the external cloud providers. To configure the database connection, set the following environment variables:</p> <p>| Environment Variable | Description | | -------------------- | ------------------------------------------------------------- | | POSTGRES_HOSTNAME | Hostname or address to connect to a running postgres database | | POSTGRES_PORT | Port for the postgres instance | | POSTGRES_DATABASE | Database to use | | POSTGRES_USERNAME | Username credentials | | POSTGRES_PASSWORD | Password credentials |</p> <ul> <li>Consul - Cloud connectors are dynamically registered, to have a record of   what services exist, they self-register in consul. Cloud Proxy consumes consul   to ask which service are registered.</li> </ul> <p>| Environment Variable | Description | | -------------------- | ----------------------------------------------------- | | CONSUL_PROTOCOL | Protocol used to connect to consul instance : <code>https</code> | | CONSUL_HOST | Hostname to a running consul instance | | CONSUL_PORT | Port for the consul instance | | CONSUL_CA | Path to the internal CA |</p> <ul> <li>CA - The Device Manager service uses a Lamassu CA Client to update the   status of the certificates associated to the devices</li> </ul> <p>| Environment Variable | Description | | -------------------- | ---------------------------------------------------- | | LAMASSU_CA_ADDRESS | Lamassu CA service name and port: <code>lamassu-ca:8087</code> | | LAMASSU_CA_CERT_FILE | Path to the internal CA |</p>"},{"location":"architecture/#alerts","title":"Alerts","text":"<p>Alerts is the service in charge of sending mails. Users can be subscribed to particular events, such as, when a certificate is about to expire, and they will be notified via mail.</p> <p>Events from all services above (Lamassu CA, DMS Manager and Device Manager) that create, revoke or modify the status of any certificate publish a message to RabbitMQ broker. The message sent to the \"alerts\" queue will be consumed by the Alerts service and will send a mail to all the users subscribed to that event.</p> <p></p> <p>Alerts service uses a relational database, to store the information of subscriptions and last executed events information. To configure the database connection, set the following environment variables:</p> <p>| Environment Variable | Description | | -------------------- | ------------------------------------------------------------- | | POSTGRES_HOSTNAME | Hostname or address to connect to a running postgres database | | POSTGRES_PORT | Port for the postgres instance | | POSTGRES_DATABASE | Database to use | | POSTGRES_USERNAME | Username credentials | | POSTGRES_PASSWORD | Password credentials |</p> <ul> <li>Configuration - Alerts service allows custom configuration to send SMTP   mails, such as:</li> </ul> <p>| Environment Variable | Description | | -------------------- | -------------------------------------------------------------- | | SMTP_FROM | Email address of the sender of alerts generated by the service | | SMTP_INSECURE | Boolean value to enable or disable secure SMTP session | | SMTP_ENABLE_SSL | Boolean value to enable or disable SSL connection | | SMTP_USERNAME | Username credentials | | SMTP_PASSWORD | Password credentials | | SMTP_HOST | Hostname or address to SMTP server: <code>25</code> | | SMTP_PORT | Port for the SMTP instance |</p> <ul> <li>Templates - Alerts service allows custom configuration to send SMTP mails,   such as:</li> </ul> <p>| Environment Variable | Description | | -------------------- | -------------------------------------------------------------- | | TEMPLATE_HTML | Template in HTML format to create mail format | | TEMPLATE_JSON | Template in JSON format to rename queue names by readable text |</p>"},{"location":"architecture/#ocsp","title":"OCSP","text":"<p>OCSP (Online Certificate Status Protocol) service, allows to determine the validity status of an X.509 digital certificate.</p> <p>OCSP service's response must be signed with a public private key, so the following variables must be specified.</p> <p>| Environment Variable | Description | | -------------------- | ---------------------------------------------------- | | SIGNER_CERT | Lamassu CA service name and port: <code>ca:8087</code> | | SIGNER_KEY | Path to the internal CA |</p> <ul> <li>CA - OCSP service uses a Lamassu CA Client to update the status of the   certificates associated to the devices</li> </ul> <p>| Environment Variable | Description | | -------------------- | ---------------------------------------------------- | | LAMASSU_CA_ADDRESS | Lamassu CA service name and port: <code>ca:8087</code> | | LAMASSU_CA_CERT_FILE | Path to the internal CA |</p>"},{"location":"architecture/#lamassu-compose","title":"Lamassu Compose","text":"<p>Lamassu Compose offers a SECURE deployment of the set of microservices required to manage an industrial PKI. The architecture presented on the following image reflects the interconnection of the different services mainly using the HTTP Protocol. The use of this deployment offers the following non functional requirements by leveraging the use of an API Gateway:</p> <ul> <li> <p>Centralized point of access: Each microservice listens on a different port   which ends up being challenging for developers and users. With the use of the   API Gateway, the user will always access the same host and port address. Port   <code>80</code> for HTTP connections and port <code>443</code> for HTTPS connections.</p> </li> <li> <p>Authentication: In order to invoke any endpoint, the API Gateway enforces   each request to present a JWT. Upon receiving an HTTP request, the gateway   validates the presented token against the authentication server.</p> </li> <li> <p>Authorization: Another key aspect is enforcing an authorization schema.   Lamassu has been configured in such way that only specific endpoints are   accessible by non admin users.</p> </li> <li> <p>Tracing: Logging the life of an HTTP request can be helpful during the   debugging process of such complex application. The tracing aspect eases this   process by injecting a unique identifier to each request that is then printed   out by each microservice logs.</p> </li> <li> <p>Mutual TLS authentication: As mentioned earlier the gateway acts as the   traffic orchestrator knowing where each service is and redirecting the traffic   accordingly. To prevent any unauthorized request as well as protecting the   communications channel between the Gateway itself and the upstream service,   the API Gateway initiates a mutual TLS connection to ensure such thing.</p> </li> </ul> <p></p>"},{"location":"architecture/#cloud-providers-add-ons","title":"Cloud Providers Add-ons","text":""},{"location":"manage/","title":"Managing Lamassu","text":""},{"location":"manage/#certificate-rotation","title":"Certificate rotation","text":"<p>By default, all self-signed certificates (both upstream and downstream) have a lifespan of 365 days. At that point it will be necessary to regenerate the expired certificates:</p> <ol> <li>Regenerate the certificates:</li> </ol> <pre><code>cd tls-certificates\n./gen-upstream-certs.sh\n./gen-downstream-certs.sh\ncd ..\n</code></pre> <ol> <li>Reboot all services:</li> </ol> <pre><code>docker-compose down\ndocker-compose up -d\n</code></pre>"},{"location":"manage/#backup-strategy","title":"Backup strategy","text":"<p>Like any other system, Lamassu needs to be backed up regularly to ensure it can be restored in the event of a disaster. So the operating system, disks and virtual machine are a given, but with the PKI you also need to restore your environment in the event of a of total disaster:</p> <ul> <li>CA certificate(s) and private key(s)</li> <li>CA registry information</li> <li>CA database backup</li> </ul> <p>There are a number of ways to effectively backup a CA. As an overall summary, we will perform a system state backup that includes: Certification Authority Database, Registry Settings and CA Key information.</p> <p>Following steps allow to backup an installation based on the standard docker-compose procedure:</p> <ul> <li>Save\u00a0config\u00a0file: Stores domain variable</li> </ul> <pre><code>cp\u00a0lamassu-compose/.env\u00a0backup/.env\n</code></pre> <ul> <li>Save\u00a0vault\u00a0credentials: Ensure that the vault credentials file is safe, and   not compromised. If control of the credentials is lost, the vault credentials   can be used to register other machines to vault. Each credential should   contain a single password used for authentication to a specific system.</li> </ul> <pre><code>cp\u00a0lamassu-compose/vault-ca-credentials.json\u00a0./backup/\ncp\u00a0lamassu-compose/vault-credentials.json\u00a0./backup/\n</code></pre> <ul> <li>Get Snapshot of Consul: Consul provides   the\u00a0snapshot\u00a0command   which can be run using the CLI or the API. The\u00a0<code>snapshot</code>\u00a0command saves a   point-in-time snapshot of the state of the Consul servers which includes, but   is not limited to: Key-Value entries, the service catalog, prepared queries,   sessions and ACLs</li> </ul> <pre><code>docker\u00a0exec\u00a0consul\u00a0consul\u00a0snapshot\u00a0save\u00a0backup.snap\ndocker\u00a0cp\u00a0consul:backup.snap\u00a0./backup/\n</code></pre> <ul> <li>Backup\u00a0PostgreSQL: PostgreSQL provides the <code>pg_dump</code> utility to help you back   up databases. It generates a database file with SQL commands in a format that   can be easily restored in the future.</li> </ul> <pre><code>docker\u00a0exec\u00a0database\u00a0bash\u00a0-c\u00a0'pg_dumpall\u00a0-Uadmin\u00a0&gt;\u00a0database.sql'\ndocker\u00a0cp\u00a0database:database.sql\u00a0./backup/\n</code></pre>"},{"location":"manage/#restoring-backups","title":"Restoring backups","text":"<p>These steps allow to recover the state of an installation based on the standard docker-compose procedure:</p> <ul> <li>Restore\u00a0Lamassu's configuration: retrieve credentials from backup.</li> </ul> <pre><code>cp\u00a0backup/.env\u00a0lamassu-compose/.env\ncp\u00a0./backup/vault-ca-credentials.json\u00a0lamassu-compose/vault-ca-credentials.json\ncp\u00a0./backup/vault-credentials.json\u00a0lamassu-compose/vault-credentials.json\n</code></pre> <ul> <li>Restore Snapshot of Consul: Running the\u00a0<code>restore</code>\u00a0process should be   straightforward. Make sure the Consul datacenter you are restoring is stable   and has a leader. You can verify this   using\u00a0<code>consul operator raft list-peers</code>\u00a0and checking server logs and telemetry   for signs of leader elections or network issues.</li> </ul> <pre><code>docker\u00a0cp\u00a0./backup/backup.snap\u00a0consul:backup.snap\ndocker\u00a0exec\u00a0consul\u00a0consul\u00a0snapshot\u00a0restore\u00a0backup.snap\ndocker\u00a0exec\u00a0consul\u00a0sh\u00a0-c\u00a0'curl\u00a0-XPUT\u00a0http://127.0.0.1:8500/v1/catalog/deregister\u00a0-d\"{\\\"Node\\\":\\\"consul-server\\\"}\"'\n</code></pre> <ul> <li>Restore\u00a0PostgreSQL: Overrides all databases from different components.</li> </ul> <pre><code>docker\u00a0cp\u00a0./backup/database.sql\u00a0database:database.sql\ndocker\u00a0exec\u00a0database\u00a0bash\u00a0-c\u00a0'dropdb\u00a0-Uadmin\u00a0alerts'\ndocker\u00a0exec\u00a0database\u00a0bash\u00a0-c\u00a0'dropdb\u00a0-Uadmin\u00a0auth'\ndocker\u00a0exec\u00a0database\u00a0bash\u00a0-c\u00a0'dropdb\u00a0-Uadmin\u00a0ca'\ndocker\u00a0exec\u00a0database\u00a0bash\u00a0-c\u00a0'dropdb\u00a0-Uadmin\u00a0cloudproxy'\ndocker\u00a0exec\u00a0database\u00a0bash\u00a0-c\u00a0'dropdb\u00a0-Uadmin\u00a0devicemanager'\ndocker\u00a0exec\u00a0database\u00a0bash\u00a0-c\u00a0'dropdb\u00a0-Uadmin\u00a0dmsmanager'\ndocker\u00a0exec\u00a0database\u00a0bash\u00a0-c\u00a0'psql\u00a0-Uadmin\u00a0-f\u00a0database.sql\u00a0postgres'\n</code></pre>"},{"location":"protocols/","title":"Protocols","text":"<p>Lamassu supports a set of standards to perform some of its key functionalities such as enrolling devices as well as validating the status of a given certificate. This section aims to describe those protocols as well as explaining how them with practical examples.</p>"},{"location":"protocols/#ocsp","title":"OCSP","text":"<p>The Online Certificate Status Protocol or OCSP for short, is a protocol used to determine the current status of a digital certificate without requiring the use of Certificate Revocation Lists (CRLs).</p> <p>As defined by the standard, there are two possible methods that can be used to perform the http request:</p> <p>| Method | Path | Headers | Body payload | Used when | | ------ | --------------------------------------------------------------------------------- | --------------------------------------- | --------------------------------------------------- | ----------------------------------------------------------- | | <code>GET</code> | <code>{url}/{url-encoding of base-64 encoding of the DER encoding of the OCSPRequest}</code> |  |  | Recommended when the encoded request is less than 255 bytes | | <code>PUT</code> | <code>{url}</code> | Content-Type: <code>application/ocsp-request</code> | Binary value of the DER encoding of the OCSPRequest | Can always be used |</p>"},{"location":"protocols/#get-request","title":"GET Request","text":"OpenSSL <pre><code>Define the OCSP server endpoint as well as the \n```\nexport OCSP_SERVER=dev.lamassu.io:443 \nexport CA_CERTIFICATE=issuer_ca.crt \nexport DEVICE_CERTIFICATE=device.crt\n```\n\nObtain the Root certificate used by the server\n```\nopenssl s_client -connect $OCSP_SERVER  2&gt;/dev/null &lt;/dev/null |  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; root-ca.pem\n```\n\nCreate the OCSP Request\n```\nOCSP_REQUEST=$(openssl ocsp -CAfile $CA_CERTIFICATE -issuer $CA_CERTIFICATE -cert $DEVICE_CERTIFICATE -reqout - | base64 -w 0)\n```\n\nCheck the status of the certificate\n```\ncurl --location --request GET \"https://$OCSP_SERVER/api/ocsp/$OCSP_REQUEST\" &gt; ocspresponse.der \nopenssl ocsp -respin ocspresponse.der -VAfile root-ca.pem -resp_text\n```\n</code></pre> <p>=== \"Go\" ```go package main</p> <pre><code>import (\n    \"crypto/x509\"\n    \"encoding/base64\"\n    \"encoding/pem\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"os\"\n\n    \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\"\n)\n\nfunc main() {\n    ocspServer := \"http://localhost:9098\"\n    issuerCA := \"ca.crt\"\n    certificateToCheck := \"device.crt\"\n\n    caPEM, err := ioutil.ReadFile(issuerCA)\n    if err != nil {\n        fmt.Println(\"Could not load CA certificate\")\n        os.Exit(1)\n    }\n    caPemBlock, _ := pem.Decode(caPEM)\n    ca, err := x509.ParseCertificate(caPemBlock.Bytes)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n\n    devicePEM, err := ioutil.ReadFile(certificateToCheck)\n    if err != nil {\n        fmt.Println(\"Could not load Device certificate\")\n        os.Exit(1)\n    }\n    devicePemBlock, _ := pem.Decode(devicePEM)\n    device, err := x509.ParseCertificate(devicePemBlock.Bytes)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n\n    ocspRequestBytes, err := ocsp.CreateRequest(device, ca, &amp;ocsp.RequestOptions{})\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n\n    encodedRequest := base64.StdEncoding.EncodeToString(ocspRequestBytes)\n    fmt.Println(encodedRequest)\n\n    reqURL := ocspServer + \"/\" + encodedRequest\n\n    resp, err := http.Get(reqURL)\n\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n\n    if resp.StatusCode != http.StatusOK {\n        os.Exit(1)\n    }\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        os.Exit(1)\n    }\n    resp.Body.Close()\n\n    ocspResponse, err := ocsp.ParseResponse(body, nil)\n    if err != nil {\n        fmt.Println(\"Could not parse OCSP response \", err)\n        os.Exit(1)\n    }\n\n    fmt.Println(ocspResponse.Status == ocsp.Good)\n    fmt.Println(ocspResponse.Status == ocsp.Revoked)\n    fmt.Println(ocspResponse.RevokedAt)\n}\n```\n</code></pre>"},{"location":"protocols/#post-request","title":"POST Request","text":"OpenSSL <pre><code>Define the OCSP server endpoint as well as the \n```\nexport OCSP_SERVER=dev.lamassu.io:443 \nexport CA_CERTIFICATE=issuer_ca.crt \nexport DEVICE_CERTIFICATE=device.crt\n```\n\nObtain the Root certificate used by the server\n```\nopenssl s_client -connect $OCSP_SERVER  2&gt;/dev/null &lt;/dev/null |  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; root-ca.pem\n```\n\nCreate the OCSP Request\n```\nopenssl ocsp -issuer ca.crt -cert dev.crt -reqout - &gt; ocsp-request-post.der\n```\n\nCheck the status of the certificate\n```\ncurl --location --request POST \"https://$DOMAIN/api/ocsp/\" --header 'Content-Type: application/ocsp-request' --data-binary '@ocsp-request-post.der' &gt; ocsp-response-post.der -k\nopenssl ocsp -respin ocsp-response-post.der -VAfile root-ca.pem -resp_text\n```\n</code></pre> <p>=== \"Go\" ```go package main</p> <pre><code>    import (\n        \"bytes\"\n        \"crypto/x509\"\n        \"encoding/pem\"\n        \"fmt\"\n        \"io/ioutil\"\n        \"net/http\"\n        \"os\"\n\n        \"github.com/lamassuiot/lamassuiot/pkg/ocsp/server/crypto/ocsp\"\n    )\n\n    func main() {\n        ocspServer := \"http://localhost:9098\"\n        issuerCA := \"ca.crt\"\n        certificateToCheck := \"device.crt\"\n\n        caPEM, err := ioutil.ReadFile(issuerCA)\n        if err != nil {\n            fmt.Println(\"Could not load CA certificate\")\n            os.Exit(1)\n        }\n        caPemBlock, _ := pem.Decode(caPEM)\n        ca, err := x509.ParseCertificate(caPemBlock.Bytes)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n\n        devicePEM, err := ioutil.ReadFile(certificateToCheck)\n        if err != nil {\n            fmt.Println(\"Could not load Device certificate\")\n            os.Exit(1)\n        }\n        devicePemBlock, _ := pem.Decode(devicePEM)\n        device, err := x509.ParseCertificate(devicePemBlock.Bytes)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n\n        ocspRequestBytes, err := ocsp.CreateRequest(device, ca, &amp;ocsp.RequestOptions{})\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n\n        resp, err := http.Post(ocspServer, \"application/ocsp-request\", bytes.NewReader(ocspRequestBytes))\n\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n\n        if resp.StatusCode != http.StatusOK {\n            os.Exit(1)\n        }\n\n        body, err := ioutil.ReadAll(resp.Body)\n        if err != nil {\n            os.Exit(1)\n        }\n        resp.Body.Close()\n\n        ocspResponse, err := ocsp.ParseResponse(body, nil)\n        if err != nil {\n            fmt.Println(\"Could not parse OCSP response \", err)\n            os.Exit(1)\n        }\n\n        fmt.Println(ocspResponse.Status == ocsp.Good)\n        fmt.Println(ocspResponse.Status == ocsp.Revoked)\n        fmt.Println(ocspResponse.RevokedAt)\n\n    }\n```\n</code></pre>"},{"location":"protocols/#est","title":"EST","text":"<p>The core mechanism to obtain valid certificates for your devices is using the enrollment process described by the EST protocol. EST or Enrollment over Secure Transport establishes a set of standardized endpoints. The following table sums up all endpoints defined by the EST protocol and wether or not are supported by the current implementation.</p> <p>| Operation | Operation Path | Required by RFC7030 | Supported | | ------------------------------- | ------------------------------------------ | ------------------- | ---------------- | | Distribution of CA Certificates | /api/devmanager/.well-known/cacerts |  |  | | Enrollment of Clients | /api/devmanager/.well-known/simpleenroll |  |  | | Re-enrollment of Clients | /api/devmanager/.well-known/simplereenroll |  |  | | Full CMC | /api/devmanager/.well-known/fullcmc |  |  | | Server-Side Key Generation | /api/devmanager/.well-known/serverkeygen |  |  | | CSR Attributes | /api/devmanager/.well-known/csrattrs |  |  |</p>"},{"location":"protocols/#distribution-of-ca-certificates","title":"Distribution of CA Certificates","text":"GlobalSign <pre><code>Install GlobalSign Est Client\n    ```\n    go install github.com/globalsign/est/cmd/estclient@latest\n    ```\n\nDefine the DOMAIN as well as the\n    ```\n    export DOMAIN=dev.lamassu.io \n    ```\nObtain the Root certificate used by the server\n    ```\n    openssl s_client -connect $DOMAIN:443  2&gt;/dev/null &lt;/dev/null |  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; root-ca.pem\n    ```\nObtaining CAs certificates\n    ```\n    estclient cacerts -server $DOMAIN/api/devmanager -explicit root-ca.pem -out cacerts.pem\n    ```\n</code></pre> Go <pre><code>```go\npackage main\n\nimport (\n    \"context\"\n    \"crypto/x509\"\n    \"encoding/pem\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"os\"\n\n    \"github.com/lamassuiot/lamassuiot/pkg/est/client\"\n)\n\nfunc main() {\n    estServerAddr := \"dev.lamassu.io/api/devmanager\"\n    servercrt := \"server.crt\"\n    clientcrt := \"dms.crt\"\n    clientkey := \"dms.key\"\n\n    caCert, err := ioutil.ReadFile(servercrt)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n    caCertPool := x509.NewCertPool()\n    caCertPool.AppendCertsFromPEM(caCert)\n\n    certContent, err := ioutil.ReadFile(clientcrt)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n    cpb, _ := pem.Decode(certContent)\n\n    crt, err := x509.ParseCertificate(cpb.Bytes)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n\n    key, err := ioutil.ReadFile(clientkey)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n\n    estClient, err := client.NewLamassuEstClient(estServerAddr, caCertPool, crt, key, nil)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n    cas, err := estClient.CACerts(context.Background())\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n}\n\n```\n</code></pre> Curl <pre><code>Define the DOMAIN as well as the\n    ```\n    export DOMAIN=dev.lamassu.io \n    ```\nObtain the Root certificate used by the server\n    ```\n    openssl s_client -connect $DOMAIN:443  2&gt;/dev/null &lt;/dev/null |  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; root-ca.pem\n    ```\nObtaining CAs certificates\n    ```\n    curl https://$DOMAIN/api/devmanager/.well-known/est/cacerts -o cacerts.p7 --cacert root-ca.pem\n    openssl base64 -d -in cacerts.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cacerts.pem \n    ```\n</code></pre>"},{"location":"protocols/#enrollment-of-devices","title":"Enrollment of Devices","text":"GlobalSign <pre><code>Install GlobalSign Est Client\n    ```\n    go install github.com/globalsign/est/cmd/estclient@latest\n    ```\n\nDefine environment variables as well as the\n\n```\nexport DOMAIN=dev.lamassu.io\nexport CA_NAME=Test-CA\nexport DEVICE_ID=$(uuidgen)\nexport DMS_CERT=dms.crt\nexport DMS_KEY=dms.key  \n```\n!!! note\n    The name of the CA has to be that of a CA that has the DMS as Authorized_CAs.\n\nObtain the Root certificate used by the server\n    ```\n    openssl s_client -connect $DOMAIN:443  2&gt;/dev/null &lt;/dev/null |  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; root-ca.pem\n    ```\nEnrolling with an existing private key\n    ```\n    openssl genrsa 4096 &gt; key.pem\n    estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem\n    estclient enroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out cert.pem  \n    ```\n</code></pre> Go <pre><code>```go\npackage main\n\nimport (\n    \"context\"\n    \"crypto/x509\"\n    \"encoding/pem\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"os\"\n\n    \"github.com/lamassuiot/lamassuiot/pkg/est/client\"\n)\n\nfunc main() {\n    estServerAddr := \"dev.lamassu.io/api/devmanager\"\n    servercrt := \"server.crt\"\n    dmscrt := \"dms.crt\"\n    dmskey := \"dms.key\"\n    devicecsr := \"device.csr\"\n    devicecrt:=\"device.crt\"\n    ca_name := \"Test-CA\"\n    caCert, err := ioutil.ReadFile(servercrt)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n    caCertPool := x509.NewCertPool()\n    caCertPool.AppendCertsFromPEM(caCert)\n\n    certContent, err := ioutil.ReadFile(dmscrt)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n    cpb, _ := pem.Decode(certContent)\n\n    crt, err := x509.ParseCertificate(cpb.Bytes)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n\n    certContent, err = ioutil.ReadFile(devicecsr)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n    cpb, _ = pem.Decode(certContent)\n\n    csr, err := x509.ParseCertificateRequest(cpb.Bytes)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n\n    key, err := ioutil.ReadFile(dmskey)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n\n    estClient, err := client.NewLamassuEstClient(estServerAddr, caCertPool, crt, key, nil)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n\n    cert, err := estClient.Enroll(context.Background(), ca_name, csr)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n    b := pem.Block{Type: \"CERTIFICATE\", Bytes: cert.Raw}\n    certPEM := pem.EncodeToMemory(&amp;b)\n    ioutil.WriteFile(devicecrt, certPEM, 0777)\n}\n```\n</code></pre> Curl <pre><code>Define environment variables as well as the\n\n```\nexport DOMAIN=dev.lamassu.io\nexport CA_NAME=Test-CA\nexport DEVICE_ID=$(uuidgen)\nexport DMS_CERT=dms.crt\nexport DMS_KEY=dms.key  \n```\n!!! note\n    The name of the CA has to be that of a CA that has the DMS as Authorized_CAs.\n\nObtain the Root certificate used by the server\n    ```\n    openssl s_client -connect $DOMAIN:443  2&gt;/dev/null &lt;/dev/null |  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; root-ca.pem\n    ```\nCreate device CSR and private Key\n    ```\n    openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\"\n\n    sed '/CERTIFICATE/d' device.csr &gt; device_enroll.csr   \n    ```\n\nEnrolling with an existing private key\n    ```\n    curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/simpleenroll --cert $DMS_CRT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem  --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\"\n\n    openssl base64 -d -in cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out cert.pem   \n    ```\n</code></pre>"},{"location":"protocols/#re-enrollment-of-devices","title":"Re-enrollment of Devices","text":"<p>=== \"GlobalSign\" Install GlobalSign Est Client <code>go install github.com/globalsign/est/cmd/estclient@latest</code></p> <pre><code>Define environment variables as well as the\n\n```\nexport DOMAIN=dev.lamassu.io\nexport DEVICE_CRT=device.crt\nexport DEVICE_KEY=device.key  \n```\n\nObtain the Root certificate used by the server\n    ```\n    openssl s_client -connect $DOMAIN:443  2&gt;/dev/null &lt;/dev/null |  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; root-ca.pem\n    ```\nReenrolling\n    ```\n    estclient reenroll -server $DOMAIN/api/devmanager -explicit root-ca.pem -key $DEVICE_KEY -certs $DEVICE_CRT -out newcert.pem\n    ```\n</code></pre> Go <pre><code>```go\n    package main\n\n    import (\n        \"context\"\n        \"crypto/x509\"\n        \"encoding/pem\"\n        \"fmt\"\n        \"io/ioutil\"\n        \"os\"\n\n        \"github.com/lamassuiot/lamassuiot/pkg/est/client\"\n    )\n\n    func main() {\n        estServerAddr := \"dev.lamassu.io/api/devmanager\"\n        servercrt := \"server.crt\"\n        devicecrt := \"device.crt\"\n        devicekey := \"device.key\"\n        devicecsr := \"device.csr\"\n\n        caCert, err := ioutil.ReadFile(servercrt)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n        caCertPool := x509.NewCertPool()\n        caCertPool.AppendCertsFromPEM(caCert)\n\n        certContent, err := ioutil.ReadFile(devicecrt)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n        cpb, _ := pem.Decode(certContent)\n\n        crt, err := x509.ParseCertificate(cpb.Bytes)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n\n        certContent, err = ioutil.ReadFile(devicecsr)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n        cpb, _ = pem.Decode(certContent)\n\n        csr, err := x509.ParseCertificateRequest(cpb.Bytes)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n\n        key, err := ioutil.ReadFile(devicekey)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n\n        estClient, err := client.NewLamassuEstClient(estServerAddr, caCertPool, crt, key, nil)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n\n        cert, err := estClient.Reenroll(context.Background(), csr)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n        b := pem.Block{Type: \"CERTIFICATE\", Bytes: cert.Raw}\n        certPEM := pem.EncodeToMemory(&amp;b)\n        ioutil.WriteFile(devicecrt, certPEM, 0777)\n    }\n```\n</code></pre> Curl <pre><code>Define environment variables as well as the\n\n```\nexport DOMAIN=dev.lamassu.io\nexport DEVICE_CRT=device.crt\nexport DEVICE_KEY=device.key\nexprot DEVICE_CSR=device.csr  \n```\n\nObtain the Root certificate used by the server\n    ```\n    openssl s_client -connect $DOMAIN:443  2&gt;/dev/null &lt;/dev/null |  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; root-ca.pem\n    ```\nCreate device enroll CSR\n    ```\n    sed '/CERTIFICATE/d' device.csr &gt; device_enroll.csr   \n    ```\nReenrolling\n    ```\n    curl https://$DOMAIN/api/devmanager/.well-known/est/simplereenroll --cert $DEVICE_CRT --key $DEVICE_KEY -s -o newcert.p7 --cacert root-ca.pem --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\"\n\n    openssl base64 -d -in newcert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out $DEVICE_CRT\n    ```\n</code></pre>"},{"location":"protocols/#server-key-generation-of-devices","title":"Server Key Generation of Devices","text":"<p>=== \"GlobalSign\" Install GlobalSign Est Client <code>go install github.com/globalsign/est/cmd/estclient@latest</code></p> <pre><code>Define environment variables as well as the\n\n```\nexport DOMAIN=dev.lamassu.io\nexport CA_NAME=Test-CA\nexport DEVICE_ID=$(uuidgen)\nexport DMS_CERT=dms.crt\nexport DMS_KEY=dms.key  \n```\n!!! note\n    The name of the CA has to be that of a CA that has the DMS as Authorized_CAs.\n\nObtain the Root certificate used by the server\n    ```\n    openssl s_client -connect $DOMAIN:443  2&gt;/dev/null &lt;/dev/null |  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; root-ca.pem\n    ```\nEnrolling with a server-generated private key\n    ```\n    openssl genrsa 4096 &gt; key.pem\n    estclient csr -key key.pem -cn $DEVICE_ID -out csr.pem\n    estclient serverkeygen -server $DOMAIN/api/devmanager -explicit root-ca.pem -csr csr.pem -aps $CA_NAME -key $DMS_KEY -certs $DMS_CERT -out device.crt -keyout device.key\n    ```\n</code></pre> Go <pre><code>```go\n    package main\n\n    import (\n        \"context\"\n        \"crypto/x509\"\n        \"encoding/pem\"\n        \"fmt\"\n        \"io/ioutil\"\n        \"os\"\n\n        \"github.com/lamassuiot/lamassuiot/pkg/est/client\"\n    )\n\n    func main() {\n        estServerAddr := \"dev.lamassu.io/api/devmanager\"\n        servercrt := \"server.crt\"\n        dmscrt := \"dms.crt\"\n        dmskey := \"dms.key\"\n        devicecrt := \"device.crt\"\n        devicekey := \"device.key\"\n        devicecsr := \"device.csr\"\n        ca_name := \"Test-CA\"\n        caCert, err := ioutil.ReadFile(servercrt)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n        caCertPool := x509.NewCertPool()\n        caCertPool.AppendCertsFromPEM(caCert)\n\n        certContent, err := ioutil.ReadFile(dmscrt)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n        cpb, _ := pem.Decode(certContent)\n\n        crt, err := x509.ParseCertificate(cpb.Bytes)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n\n        certContent, err = ioutil.ReadFile(devicecsr)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n        cpb, _ = pem.Decode(certContent)\n\n        csr, err := x509.ParseCertificateRequest(cpb.Bytes)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n\n        key, err := ioutil.ReadFile(dmskey)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n\n        estClient, err := client.NewLamassuEstClient(estServerAddr, caCertPool, crt, key, nil)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n\n        cert, key, err := estClient.ServerKeyGen(context.Background(), ca_name, csr)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n        }\n        b := pem.Block{Type: \"CERTIFICATE\", Bytes: cert.Raw}\n        certPEM := pem.EncodeToMemory(&amp;b)\n        ioutil.WriteFile(devicecrt, certPEM, 0777)\n\n        b = pem.Block{Type: \"PRIVATE KEY\", Bytes: key}\n        keyPEM := pem.EncodeToMemory(&amp;b)\n        ioutil.WriteFile(devicekey, keyPEM, 0777)\n    }\n\n```\n</code></pre> <p>=== \"Curl\" Define environment variables as well as the</p> <pre><code>```\nexport DOMAIN=dev.lamassu.io\nexport CA_NAME=Test-CA\nexport DEVICE_ID=$(uuidgen)\nexport DMS_CERT=dms.crt\nexport DMS_KEY=dms.key  \n```\n!!! note\n    The name of the CA has to be that of a CA that has the DMS as Authorized_CAs.\n\nObtain the Root certificate used by the server\n    ```\n    openssl s_client -connect $DOMAIN:443  2&gt;/dev/null &lt;/dev/null |  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; root-ca.pem\n    ```\nCreate device CSR and private Key\n    ```\n    openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -subj \"/CN=$DEVICE_ID\"\n\n    sed '/CERTIFICATE/d' device.csr &gt; device_enroll.csr   \n    ```\nEnrolling with a server-generated private key\n    ```\n    curl https://$DOMAIN/api/devmanager/.well-known/est/$CA_NAME/serverkeygen --cert $DMS_CERT --key $DMS_KEY -s -o cert.p7 --cacert root-ca.pem  --data-binary @device_enroll.csr -H \"Content-Type: application/pkcs10\"\n\n    cat cert.p7 | sed -ne '/application\\/pkcs7-mime/,/-estServerKeyGenBoundary/p' |  sed '/-/d' &gt; crt.p7\n\n    openssl base64 -d -in crt.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device.pem\n\n    ```\n</code></pre>"},{"location":"setup/","title":"Setup","text":"<p>Lamassu Compose is the official release containing the scripts and resources required to deploy all microservices such as the CA component, the VA component or the RA components to name a few.</p>"},{"location":"setup/#requirements","title":"Requirements","text":"<ul> <li><code>jq</code>. Get the latest version: https://stedolan.github.io/jq/download/</li> <li><code>docker</code> and <code>docker-compose</code>: Get the latest version:   https://docs.docker.com/engine/install/ubuntu/ and   https://docs.docker.com/compose/install/</li> <li>Have a working DNS server able to resolve the domain used during the   installation process or add the following content to the <code>/etc/hosts</code> file,   replacing the <code>dev.lamassu.io</code> domain with your own:   <pre><code>127.0.0.1  dev.lamassu.io \n127.0.0.1  vault.dev.lamassu.io \n127.0.0.1  auth.dev.lamassu.io \n127.0.0.1  tracing.dev.lamassu.io \n127.0.0.1  consul.dev.lamassu.io \n</code></pre></li> </ul>"},{"location":"setup/#setup_1","title":"Setup","text":"<ol> <li>Get and run the installer script:</li> </ol> <pre><code>curl -fsSL https://raw.githubusercontent.com/lamassuiot/lamassu-compose/release/lamassu-compose.sh -o lamassu-compose.sh\nsudo bash lamassu-compose.sh --domain dev.lamassu.io --with-simulators --compose-version develop --simulation-version main\n</code></pre> <ol> <li>OPTIONAL: Import your certificates:</li> </ol> <p>The <code>lamassu-compose.sh</code> script also generates self-signed for the downstream    certificates. It is possible to provide other valid certificates by replacing    the following files:</p> <pre><code>lamassu-compose/tls-certificates\n\u251c\u2500\u2500 upstream\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 downstream\n    \u251c\u2500\u2500 tls.crt     &lt;----- Provide your certificate\n    \u2514\u2500\u2500 tls.key     &lt;----- Provide your private key\n</code></pre> <p>Once you replace this certificates, restart the api-gateway to obtain the    imported certificates:</p> <pre><code>docker-compose rm -s -f api-gateway dms-default\ndocker-compose up -d api-gateway dms-default\n</code></pre> <ol> <li>Final notes:</li> </ol> <p>\ud83d\ude80 You are ready to go \ud83d\ude80</p> <p>!!! note</p> <pre><code> Keycloak is your auth provider. During the installation process, the service is provisioned with 2 users with different roles:\n     ```\n     Username: enroller\n     Password: enroller\n     Role: admin\n     ```\n     ```\n     Username: operator\n     Password: operator\n     Role: operator\n     ```\n You can change those credentials (or create new users) using keycloak's UI available at: `https://auth.&lt;DOMAIN&gt;`\n</code></pre>"},{"location":"setup/#deploy-aws-iot-core-connectors","title":"Deploy AWS IoT Core connectors","text":""},{"location":"setup/#requirements_1","title":"Requirements","text":"<p>In order tu run the connector, you must have:</p> <ul> <li> <p>NodeJS: https://nodejs.org/en/</p> </li> <li> <p>AWS CDK v1: https://docs.aws.amazon.com/cdk/v1/guide/cli.html</p> </li> </ul>"},{"location":"setup/#deployment","title":"Deployment","text":"<ol> <li>Download the AWS Connector source code:</li> </ol> <pre><code>git clone https://github.com/lamassuiot/lamassu-aws-connector.git\n</code></pre> <ol> <li>Configure the AWS Credentials. Those values will be used by the Lamassu AWS    Connector as well as the CDK.</li> </ol> <pre><code>export AWS_ACCESS_KEY_ID=&lt;AWS_ACCESS_KEY_ID&gt;\nexport AWS_SECRET_ACCESS_KEY=&lt;AWS_SECRET_ACCESS_KEY&gt;\nexport AWS_ACCOUNT_ID=&lt;AWS_ACCOUNT_ID&gt;\nexport AWS_DEFAULT_REGION=&lt;AWS_DEFAULT_REGION&gt;\n</code></pre> <ol> <li>Provide a friendly name for the Lamassu AWS Connector. This name will be    displayed in the UI</li> </ol> <pre><code>export CONNECTOR_NAME=Lamassu IoT AWS Account\n</code></pre> <ol> <li>Substitute the aws-connector <code>.env</code> file:</li> </ol> <pre><code>envsubst &lt; .env | tee .env\n</code></pre> <ol> <li>Generate the TLS certificates used by the connector. You must have access to    the main CA certificate and private key that where generated during Lamassu    installation.</li> </ol> <pre><code>export INTERNAL_CA_CERT=&lt;CHANGE_TO_LAMASSU_INSTALLATION_PATH&gt;/tls-certificates/upstream/ca.crt\nexport INTERNAL_CA_KEY=&lt;CHANGE_TO_LAMASSU_INSTALLATION_PATH&gt;/tls-certificates/upstream/ca.key\n</code></pre> <p>After defining those variables, run the following OpenSSL commands:</p> <pre><code>openssl genrsa -out aws-connector.key 4096\nopenssl req -new -key aws-connector.key -out aws-connector.csr -subj \"/CN=aws-connector\" \nopenssl x509 -req -extfile &lt;(printf \"subjectAltName=DNS:aws-connector\") -in aws-connector.csr -days 365 -CA $INTERNAL_CA_CERT -CAkey $INTERNAL_CA_KEY -CAcreateserial -out aws.crt\n</code></pre> <ol> <li>Deploy the required AWS services by using the CDK:</li> </ol> <pre><code>cd aws-connector\nnpm i\ncdk deploy\n</code></pre> <ol> <li>Start the connector:</li> </ol> <pre><code>docker-compose up -d\n</code></pre>"},{"location":"simulation-tools/","title":"Lamassu Simulation Tools","text":"<p>It is recommended to follow this directory layout when deploying different Lamassu tools: <code>$HOME/          \u251c\u2500\u2500 lamassu-compose          \u251c\u2500\u2500 lamassu-simulation-tools</code></p> <ol> <li>Clone the repository and get into the directory:</li> </ol> <pre><code>git clone https://github.com/lamassuiot/lamassu-simulation-tools.git \ncd lamassu-simulation-tools\n</code></pre> <ol> <li>Basic configuration:</li> </ol> <pre><code>export DOMAIN=dev.lamassu.io\nexport LAMASSU_GATEWAY=https://${DOMAIN}\nexport AWS_IOT_ENDPOINT=\nexport AZURE_IOT_HUB_ENDPOINT=\nexport AZURE_DPS_ENDPOINT=\nexport AZURE_SCOPE_ID=\nenvsubst &lt; .env | tee .env  &gt; /dev/null\n</code></pre> <ol> <li>Run the VDMS and VDevice applications:</li> </ol> <pre><code>docker-compose up -d\n</code></pre>"},{"location":"simulation-tools/#virtual-dms","title":"Virtual DMS","text":"<p>When deploying the docker container with the virtual DMS, the DMS is accessible at http://dev.lamassu.io:7002.</p> <p>When accessing the Web interface, it is necessary to enter both the access credentials for the Operator user and the name of the DMS to be created.</p> <ul> <li>Operator Username: operator</li> <li>Operator Password: operator</li> <li>DMS Name: VirtualDMS</li> </ul> <p>When pressing the Register button the administrator has to approve the DMS, until the DMS is approved the VDMS cannot be used.</p> <p></p> <ol> <li>Admin - Authenticate the admin user</li> </ol> <pre><code>ENROLLER_USERNAME=enroller\nENROLLER_PASSWORD=enroller\nDOMAIN=dev.lamassu.io\n</code></pre> <pre><code>ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token)\n</code></pre> <ol> <li>Admin - Authorize the enrollment with all the provisioned CAs</li> </ol> <pre><code>export DMS_NAME=VirtualDMS\n</code></pre> <pre><code>AUTHORIZED_CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .cas[].name | jq -s)\n</code></pre> <pre><code>curl -k --location --request PUT \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME/status\" \\\n--header \"Authorization: Bearer $ENROLLER_TOKEN\" \\\n--data-raw \"{\\\"status\\\":\\\"APPROVED\\\"}\"\n</code></pre> <pre><code>curl -k --location --request PUT \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME/auth\" \\\n--header \"Authorization: Bearer $ENROLLER_TOKEN\" \\\n--data-raw \"{\\\"authorized_cas\\\":$AUTHORIZED_CAS}\"\n</code></pre> <p>Once approved, the DMS is operational and waiting for requests from the devices. In the Web interface you can select the CA through which you want to sign the device certificates Enroll Devices with CA.</p> <p></p> <p>When a request is received from a device the operator must approve the request and forward the request to Lamassu. Once Lamassu has issued the certificate, the same operator must transfer the certificate to the device. For this purpose, when a request is received in the Virtual DMS, the information of the request and a button to authorize the request appear in the Virtual DMS. On the other hand, when Lamassu issues the certificate, the message with the information of the certificate and a button to transfer the certificate to the device also appear in the Virtual DMS.</p> <p></p>"},{"location":"simulation-tools/#virtual-device","title":"Virtual Device","text":"<p>When deploying the docker container with the virtual DMS, the DMS is accessible at http://dev.lamassu.io:7001.</p> <p></p> <p>When accessing the Virtual Device Web interface for the first time, only the ISSUE FIRST IDENTITY option appears as available, this button is used to request a certificate from the device. This request is sent to the DMS and if the request is approved an identity is generated for the device. Once an identity is generated in the Web interface you can see the most relevant information, Certificate Serial Number, Issuer Certificate Authority and Expiration Date.</p> <p></p> <p>When a device has a valid identity and its status is PROVISIONED the identity can be renewed using the RENEW IDENTITY button, i.e. requesting a new certificate. This is usually done when the active identity is about to expire.</p> <p>On the other hand, in case you want to register a new device using the GENERATE SERIAL NUMBER button you can generate a new serial number simulating a new device. To register it, press the ISSUE FIRTS IDENTITY button as explained in the previous steps.</p>"},{"location":"tests/","title":"Tests","text":"<p>Integration test are carried out to check the proper functionabillity of the server. The tests, start up the same server used in production with an empty database and run against the server using HTTP.</p> <p>To create the test, httpexpect library has been used; a set of chainable builders for HTTP requests and assertions for HTTP responses and payload, on top of net/http and several utility packages.</p> <p>Each test-case has three arguments: the name of the test, an instance of the service and a httpexpect.Expect object, upon which the rest call will be made.</p> <p>Passing an instance of the service per test, allows custom inicialization of the database per test. Also, as the service used is the exact same used in production, the calls made from one service to another are mantained, allowing to check the interoperability from services.</p> <p>The response obtained from the httpexpect.Expect object will be evaluated; the response's keys and values will be revised to compare with the expected ones. If the expected results don\u00b4t match with the obtained ones, an error will occur, allowing the developers to notice and fix it before releasing it into production.</p> <p>Three different branches are differenciated:</p> <ul> <li>Development: this branch is used for testing purposes whenever a service is   modified to check the proper functionabillity of the same service.</li> <li>Release: this branch is used for testing purposes whenever a service is   modified to check the proper functionabillity of the all services.</li> <li>Main: once the test are passed successfully, changes are published in main   branch.</li> </ul>"},{"location":"tests/#coverage","title":"Coverage","text":"<p>The following commands can be used to calculate the coverage of the system:</p> <pre><code>go test -json -v ./pkg/... -cover  -coverprofile=coverage.out -coverpkg=./...\ngo tool cover -html=coverage.out -o coverage.html\n\ngo tool cover -func coverage.out | grep total | awk '{print substr($3, 1, length($3)-1)}' | .github/coverage-badge.sh\ngo tool cover -func coverage.out | grep total\n</code></pre> <p>The total and relative percentages of each component can be found in the resulting cover.html file. Opening the file in the browser, will mark the tested code in green and the untested one in red.</p> <p>The resulting cover.out file, can be imported to go-cover-treemap.io webpage to generate a visual representation of the coverage results:</p> <p></p>"},{"location":"tests/#pipeline","title":"Pipeline","text":"<p>The test are run against the server using HTTP, the top layer of the system. Facilitating the task of testing the layers below.</p> <p></p>"},{"location":"usage/","title":"Getting Started","text":"<p>Before jumping any further, please check out the installation process to deploy all Lamassu services. This section will guide you through the basic functionalities provided by our PKI to start provisioning your devices.</p>"},{"location":"usage/#overview","title":"Overview","text":""},{"location":"usage/#create-a-new-certification-authority","title":"Create a new Certification Authority","text":"<p>The first step to provision your devices with digital certificates is to create the Certification Authority. The role of a CA is to issue and manage all the certificates. To create a new CA, fill the following form taking into account the following things:</p> <ul> <li>Lamassu supports both <code>RSA</code> and <code>EC</code> based CAs.</li> <li>The CA name MUST be unique.</li> <li>The CA expiration time must be greater than the lifespan of the issued certs.</li> </ul> <p> </p>"},{"location":"usage/#register-a-new-device-manufacturing-system","title":"Register a new Device Manufacturing System","text":"<p>Lamassu is a PKI designed for the industrial and IoT sector. To better integrate this PKI in real life manufacturing system, Lamassu delegates the issuance of device certificate to the factory itself. First lets dive into the Device Manufacturing System (DMS for short) registration step by step. After that, a couple of examples will demonstrate how to start enrolling your devices using the Lamassu's Virtual DMS software as well as using the UI.</p> <p>Device manufacturing process tend to be highly automated. Provisioning the devices with digital identities should not slow down the fabrication process. Lamassu addresses this challenge introducing the DMS concept as core.</p> <p>One of the factories operators stars the process by generating a DMS registration request contained in a Certificate Signing Request also referred as CSR. This CSR is then sent to the DMS Enroller service to be approved by one of the PKI Administrators:</p> <p></p> <p>The Administrator then decides if the request is approved or denied. If it decision is to approve the DMS registration request, the Administrator must specify which CAs will that particular DSM be entitled to issue certificates with:</p> <p></p> <p>Once, and only if, the DMS registration request is approved, then the Operator must retrieve the signed CSR and pass it to the DMS software that will be in charge off requesting the issuance of new digital certificates for the manufactured devices:</p> <p></p> <p>Finally, the DMS is able to request new x509 certificates for its manufactured devices. The DMS may be assisted by additional tools to obtain the manufactured device unique identifier.</p> <p></p> <p>!!! note Envoy is used as an API gateway in this project. Currently Envoy is written to use Boring SSl as the TLS provider. It does not support secp224r1 signing method, which is used to create ECDSA224 keys. Therefore, enroll and reenroll methods will return a error when using this key.</p> <p>Let's register a new DMS instance:</p>"},{"location":"usage/#manual-dms","title":"Manual DMS","text":"<ol> <li>Operator - Authenticate the user:</li> </ol> <pre><code>OPERATOR_USERNAME=operator\nOPERATOR_PASSWORD=operator\nDOMAIN=dev.lamassu.io\n</code></pre> <pre><code>OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token)\n</code></pre> <ol> <li>Operator - Request the registration for a new DMS instance:</li> </ol> <pre><code>DMS_NAME=MyDMS\nDMS_SUBJECT_COUNTRY=ES\nDMS_SUBJECT_STATE=Gipuzkoa\nDMS_SUBJECT_LOCALITY=Donostia\nDMS_SUBJECT_ORGANIZATION=Lamassu\nDMS_SUBJECT_ORGANIZATION_UNIT=IoT\n</code></pre> <pre><code>DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsmanager/v1/\" \\\n--header \"Authorization: Bearer $OPERATOR_TOKEN\" \\\n--data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"organization_unit\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}}\")\nDMS_NAME=$(echo $DMS_REG_RESPONSE | jq -r .dms.name)\necho $DMS_REG_RESPONSE | jq -r .private_key | base64 -d &gt; dms.key\n</code></pre> <ol> <li>Admin - Authenticate the admin user</li> </ol> <pre><code>ENROLLER_USERNAME=enroller\nENROLLER_PASSWORD=enroller\nDOMAIN=dev.lamassu.io\n</code></pre> <pre><code>ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token)\n</code></pre> <ol> <li>Admin - Authorize the enrollment with all the provisioned CAs</li> </ol> <pre><code>AUTHORIZED_CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .cas[].name | jq -s)\n</code></pre> <pre><code>curl -k --location --request PUT \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME/status\" \\\n--header \"Authorization: Bearer $ENROLLER_TOKEN\" \\\n--data-raw \"{\\\"status\\\":\\\"APPROVED\\\"}\"\n</code></pre> <pre><code>curl -k --location --request PUT \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME/auth\" \\\n--header \"Authorization: Bearer $ENROLLER_TOKEN\" \\\n--data-raw \"{\\\"authorized_cas\\\":$AUTHORIZED_CAS}\"\n</code></pre> <ol> <li>Operator - Get the DMS certificate:</li> </ol> <pre><code>curl -k \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .certificate | base64 -d &gt; dms.crt \n</code></pre>"},{"location":"usage/#cloud-hosted-dms","title":"Cloud Hosted DMS","text":"<p>When creating a Cloud Hosted DMS the Payload of the request has three more parameters:</p> <ul> <li>BootstrapCAs: Bootstrap CAs, i.e. the Bootstrap certificate used by the   device has to be issued by one of these CAs, in case it is not issued by any   of these CAs the device request will not be authorized.</li> <li>IsCloudDMS: It is a boolean parameter. In this case it always has the same   value true.</li> </ul> <p>Let's register a new Cloud Hosted DMS instance:</p> <ol> <li>Operator - Authenticate the user:</li> </ol> <pre><code>OPERATOR_USERNAME=operator\nOPERATOR_PASSWORD=operator\nDOMAIN=dev.lamassu.io\n</code></pre> <pre><code>OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token)\n</code></pre> <ol> <li>Admin - Authenticate the admin user</li> </ol> <pre><code>ENROLLER_USERNAME=enroller\nENROLLER_PASSWORD=enroller\nDOMAIN=dev.lamassu.io\n</code></pre> <pre><code>ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token)\n</code></pre> <ol> <li>Admin - Get all the provisioned CAs</li> </ol> <pre><code>CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .cas[].name | jq -s)\n</code></pre> <ol> <li>Operator - Request the registration for a new DMS instance:</li> </ol> <pre><code>DMS_NAME=HostCloudDMS\nDMS_SUBJECT_COUNTRY=ES\nDMS_SUBJECT_STATE=Gipuzkoa\nDMS_SUBJECT_LOCALITY=Donostia\nDMS_SUBJECT_ORGANIZATION=Lamassu\nDMS_SUBJECT_ORGANIZATION_UNIT=IoT\n</code></pre> <pre><code>DMS_REG_RESPONSE=$(curl -k --location --request POST \"https://$DOMAIN/api/dmsmanager/v1/\" \\\n--header \"Authorization: Bearer $OPERATOR_TOKEN\" \\\n--data-raw \"{\\\"key_metadata\\\": {\\\"bits\\\":3072, \\\"type\\\":\\\"RSA\\\"}, \\\"subject\\\":{\\\"common_name\\\":\\\"$DMS_NAME\\\", \\\"country\\\":\\\"$DMS_SUBJECT_COUNTRY\\\",\\\"locality\\\":\\\"$DMS_SUBJECT_LOCALITY\\\",\\\"organization\\\":\\\"$DMS_SUBJECT_ORGANIZATION\\\",\\\"organization_unit\\\":\\\"$DMS_SUBJECT_ORGANIZATION_UNIT\\\",\\\"state\\\":\\\"$DMS_SUBJECT_STATE\\\"}, \\\"host_cloud_dms\\\":true, \\\"bootstrap_cas\\\":$CAS }\")\n\nDMS_NAME=$(echo $DMS_REG_RESPONSE | jq -r .dms.name)\necho $DMS_REG_RESPONSE | jq -r .private_key | base64 -d &gt; dms.key\n</code></pre> <ol> <li>Admin - Authenticate the admin user</li> </ol> <pre><code>ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token)\n</code></pre> <ol> <li>Admin - Authorize the enrollment with all the provisioned CAs</li> </ol> <pre><code>AUTHORIZED_CAS=$(curl -k \"https://$DOMAIN/api/ca/v1/pki\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" | jq .cas[].name | jq -s)\n</code></pre> <pre><code>curl -k --location --request PUT \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME/status\" \\\n--header \"Authorization: Bearer $ENROLLER_TOKEN\" \\\n--data-raw \"{\\\"status\\\":\\\"APPROVED\\\"}\"\n</code></pre> <pre><code>AUTHORIZED_CA=$(echo $AUTHORIZED_CAS | jq .[0] -r)\n</code></pre> <pre><code>curl -k --location --request PUT \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME/auth\" \\\n--header \"Authorization: Bearer $ENROLLER_TOKEN\" \\\n--data-raw \"{\\\"authorized_cas\\\":[\\\"$AUTHORIZED_CA\\\"]}\"\n</code></pre> <ol> <li>Operator - Get the DMS certificate:</li> </ol> <pre><code>curl -k \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq -r .certificate | base64 -d &gt; dms.crt \n</code></pre>"},{"location":"usage/#provision-your-devices-with-x509-certificates","title":"Provision your devices with x509 Certificates","text":"<p>The enrollment process is the way to go to obtain a certificate issued by one of the provisioned CAs. As described in the RFC document, Lamassu requires the authentication of the client requesting the enrollment using a certificate as well as the private key of an issued DMS to perform a mutual TLS connection. By using this type of TLS connection, the client is able to authenticate the server, and also, the server is able to authenticate the client.</p> <p>Although the <code>/api/devmanager/.well-known/cacerts</code> endpoint returns the list containing all the manged CAs by the PKI, each DMS is entitled to request the issuance of a certificate with an authorized CA. For instance, the PKI may have the following CAs: <code>CA1</code>, <code>CA2</code>, <code>CA3</code> and <code>CA4</code>. The <code>/api/devmanager/.well-known/cacerts</code> would return all four CAs. Then, a new DMS is registered. the PKI administrator approves the DMS registration by authorizing such DMS to issue certificates with <code>CA1</code> and <code>CA4</code>. This process is known as the DMS registration process. Once the DMS is completely registered, it can now start performing the EST enrollment process. Check out the previous section to understand what a DMS does.</p> <p>Let's first obtain the CA list for a particular DMS:</p>"},{"location":"usage/#manual-dms_1","title":"Manual DMS","text":"<ol> <li>First, authenticate and obtain a valid JWT</li> </ol> <pre><code>OPERATOR_USERNAME=operator\nOPERATOR_PASSWORD=operator\nDOMAIN=dev.lamassu.io\n</code></pre> <pre><code>OPERATOR_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$OPERATOR_USERNAME\" --data-urlencode \"password=$OPERATOR_PASSWORD\" | jq -r .access_token)\n</code></pre> <ol> <li>Obtain the CA list:</li> </ol> <pre><code>ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .authorized_cas)\n</code></pre> <ol> <li>Select one of the entitled the CAs from the previous list:</li> </ol> <pre><code>!!! note\n    You can manually spefify the `SELECTED_CA`. Otherwise you can enroll the device with the first entitled CA using the following command.\n\n```\nSELECTED_CA=$(echo $ENTITLED_CAS | jq .[0] -r)\n```\n</code></pre> <ol> <li>Generate the device CSR:</li> </ol> <pre><code>DEVICE_ID=mytestdevice-123\n</code></pre> <pre><code>openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -outform DER -subj \"/CN=$DEVICE_ID\"\n\nopenssl base64 -in device.csr -out device.b64 -e\n</code></pre> <ol> <li>Enroll the device:</li> </ol> <pre><code>DMS_CRT_PATH=path/to/dms_crt\nDMS_KEY_PATH=path/to/dms_key\n</code></pre> <pre><code>openssl s_client -connect $DOMAIN:443 2&gt;/dev/null &lt;/dev/null |  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; root-ca.pem\n\ncurl https://$DOMAIN/api/devmanager/.well-known/est/$SELECTED_CA/simpleenroll --cert $DMS_CRT_PATH --key $DMS_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem  --data @device.b64 -H \"Content-Type: application/pkcs10\" -H \"Content-Transfer-Encoding: base64\"\n\nopenssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem \n\nopenssl x509 -text -in device-cert.pem\n</code></pre>"},{"location":"usage/#cloud-hosted-dms_1","title":"Cloud Hosted DMS","text":"<ol> <li>First, authenticate and obtain a valid JWT</li> </ol> <pre><code>ENROLLER_USERNAME=enroller\nENROLLER_PASSWORD=enroller\nDOMAIN=dev.lamassu.io\n</code></pre> <pre><code>ENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token)\n</code></pre> <ol> <li>Obtain the Bootstrap CA list:</li> </ol> <pre><code>ENTITLED_CAS=$(curl -k --location --request GET \"https://$DOMAIN/api/dmsmanager/v1/$DMS_NAME\" --header \"Authorization: Bearer $OPERATOR_TOKEN\" | jq .bootstrap_cas)\n</code></pre> <ol> <li>Select one of the entitled the CAs from the previous list:</li> </ol> <pre><code>!!! note\n    You can manually spefify the `BOOTSTRAP_CA`. \n\n```\nBOOTSTRAP_CA=$(echo $ENTITLED_CAS | jq .[0] -r)\n```\n</code></pre> <ol> <li>Generate the Bootstrap CSR:</li> </ol> <pre><code>DEVICE_ID=bootstrap\n</code></pre> <pre><code>openssl req -new -newkey rsa:2048 -nodes -keyout bootstrap.key -out bootstrap.csr -subj \"/CN=$DEVICE_ID\"\n</code></pre> <ol> <li>Admin - Authenticate the admin user</li> </ol> <pre><code>```\nENROLLER_TOKEN=$(curl -k -s --location --request POST \"https://auth.$DOMAIN/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode \"username=$ENROLLER_USERNAME\" --data-urlencode \"password=$ENROLLER_PASSWORD\" | jq -r .access_token)\n```\n</code></pre> <ol> <li>Admin - Get Bootstrap Certificate</li> </ol> <pre><code>openssl s_client -connect $DOMAIN:443 2&gt;/dev/null &lt;/dev/null |  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; root-ca.pem\n\nCSR_B64=$(openssl base64 -in bootstrap.csr -e | tr -d [:space:])\n\nBOOTSTRAP_CERT=$(curl -k --location --request POST \"https://$DOMAIN/api/ca/v1/pki/$BOOTSTRAP_CA/sign\" --header \"Authorization: Bearer $ENROLLER_TOKEN\" --data-raw \"{\\\"certificate_request\\\":\\\"$CSR_B64\\\", \\\"common_name\\\":\\\"bootstrap\\\",\\\"sign_verbatim\\\":true}\")\n\necho $BOOTSTRAP_CERT | jq -r .certificate | base64 -d &gt; bootstrap.crt \n</code></pre> <ol> <li>Enroll the device:</li> </ol> <pre><code>DEVICE_ID=mytestdevice-123\n</code></pre> <pre><code>openssl req -new -newkey rsa:2048 -nodes -keyout device.key -out device.csr -outform DER -subj \"/CN=$DEVICE_ID\"\n\nopenssl base64 -in device.csr -out device.b64 -e\n</code></pre> <pre><code>BOOTSTRAP_CRT_PATH=path/to/bootstrap_crt\nBOOTSTRAP_KEY_PATH=path/to/bootstrap_key\n</code></pre> <pre><code>openssl s_client -connect $DOMAIN:443 2&gt;/dev/null &lt;/dev/null |  sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; root-ca.pem\n\ncurl https://$DOMAIN/api/dmsmanager/.well-known/est/$DMS_NAME/simpleenroll --cert $BOOTSTRAP_CRT_PATH --key $BOOTSTRAP_KEY_PATH -s -o device-cert.p7 --cacert root-ca.pem  --data @device.b64 -H \"Content-Type: application/pkcs10\" -H \"Content-Transfer-Encoding: base64\"\n\nopenssl base64 -d -in device-cert.p7 | openssl pkcs7 -inform DER -outform PEM -print_certs -out device-cert.pem \n\nopenssl x509 -text -in device-cert.pem\n</code></pre>"},{"location":"usage/#using-the-ui","title":"Using the UI","text":"<p>The UI is an easy manageable tool designed to ease the burdens to non-technical users in using Lamassu PKI. This project was bootstrapped with Create React App.</p> <p>You can learn more in the Create React App documentation.</p> <p></p>"},{"location":"usage/#deployment","title":"Deployment","text":"<p>This section has moved here: https://facebook.github.io/create-react-app/docs/deployment</p>"},{"location":"usage/#create-a-new-certification-authority_1","title":"Create a new Certification Authority","text":"<p>There are two methos of creating a new CA from the UI.</p> <p>The first one, filling the following form taking into account the following things:</p> <ul> <li>Lamassu supports both <code>RSA</code> and <code>EC</code> based CAs.</li> <li>The CA name MUST be unique.</li> <li>The CA expiration time must be greater than the lifespan of the issued certs.</li> </ul> <p> </p> <p>The other one, will be importing it. A Certificate and a Private Key will be required.</p> <p></p>"},{"location":"usage/#registration-of-a-dms-using-the-ui","title":"Registration of a DMS using the UI","text":"<p>Using the UI, creating a new DMS is as simple as filling the following form.</p> <p>Manual DMS</p> <p></p> <p>Cloud Hosted DMS</p> <p></p> <p>Once the DMS has been created successfully, a prompt showing the generated private key will be shown. It is encouraged to download it just after the creation as this prompt will be shown only once.</p> <p></p> <p>The status of the new created DMS will be <code>Pending Approval</code>, to approve it, we must select at least one CA from the list of registered CAs. The selected CAs will be the authorised ones to sign certificates from now on.</p> <p></p> <p></p>"},{"location":"usage/#registration-of-a-device-using-the-ui","title":"Registration of a device using the UI","text":"<p>To create a device, we will need to fill the following form taking into account:</p> <ul> <li>A device identification must be provided.</li> <li>A DMS must be assigned.</li> </ul> <p></p> <p>Each device can have certificates signed by different authorised CAs.</p> <p></p> <p>The certificates of each device as well as the cloud-connectors will be showned.</p> <p></p>"},{"location":"usage/#using-the-apis","title":"Using the APIs","text":"<p>The main 3 Open API documentation can be found on the following urls:</p> <ul> <li>https://dev.lamassu.io/api/dmsmanager/v1/docs/</li> <li>https://dev.lamassu.io/api/ca/v1/docs/</li> <li>https://dev.lamassu.io/api/devmanager/v1/docs/</li> </ul> <p>Note</p> <pre><code>The following endpoints defined in the Lamassu Device Manager Api specification are not correctly defined due to the limitations imposed by the Open API 3.0 schema. The current specification defines an `OIDC` security schema (meaning that a valid JWT token must be provided while requesting the API) while the implemented security schema uses the `mTLS` approach. This issue will be resolved once the specification is migrated to Open API 3.1 compliant. The affected endpoints are:\n![Screenshot](img/missing-mtls-openapi.png)\n</code></pre> <p>Lamassu provides easy to use GO clients for most of its APIs to help speeding up the development of third-party applications. Before using thees clients, it is important to identify the path taken by the request. Unless the application using the GO clients (or any other http client such as <code>curl</code>) is deployed within the same docker network, the request will be handled by the API Gateway component. Otherwise check the internal usage section.</p>"},{"location":"usage/#through-the-api-gateway","title":"Through the API Gateway","text":"Go <pre><code>``` go\npackage main\n\nimport (\n\"net/url\"\nlamassuCAClient \"github.com/lamassuiot/lamassuiot/pkg/ca/client\"\ncaDTO \"github.com/lamassuiot/lamassuiot/pkg/ca/common/dto\"\n\"github.com/lamassuiot/lamassuiot/pkg/utils/client\"\n)\n\nfunction main (){\n    lamassuGatewayURL := \"dev.lamassu.io\"\n    apiCAFile := \"path/to/apigw.crt\"\n\n    caClient := lamassuCAClient.NewLamassuCAClient(client.ClientConfiguration{\n        URL: &amp;url.URL{\n            Scheme: \"https\",\n            Host:   lamassuGatewayURL,\n            Path:   \"/api/ca/\",\n        },\n        AuthMethod: client.JWT,\n        AuthMethodConfig: &amp;client.JWTConfig{\n            Username: \"enroller\",\n            Password: \"enroller\",\n            URL: &amp;url.URL{\n                Scheme: \"https\",\n                Host:   \"auth.\" + lamassuGatewayURL,\n            },\n            CACertificate: apiCAFile,\n        },\n        CACertificate: apiCAFile,\n    })\n\n    ca, err = caClient.CreateCA(context.Background(), caDTO.Pki, caName, caDTO.PrivateKeyMetadata{KeyType: \"rsa\", KeyBits: 2048}, caDTO.Subject{CN: caName}, 365*time.Hour, 30*time.Hour)\n}\n```\n</code></pre> <p>=== \"Curl\" Define the DOMAIN, TOKEN and CA_NAME <code>export AUTH_ADDR=auth.$DOMAIN          export TOKEN=$(curl -k --location --request POST \"https://$AUTH_ADDR/auth/realms/lamassu/protocol/openid-connect/token\" --header 'Content-Type: application/x-www-form-urlencoded' --data-urlencode 'grant_type=password' --data-urlencode 'client_id=frontend' --data-urlencode 'username=enroller' --data-urlencode 'password=enroller' | jq -r .access_token)         export CA_ADDR=$DOMAIN/api/ca         export CA_NAME=$(uuidgen)</code> Creting CA <code>export CREATE_CA_RESP=$(curl -k -s --location --request POST \"https://$CA_ADDR/v1/pki\" --header \"Authorization: Bearer ${TOKEN}\" --header 'Content-Type: application/json' --data-raw \"{\\\"ca_duration\\\": 262800, \\\"issuance_duration\\\": 175200, \\\"subject\\\":{ \\\"common_name\\\": \\\"$CA_NAME\\\",\\\"country\\\": \\\"ES\\\",\\\"locality\\\": \\\"Arrasate\\\",\\\"organization\\\": \\\"LKS Next, S. Coop\\\",\\\"state\\\": \\\"Gipuzkoa\\\"},\\\"key_metadata\\\":{\\\"bits\\\": 4096,\\\"type\\\": \\\"RSA\\\"}}\")</code></p>"},{"location":"usage/#running-unit-tests","title":"Running Unit tests","text":"<pre><code>#For pretty printing\ngo install github.com/haveyoudebuggedit/gotestfmt/v2/cmd/gotestfmt@v2.3.1\n\n\ngo test -json -v ./pkg/ca/server/api/ | gotestfmt\ngo test -json -v ./pkg/dms-manager/server/api/ | gotestfmt\ngo test -json -v ./pkg/device-manager/server/api/ | gotestfmt\n</code></pre>"},{"location":"usage/#filtering-sorting-and-pagination","title":"Filtering, Sorting and Pagination","text":"<p>Lamassu API supports filtering, sorting and pagination.</p> <p>The filter can be form by the following parameters, being each of them optional:</p> <ul> <li><code>filter= attribute[operator]=value</code></li> <li><code>sort_by=attribute.[asc|desc]</code></li> <li><code>limit=value</code> . Limits the maximun number of results of the query</li> <li><code>offset=value</code> . In addition to <code>limit</code>, implements pagination. It defines the   index of the first value from the resulting query.</li> </ul> <p>Example</p> <pre><code>```\n /v1/devices?filter=id[contains]=device_id&amp;sort_by=id.asc&amp;limit=100&amp;offset=15\n\n /v1?filter=id[contains]=dms_id&amp;sort_by=id.desc\n```\n</code></pre>"},{"location":"usage/#operators","title":"Operators","text":"<p>Depending of the data type of the parameters, the supported operators will vary.</p> <ul> <li>Strings : <code>equals</code>, <code>notequals</code>, <code>contains</code>, <code>notcontains</code></li> <li>Dates: <code>before</code>, <code>after</code>, <code>is</code>, <code>isnot</code></li> <li>Enums: <code>is</code>, <code>isnot</code></li> <li>Numbers: <code>lessthan</code>, <code>greaterthan</code>, <code>lessorequal</code>, <code>gretaerorequal</code>, <code>equal</code>,   <code>notequal</code></li> </ul>"}]}